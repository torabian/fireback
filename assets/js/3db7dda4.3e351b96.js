"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[4520],{3148:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>d,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"tasks-in-fireback","title":"Tasks","description":"Tasks, are an important aspect of many projects, they can be cronjobs, or triggered","source":"@site/docs/tasks-in-fireback.mdx","sourceDirName":".","slug":"/tasks-in-fireback","permalink":"/fireback/docs/tasks-in-fireback","draft":false,"unlisted":false,"editUrl":"https://github.com/torabian/fireback/tree/main/docs/docs/tasks-in-fireback.mdx","tags":[],"version":"current","sidebarPosition":8.6,"frontMatter":{"title":"Tasks","sidebar_position":8.6},"sidebar":"tutorialSidebar","previous":{"title":"Messages","permalink":"/fireback/docs/messages"},"next":{"title":"Queries and VSQL","permalink":"/fireback/docs/queries-and-vsql"}}');var a=n(4848),i=n(8453);const r={title:"Tasks",sidebar_position:8.6},o=void 0,d={},c=[{value:"Purpose of tasks",id:"purpose-of-tasks",level:2},{value:"Define and register tasks",id:"define-and-register-tasks",level:2},{value:"Using generated tasks",id:"using-generated-tasks",level:2},{value:"Check for list of tasks",id:"check-for-list-of-tasks",level:2},{value:"Running task server",id:"running-task-server",level:2},{value:"Other details a tasks need",id:"other-details-a-tasks-need",level:2}];function l(e){const s={code:"code",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(s.p,{children:"Tasks, are an important aspect of many projects, they can be cronjobs, or triggered\nby an event. Fireback supports such features both internally and connecting with external\nservices such as SQS."}),"\n",(0,a.jsxs)(s.p,{children:["Fireback generates the tasks on module level, and they are registered across the ",(0,a.jsx)(s.code,{children:"*workspaces.FirebackApp"}),"\nand accessible through the hole app. The reason is, the task server is single per app,\nand it won't be started by each module independently."]}),"\n",(0,a.jsx)(s.h2,{id:"purpose-of-tasks",children:"Purpose of tasks"}),"\n",(0,a.jsx)(s.p,{children:"Tasks, are golang actions, which can be triggered either by a messaging system (event system such as redis) or\ntriggered automatically with cronjob ticks."}),"\n",(0,a.jsx)(s.p,{children:"Few examples:"}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsx)(s.li,{children:"Postprocesss video, when a user uploads vide. You can define a video post process task."}),"\n",(0,a.jsx)(s.li,{children:"Make a cronjob on each night to send marketing emails."}),"\n"]}),"\n",(0,a.jsx)(s.h2,{id:"define-and-register-tasks",children:"Define and register tasks"}),"\n",(0,a.jsxs)(s.p,{children:["In this example, first we need to create a new Module called ",(0,a.jsx)(s.code,{children:"media"})," and we continue adding tasks\nto that file.\nBy having in MediaModule3.yml, defining tasks could be easily defined via Module3.yml files.\nLet's create a postVideoProcessing task:"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-yaml",children:"name: media\ntasks:\n  - name: postProcessVideo\n    description: Listens to the post process videos and converts them into different sizes\n    in:\n      fields:\n        - name: videoUniqueId\n          type: string\n          validate: required\n"})}),"\n",(0,a.jsxs)(s.p,{children:["This will generated set of codes in ",(0,a.jsx)(s.code,{children:"MediaModule.dyno.go"}),":"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-go",children:'type LicensesTasksContext struct {\n\tPostProcessVideo func(body *PostProcessVideoTaskParams, tx *workspaces.TaskCtx) error\n}\n\nfunc (x *LicensesTasksContext) GetTasks() []*workspaces.TaskAction {\n\treturn []*workspaces.TaskAction{\n\t\t{\n\t\t\tName: "PostProcessVideo",\n\t\t\tHandlerFunc: func(ctx *workspaces.TaskCtx, content []byte) error {\n\t\t\t\tvar body *PostProcessVideoTaskParams\n\t\t\t\tif err := json.Unmarshal(content, &body); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\treturn x.PostProcessVideo(body, &workspaces.TaskCtx{})\n\t\t\t},\n            ....\n'})}),"\n",(0,a.jsx)(s.p,{children:"There might be more code generated which would be different based on the cronjob definition."}),"\n",(0,a.jsx)(s.h2,{id:"using-generated-tasks",children:"Using generated tasks"}),"\n",(0,a.jsxs)(s.p,{children:["Tasks are ",(0,a.jsx)(s.strong,{children:"not"})," being automatically included via modules. You need to go to your ",(0,a.jsx)(s.code,{children:"MediaModule.go"})," and create\na context, and pass them to the Module:"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-go",children:'func MediaModuleSetup(cfg *MediaModuleConfig) *workspaces.ModuleProvider {\n\t// Create the context\n\tctx := MediaTasksContext{}\n\tmodule := &workspaces.ModuleProvider{\n\t\tName: "media",\n        Definitions: &Module3Definitions,\n\n\t\t// Add the following line:\n\t\tTasks: ctx.GetTasks(),\n'})}),"\n",(0,a.jsx)(s.p,{children:"Now, all the tasks you have defined will become available in your project."}),"\n",(0,a.jsx)(s.h2,{id:"check-for-list-of-tasks",children:"Check for list of tasks"}),"\n",(0,a.jsxs)(s.p,{children:["Any Fireback app (and itself) would have a ",(0,a.jsx)(s.code,{children:"tasks"})," command. By running list command, you'll see all of the\navailable tasks in the project:"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-bash",children:"ali@alis-MacBook-Pro fireback % ./app tasks list\nPostProcessVideo\n"})}),"\n",(0,a.jsxs)(s.p,{children:["Also you can see the parameters of the task via ",(0,a.jsx)(s.code,{children:"enqueue"})," task"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-bash",children:"ali@alis-MacBook-Pro fireback % ./app tasks enqueue PostProcessVideo --help\nNAME:\n   Fireback core microservice - v1.1.28 tasks enqueue PostProcessVideo - \n\nUSAGE:\n   Fireback core microservice - v1.1.28 tasks enqueue PostProcessVideo [command options] [arguments...]\n\nOPTIONS:\n   --video-unique-id value  videoUniqueId\n"})}),"\n",(0,a.jsx)(s.h2,{id:"running-task-server",children:"Running task server"}),"\n",(0,a.jsxs)(s.p,{children:["By default, Fireback is using ",(0,a.jsx)(s.code,{children:"github.com/hibiken/asynq"})," library to manage tasks.\nIt depends on the redis, and needs to be available on ",(0,a.jsx)(s.code,{children:"127.0.0.1:6379"})," by default.\nThis can be changed via setting ",(0,a.jsx)(s.code,{children:"WORKER_ADDRESS=127.0.0.1:6379"})," to different one.\nThere should be a support for SQS later on and easily, you can contribute it to project if you wanted."]}),"\n",(0,a.jsx)(s.p,{children:"Tasks server is not running by default, you need to run it via:"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{children:"./app tasks start\n"})}),"\n",(0,a.jsxs)(s.p,{children:["You can avoid the separate task server by setting ",(0,a.jsx)(s.code,{children:"WITH_TASK_SERVER=true"})," in env file to true,\nthen it would be starting with your ",(0,a.jsx)(s.code,{children:"./app start"})," functionality."]}),"\n",(0,a.jsx)(s.h1,{id:"enqueue-a-task",children:"Enqueue a task"}),"\n",(0,a.jsx)(s.p,{children:"While tasks server is running, you can enqueue them via cli or golang."}),"\n",(0,a.jsx)(s.p,{children:"Via CLI:"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-bash",children:"./app tasks enqueue PostProcessVideo --video-unique-id 809182ji392879\n"})}),"\n",(0,a.jsx)(s.p,{children:"That might be handly for external events, but you can also trigger that in golang inside any action:"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-go",children:'task, err := NewPostProcessVideoTask(&PostProcessVideoTaskParams{\n    VideoUniqueId: &uid,\n})\nif err != nil {\n    fmt.Println("Error on enqueue task PostProcessVideo: %w", err)\n    return err\n}\nresult, err2 := workspaces.EnqueueTask(task)\nif err2 == nil {\n    fmt.Println("task is in queue, id: %s", result.ID)\n    return nil\n}\n'})}),"\n",(0,a.jsxs)(s.p,{children:[(0,a.jsx)(s.strong,{children:"If a cronjob be added to the action, it would be automatically triggered"}),":"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-yaml",children:"tasks:\n  - name: postProcessVideo2\n    description: Listens to the post process videos and converts them into different sizes\n    in:\n      fields:\n        - name: videoUniqueId\n          type: string\n          validate: required\n    triggers:\n      - cron: '* * * * *'\n"})}),"\n",(0,a.jsx)(s.p,{children:"This would add the cron to generated code:"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-go",children:'...\n    Flags: PostProcessVideo2CommonCliFlagsOptional,\n    Triggers: []*workspaces.Module3Trigger{\n        {\n            Cron: "* * * * *",\n        },\n    },\n...\n'})}),"\n",(0,a.jsx)(s.h2,{id:"other-details-a-tasks-need",children:"Other details a tasks need"}),"\n",(0,a.jsx)(s.p,{children:"Obviously, the task manager in Fireback could be much more complicated to support the SQS,\nand much more details. I am interested to have those features developed by someone else,\nbecause in projects I do the current solution is enough."})]})}function u(e={}){const{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,a.jsx)(s,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},8453:(e,s,n)=>{n.d(s,{R:()=>r,x:()=>o});var t=n(6540);const a={},i=t.createContext(a);function r(e){const s=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),t.createElement(i.Provider,{value:s},e.children)}}}]);