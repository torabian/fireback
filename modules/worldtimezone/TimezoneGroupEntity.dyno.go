package worldtimezone

/*
*	Generated by fireback 1.1.27
*	Written by Ali Torabi.
*	Checkout the repository for licenses and contribution: https://github.com/torabian/fireback
 */
import (
	"embed"
	"encoding/json"
	"fmt"
	"github.com/gin-gonic/gin"
	"github.com/gookit/event"
	jsoniter "github.com/json-iterator/go"
	"github.com/schollz/progressbar/v3"
	"github.com/torabian/fireback/modules/workspaces"
	metas "github.com/torabian/fireback/modules/worldtimezone/metas"
	mocks "github.com/torabian/fireback/modules/worldtimezone/mocks/TimezoneGroup"
	seeders "github.com/torabian/fireback/modules/worldtimezone/seeders/TimezoneGroup"
	"github.com/urfave/cli"
	"gopkg.in/yaml.v2"
	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	reflect "reflect"
	"strings"
)

var timezoneGroupSeedersFs = &seeders.ViewsFs

func ResetTimezoneGroupSeeders(fs *embed.FS) {
	timezoneGroupSeedersFs = fs
}

type TimezoneGroupUtcItems struct {
	Visibility       *string              `json:"visibility,omitempty" yaml:"visibility,omitempty"`
	WorkspaceId      *string              `json:"workspaceId,omitempty" yaml:"workspaceId,omitempty"`
	LinkerId         *string              `json:"linkerId,omitempty" yaml:"linkerId,omitempty"`
	ParentId         *string              `json:"parentId,omitempty" yaml:"parentId,omitempty"`
	IsDeletable      *bool                `json:"isDeletable,omitempty" yaml:"isDeletable,omitempty" gorm:"default:true"`
	IsUpdatable      *bool                `json:"isUpdatable,omitempty" yaml:"isUpdatable,omitempty" gorm:"default:true"`
	UserId           *string              `json:"userId,omitempty" yaml:"userId,omitempty"`
	Rank             int64                `json:"rank,omitempty" gorm:"type:int;name:rank"`
	ID               uint                 `gorm:"primaryKey;autoIncrement" json:"id,omitempty" yaml:"id,omitempty"`
	UniqueId         string               `json:"uniqueId,omitempty" gorm:"unique;not null;size:100;" yaml:"uniqueId,omitempty"`
	Created          int64                `json:"created,omitempty" yaml:"created,omitempty" gorm:"autoUpdateTime:nano"`
	Updated          int64                `json:"updated,omitempty" yaml:"updated,omitempty"`
	Deleted          int64                `json:"deleted,omitempty" yaml:"deleted,omitempty"`
	CreatedFormatted string               `json:"createdFormatted,omitempty" yaml:"createdFormatted,omitempty" sql:"-" gorm:"-"`
	UpdatedFormatted string               `json:"updatedFormatted,omitempty" yaml:"updatedFormatted,omitempty" sql:"-" gorm:"-"`
	Name             *string              `json:"name" yaml:"name"  validate:"required"        translate:"true"  `
	LinkedTo         *TimezoneGroupEntity `yaml:"-" gorm:"-" json:"-" sql:"-"`
}

func (x *TimezoneGroupUtcItems) RootObjectName() string {
	return "TimezoneGroupEntity"
}

type TimezoneGroupEntity struct {
	Visibility       *string                        `json:"visibility,omitempty" yaml:"visibility,omitempty"`
	WorkspaceId      *string                        `json:"workspaceId,omitempty" yaml:"workspaceId,omitempty"`
	LinkerId         *string                        `json:"linkerId,omitempty" yaml:"linkerId,omitempty"`
	ParentId         *string                        `json:"parentId,omitempty" yaml:"parentId,omitempty"`
	IsDeletable      *bool                          `json:"isDeletable,omitempty" yaml:"isDeletable,omitempty" gorm:"default:true"`
	IsUpdatable      *bool                          `json:"isUpdatable,omitempty" yaml:"isUpdatable,omitempty" gorm:"default:true"`
	UserId           *string                        `json:"userId,omitempty" yaml:"userId,omitempty"`
	Rank             int64                          `json:"rank,omitempty" gorm:"type:int;name:rank"`
	ID               uint                           `gorm:"primaryKey;autoIncrement" json:"id,omitempty" yaml:"id,omitempty"`
	UniqueId         string                         `json:"uniqueId,omitempty" gorm:"unique;not null;size:100;" yaml:"uniqueId,omitempty"`
	Created          int64                          `json:"created,omitempty" yaml:"created,omitempty" gorm:"autoUpdateTime:nano"`
	Updated          int64                          `json:"updated,omitempty" yaml:"updated,omitempty"`
	Deleted          int64                          `json:"deleted,omitempty" yaml:"deleted,omitempty"`
	CreatedFormatted string                         `json:"createdFormatted,omitempty" yaml:"createdFormatted,omitempty" sql:"-" gorm:"-"`
	UpdatedFormatted string                         `json:"updatedFormatted,omitempty" yaml:"updatedFormatted,omitempty" sql:"-" gorm:"-"`
	Value            *string                        `json:"value" yaml:"value"        translate:"true"  `
	Abbr             *string                        `json:"abbr" yaml:"abbr"        `
	Offset           *int64                         `json:"offset" yaml:"offset"        `
	Isdst            *bool                          `json:"isdst" yaml:"isdst"        `
	Text             *string                        `json:"text" yaml:"text"        translate:"true"  `
	UtcItems         []*TimezoneGroupUtcItems       `json:"utcItems" yaml:"utcItems"    gorm:"foreignKey:LinkerId;references:UniqueId;constraint:OnDelete:CASCADE"      `
	Translations     []*TimezoneGroupEntityPolyglot `json:"translations,omitempty" yaml:"translations,omitempty" gorm:"foreignKey:LinkerId;references:UniqueId;constraint:OnDelete:CASCADE"`
	Children         []*TimezoneGroupEntity         `csv:"-" gorm:"-" sql:"-" json:"children,omitempty" yaml:"children,omitempty"`
	LinkedTo         *TimezoneGroupEntity           `csv:"-" yaml:"-" gorm:"-" json:"-" sql:"-"`
}

func TimezoneGroupEntityStream(q workspaces.QueryDSL) (chan []*TimezoneGroupEntity, *workspaces.QueryResultMeta, error) {
	cn := make(chan []*TimezoneGroupEntity)
	q.ItemsPerPage = 50
	q.StartIndex = 0
	_, qrm, err := TimezoneGroupActionQuery(q)
	if err != nil {
		return nil, nil, err
	}
	go func() {
		for i := 0; i <= int(qrm.TotalAvailableItems)-1; i++ {
			items, _, _ := TimezoneGroupActionQuery(q)
			i += q.ItemsPerPage
			q.StartIndex = i
			cn <- items
		}
	}()
	return cn, qrm, nil
}

type TimezoneGroupEntityList struct {
	Items []*TimezoneGroupEntity
}

func NewTimezoneGroupEntityList(items []*TimezoneGroupEntity) *TimezoneGroupEntityList {
	return &TimezoneGroupEntityList{
		Items: items,
	}
}
func (x *TimezoneGroupEntityList) ToTree() *workspaces.TreeOperation[TimezoneGroupEntity] {
	return workspaces.NewTreeOperation(
		x.Items,
		func(t *TimezoneGroupEntity) string {
			if t.ParentId == nil {
				return ""
			}
			return *t.ParentId
		},
		func(t *TimezoneGroupEntity) string {
			return t.UniqueId
		},
	)
}

var TimezoneGroupPreloadRelations []string = []string{}
var TIMEZONE_GROUP_EVENT_CREATED = "timezoneGroup.created"
var TIMEZONE_GROUP_EVENT_UPDATED = "timezoneGroup.updated"
var TIMEZONE_GROUP_EVENT_DELETED = "timezoneGroup.deleted"
var TIMEZONE_GROUP_EVENTS = []string{
	TIMEZONE_GROUP_EVENT_CREATED,
	TIMEZONE_GROUP_EVENT_UPDATED,
	TIMEZONE_GROUP_EVENT_DELETED,
}

type TimezoneGroupFieldMap struct {
	Value    workspaces.TranslatedString `yaml:"value"`
	Abbr     workspaces.TranslatedString `yaml:"abbr"`
	Offset   workspaces.TranslatedString `yaml:"offset"`
	Isdst    workspaces.TranslatedString `yaml:"isdst"`
	Text     workspaces.TranslatedString `yaml:"text"`
	UtcItems workspaces.TranslatedString `yaml:"utcItems"`
}

var TimezoneGroupEntityMetaConfig map[string]int64 = map[string]int64{}
var TimezoneGroupEntityJsonSchema = workspaces.ExtractEntityFields(reflect.ValueOf(&TimezoneGroupEntity{}))

type TimezoneGroupEntityPolyglot struct {
	LinkerId   string `gorm:"uniqueId;not null;size:100;" json:"linkerId,omitempty" yaml:"linkerId,omitempty"`
	LanguageId string `gorm:"uniqueId;not null;size:100;" json:"languageId,omitempty" yaml:"languageId,omitempty"`
	Value      string `yaml:"value,omitempty" json:"value,omitempty"`
	Text       string `yaml:"text,omitempty" json:"text,omitempty"`
}

func TimezoneGroupUtcItemsActionCreate(
	dto *TimezoneGroupUtcItems,
	query workspaces.QueryDSL,
) (*TimezoneGroupUtcItems, *workspaces.IError) {
	dto.LinkerId = &query.LinkerId
	var dbref *gorm.DB = nil
	if query.Tx == nil {
		dbref = workspaces.GetDbRef()
	} else {
		dbref = query.Tx
	}
	query.Tx = dbref
	if dto.UniqueId == "" {
		dto.UniqueId = workspaces.UUID()
	}
	err := dbref.Create(&dto).Error
	if err != nil {
		err := workspaces.GormErrorToIError(err)
		return dto, err
	}
	return dto, nil
}
func TimezoneGroupUtcItemsActionUpdate(
	query workspaces.QueryDSL,
	dto *TimezoneGroupUtcItems,
) (*TimezoneGroupUtcItems, *workspaces.IError) {
	dto.LinkerId = &query.LinkerId
	var dbref *gorm.DB = nil
	if query.Tx == nil {
		dbref = workspaces.GetDbRef()
	} else {
		dbref = query.Tx
	}
	query.Tx = dbref
	err := dbref.UpdateColumns(&dto).Error
	if err != nil {
		err := workspaces.GormErrorToIError(err)
		return dto, err
	}
	return dto, nil
}
func TimezoneGroupUtcItemsActionGetOne(
	query workspaces.QueryDSL,
) (*TimezoneGroupUtcItems, *workspaces.IError) {
	refl := reflect.ValueOf(&TimezoneGroupUtcItems{})
	item, err := workspaces.GetOneEntity[TimezoneGroupUtcItems](query, refl)
	return item, err
}
func entityTimezoneGroupFormatter(dto *TimezoneGroupEntity, query workspaces.QueryDSL) {
	if dto == nil {
		return
	}
	if dto.Created > 0 {
		dto.CreatedFormatted = workspaces.FormatDateBasedOnQuery(dto.Created, query)
	}
	if dto.Updated > 0 {
		dto.CreatedFormatted = workspaces.FormatDateBasedOnQuery(dto.Updated, query)
	}
}
func TimezoneGroupMockEntity() *TimezoneGroupEntity {
	stringHolder := "~"
	int64Holder := int64(10)
	float64Holder := float64(10)
	_ = stringHolder
	_ = int64Holder
	_ = float64Holder
	entity := &TimezoneGroupEntity{
		Value:  &stringHolder,
		Abbr:   &stringHolder,
		Offset: &int64Holder,
		Text:   &stringHolder,
	}
	return entity
}
func TimezoneGroupActionSeederMultiple(query workspaces.QueryDSL, count int) {
	successInsert := 0
	failureInsert := 0
	batchSize := 100
	bar := progressbar.Default(int64(count))
	// Collect entities in batches
	var entitiesBatch []*TimezoneGroupEntity
	for i := 1; i <= count; i++ {
		entity := TimezoneGroupMockEntity()
		entitiesBatch = append(entitiesBatch, entity)
		// When batch size is reached, perform the batch insert
		if len(entitiesBatch) == batchSize || i == count {
			// Insert batch
			_, err := TimezoneGroupMultiInsert(entitiesBatch, query)
			if err == nil {
				successInsert += len(entitiesBatch)
			} else {
				fmt.Println(err)
				failureInsert += len(entitiesBatch)
			}
			// Clear the batch after insert
			entitiesBatch = nil
		}
		bar.Add(1)
	}
	fmt.Println("Success", successInsert, "Failure", failureInsert)
}
func TimezoneGroupActionSeeder(query workspaces.QueryDSL, count int) {
	successInsert := 0
	failureInsert := 0
	bar := progressbar.Default(int64(count))
	for i := 1; i <= count; i++ {
		entity := TimezoneGroupMockEntity()
		_, err := TimezoneGroupActionCreate(entity, query)
		if err == nil {
			successInsert++
		} else {
			fmt.Println(err)
			failureInsert++
		}
		bar.Add(1)
	}
	fmt.Println("Success", successInsert, "Failure", failureInsert)
}
func (x *TimezoneGroupEntity) GetValueTranslated(language string) string {
	if x.Translations != nil && len(x.Translations) > 0 {
		for _, item := range x.Translations {
			if item.LanguageId == language {
				return item.Value
			}
		}
	}
	return ""
}
func (x *TimezoneGroupEntity) GetTextTranslated(language string) string {
	if x.Translations != nil && len(x.Translations) > 0 {
		for _, item := range x.Translations {
			if item.LanguageId == language {
				return item.Text
			}
		}
	}
	return ""
}
func (x *TimezoneGroupEntity) Seeder() string {
	obj := TimezoneGroupActionSeederInit()
	v, _ := json.MarshalIndent(obj, "", "  ")
	return string(v)
}
func TimezoneGroupActionSeederInit() *TimezoneGroupEntity {
	tildaRef := "~"
	_ = tildaRef
	entity := &TimezoneGroupEntity{
		Value:    &tildaRef,
		Abbr:     &tildaRef,
		Text:     &tildaRef,
		UtcItems: []*TimezoneGroupUtcItems{{}},
	}
	return entity
}
func TimezoneGroupAssociationCreate(dto *TimezoneGroupEntity, query workspaces.QueryDSL) error {
	return nil
}

/**
* These kind of content are coming from another entity, which is indepndent module
* If we want to create them, we need to do it before. This is not association.
**/
func TimezoneGroupRelationContentCreate(dto *TimezoneGroupEntity, query workspaces.QueryDSL) error {
	return nil
}
func TimezoneGroupRelationContentUpdate(dto *TimezoneGroupEntity, query workspaces.QueryDSL) error {
	return nil
}
func TimezoneGroupPolyglotCreateHandler(dto *TimezoneGroupEntity, query workspaces.QueryDSL) {
	if dto == nil {
		return
	}
	workspaces.PolyglotCreateHandler(dto, &TimezoneGroupEntityPolyglot{}, query)
}

/**
 * This will be validating your entity fully. Important note is that, you add validate:* tag
 * in your entity, it will automatically work here. For slices inside entity, make sure you add
 * extra line of AppendSliceErrors, otherwise they won't be detected
 */
func TimezoneGroupValidator(dto *TimezoneGroupEntity, isPatch bool) *workspaces.IError {
	err := workspaces.CommonStructValidatorPointer(dto, isPatch)
	if dto != nil && dto.UtcItems != nil {
		workspaces.AppendSliceErrors(dto.UtcItems, isPatch, "utcItems", err)
	}
	return err
}

// Creates a set of natural language queries, which can be used with
// AI tools to create content or help with some tasks
var TimezoneGroupAskCmd cli.Command = cli.Command{
	Name:  "nlp",
	Usage: "Set of natural language queries which helps creating content or data",
	Subcommands: []cli.Command{
		{
			Name:  "sample",
			Usage: "Asks for generating sample by giving an example data",
			Flags: []cli.Flag{
				&cli.StringFlag{
					Name:  "format",
					Usage: "Format of the export or import file. Can be 'yaml', 'yml', 'json'",
					Value: "yaml",
				},
				&cli.IntFlag{
					Name:  "count",
					Usage: "How many samples to ask",
					Value: 30,
				},
			},
			Action: func(c *cli.Context) error {
				v := &TimezoneGroupEntity{}
				format := c.String("format")
				request := "\033[1m" + `
I need you to create me an array of exact signature as the example given below,
with at least ` + fmt.Sprint(c.String("count")) + ` items, mock the content with few words, and guess the possible values
based on the common sense. I need the output to be a valid ` + format + ` file.
Make sure you wrap the entire array in 'items' field. Also before that, I provide some explanation of each field:
Value: (type: string) Description: 
Abbr: (type: string) Description: 
Offset: (type: int64) Description: 
Isdst: (type: bool) Description: 
Text: (type: string) Description: 
UtcItems: (type: array) Description: 
And here is the actual object signature:
` + v.Seeder() + `
`
				fmt.Println(request)
				return nil
			},
		},
	},
}

func TimezoneGroupEntityPreSanitize(dto *TimezoneGroupEntity, query workspaces.QueryDSL) {
}
func TimezoneGroupEntityBeforeCreateAppend(dto *TimezoneGroupEntity, query workspaces.QueryDSL) {
	if dto.UniqueId == "" {
		dto.UniqueId = workspaces.UUID()
	}
	dto.WorkspaceId = &query.WorkspaceId
	dto.UserId = &query.UserId
	TimezoneGroupRecursiveAddUniqueId(dto, query)
}
func TimezoneGroupRecursiveAddUniqueId(dto *TimezoneGroupEntity, query workspaces.QueryDSL) {
	if dto.UtcItems != nil && len(dto.UtcItems) > 0 {
		for index0 := range dto.UtcItems {
			if dto.UtcItems[index0].UniqueId == "" {
				dto.UtcItems[index0].UniqueId = workspaces.UUID()
			}
		}
	}
}

/*
*
	Batch inserts, do not have all features that create
	operation does. Use it with unnormalized content,
	or read the source code carefully.
  This is not marked as an action, because it should not be available publicly
  at this moment.
*
*/
func TimezoneGroupMultiInsert(dtos []*TimezoneGroupEntity, query workspaces.QueryDSL) ([]*TimezoneGroupEntity, *workspaces.IError) {
	if len(dtos) > 0 {
		for index := range dtos {
			TimezoneGroupEntityPreSanitize(dtos[index], query)
			TimezoneGroupEntityBeforeCreateAppend(dtos[index], query)
		}
		var dbref *gorm.DB = nil
		if query.Tx == nil {
			dbref = workspaces.GetDbRef()
		} else {
			dbref = query.Tx
		}
		query.Tx = dbref
		err := dbref.Create(&dtos).Error
		if err != nil {
			return nil, workspaces.GormErrorToIError(err)
		}
	}
	return dtos, nil
}
func TimezoneGroupActionBatchCreateFn(dtos []*TimezoneGroupEntity, query workspaces.QueryDSL) ([]*TimezoneGroupEntity, *workspaces.IError) {
	if dtos != nil && len(dtos) > 0 {
		items := []*TimezoneGroupEntity{}
		for _, item := range dtos {
			s, err := TimezoneGroupActionCreateFn(item, query)
			if err != nil {
				return nil, err
			}
			items = append(items, s)
		}
		return items, nil
	}
	return dtos, nil
}
func TimezoneGroupDeleteEntireChildren(query workspaces.QueryDSL, dto *TimezoneGroupEntity) *workspaces.IError {
	// intentionally removed this. It's hard to implement it, and probably wrong without
	// proper on delete cascade
	return nil
}
func TimezoneGroupActionCreateFn(dto *TimezoneGroupEntity, query workspaces.QueryDSL) (*TimezoneGroupEntity, *workspaces.IError) {
	// 1. Validate always
	if iError := TimezoneGroupValidator(dto, false); iError != nil {
		return nil, iError
	}
	// 1.5 Sanitize the content coming of the front-end
	TimezoneGroupEntityPreSanitize(dto, query)
	// 2. Append the necessary information about user, workspace
	TimezoneGroupEntityBeforeCreateAppend(dto, query)
	// 3. Append the necessary translations, even if english
	TimezoneGroupPolyglotCreateHandler(dto, query)
	// 3.5. Create other entities if we want select from them
	TimezoneGroupRelationContentCreate(dto, query)
	// 4. Create the entity
	var dbref *gorm.DB = nil
	if query.Tx == nil {
		dbref = workspaces.GetDbRef()
	} else {
		dbref = query.Tx
	}
	query.Tx = dbref
	err := dbref.Create(&dto).Error
	if err != nil {
		err := workspaces.GormErrorToIError(err)
		return dto, err
	}
	// 5. Create sub entities, objects or arrays, association to other entities
	TimezoneGroupAssociationCreate(dto, query)
	// 6. Fire the event into system
	event.MustFire(TIMEZONE_GROUP_EVENT_CREATED, event.M{
		"entity":    dto,
		"entityKey": workspaces.GetTypeString(&TimezoneGroupEntity{}),
		"target":    "workspace",
		"unqiueId":  query.WorkspaceId,
	})
	return dto, nil
}
func TimezoneGroupActionGetOne(query workspaces.QueryDSL) (*TimezoneGroupEntity, *workspaces.IError) {
	refl := reflect.ValueOf(&TimezoneGroupEntity{})
	item, err := workspaces.GetOneEntity[TimezoneGroupEntity](query, refl)
	entityTimezoneGroupFormatter(item, query)
	return item, err
}
func TimezoneGroupActionGetByWorkspace(query workspaces.QueryDSL) (*TimezoneGroupEntity, *workspaces.IError) {
	refl := reflect.ValueOf(&TimezoneGroupEntity{})
	item, err := workspaces.GetOneByWorkspaceEntity[TimezoneGroupEntity](query, refl)
	entityTimezoneGroupFormatter(item, query)
	return item, err
}
func TimezoneGroupActionQuery(query workspaces.QueryDSL) ([]*TimezoneGroupEntity, *workspaces.QueryResultMeta, error) {
	refl := reflect.ValueOf(&TimezoneGroupEntity{})
	items, meta, err := workspaces.QueryEntitiesPointer[TimezoneGroupEntity](query, refl)
	for _, item := range items {
		entityTimezoneGroupFormatter(item, query)
	}
	return items, meta, err
}

var timezoneGroupMemoryItems []*TimezoneGroupEntity = []*TimezoneGroupEntity{}

func TimezoneGroupEntityIntoMemory() {
	q := workspaces.QueryDSL{
		ItemsPerPage: 500,
		StartIndex:   0,
	}
	_, qrm, _ := TimezoneGroupActionQuery(q)
	for i := 0; i <= int(qrm.TotalAvailableItems)-1; i++ {
		items, _, _ := TimezoneGroupActionQuery(q)
		timezoneGroupMemoryItems = append(timezoneGroupMemoryItems, items...)
		i += q.ItemsPerPage
		q.StartIndex = i
	}
}
func TimezoneGroupMemGet(id uint) *TimezoneGroupEntity {
	for _, item := range timezoneGroupMemoryItems {
		if item.ID == id {
			return item
		}
	}
	return nil
}
func TimezoneGroupMemJoin(items []uint) []*TimezoneGroupEntity {
	res := []*TimezoneGroupEntity{}
	for _, item := range items {
		v := TimezoneGroupMemGet(item)
		if v != nil {
			res = append(res, v)
		}
	}
	return res
}
func TimezoneGroupUpdateExec(dbref *gorm.DB, query workspaces.QueryDSL, fields *TimezoneGroupEntity) (*TimezoneGroupEntity, *workspaces.IError) {
	uniqueId := fields.UniqueId
	query.TriggerEventName = TIMEZONE_GROUP_EVENT_UPDATED
	TimezoneGroupEntityPreSanitize(fields, query)
	var item TimezoneGroupEntity
	q := dbref.
		Where(&TimezoneGroupEntity{UniqueId: uniqueId}).
		FirstOrCreate(&item)
	err := q.UpdateColumns(fields).Error
	if err != nil {
		return nil, workspaces.GormErrorToIError(err)
	}
	query.Tx = dbref
	TimezoneGroupRelationContentUpdate(fields, query)
	TimezoneGroupPolyglotCreateHandler(fields, query)
	if ero := TimezoneGroupDeleteEntireChildren(query, fields); ero != nil {
		return nil, ero
	}
	// @meta(update has many)
	if fields.UtcItems != nil {
		linkerId := uniqueId
		dbref.
			Where(&TimezoneGroupUtcItems{LinkerId: &linkerId}).
			Delete(&TimezoneGroupUtcItems{})
		for _, newItem := range fields.UtcItems {
			newItem.UniqueId = workspaces.UUID()
			newItem.LinkerId = &linkerId
			dbref.Create(&newItem)
		}
	}
	err = dbref.
		Preload(clause.Associations).
		Where(&TimezoneGroupEntity{UniqueId: uniqueId}).
		First(&item).Error
	event.MustFire(query.TriggerEventName, event.M{
		"entity":   &item,
		"target":   "workspace",
		"unqiueId": query.WorkspaceId,
	})
	if err != nil {
		return &item, workspaces.GormErrorToIError(err)
	}
	return &item, nil
}
func TimezoneGroupActionUpdateFn(query workspaces.QueryDSL, fields *TimezoneGroupEntity) (*TimezoneGroupEntity, *workspaces.IError) {
	if fields == nil {
		return nil, workspaces.Create401Error(&workspaces.WorkspacesMessages.BodyIsMissing, []string{})
	}
	// 1. Validate always
	if iError := TimezoneGroupValidator(fields, true); iError != nil {
		return nil, iError
	}
	// Let's not add this. I am not sure of the consequences
	// TimezoneGroupRecursiveAddUniqueId(fields, query)
	var dbref *gorm.DB = nil
	if query.Tx == nil {
		dbref = workspaces.GetDbRef()
		var item *TimezoneGroupEntity
		vf := dbref.Transaction(func(tx *gorm.DB) error {
			dbref = tx
			var err *workspaces.IError
			item, err = TimezoneGroupUpdateExec(dbref, query, fields)
			if err == nil {
				return nil
			} else {
				return err
			}
		})
		return item, workspaces.CastToIError(vf)
	} else {
		dbref = query.Tx
		return TimezoneGroupUpdateExec(dbref, query, fields)
	}
}

var TimezoneGroupWipeCmd cli.Command = cli.Command{
	Name:  "wipe",
	Usage: "Wipes entire timezonegroups ",
	Action: func(c *cli.Context) error {
		query := workspaces.CommonCliQueryDSLBuilderAuthorize(c, &workspaces.SecurityModel{
			ActionRequires: []workspaces.PermissionInfo{PERM_ROOT_TIMEZONE_GROUP_DELETE},
		})
		count, _ := TimezoneGroupActionWipeClean(query)
		fmt.Println("Removed", count, "of entities")
		return nil
	},
}

func TimezoneGroupActionRemove(query workspaces.QueryDSL) (int64, *workspaces.IError) {
	refl := reflect.ValueOf(&TimezoneGroupEntity{})
	query.ActionRequires = []workspaces.PermissionInfo{PERM_ROOT_TIMEZONE_GROUP_DELETE}
	return workspaces.RemoveEntity[TimezoneGroupEntity](query, refl)
}
func TimezoneGroupActionWipeClean(query workspaces.QueryDSL) (int64, error) {
	var err error
	var count int64 = 0
	{
		subCount, subErr := workspaces.WipeCleanEntity[TimezoneGroupUtcItems]()
		if subErr != nil {
			fmt.Println("Error while wiping 'TimezoneGroupUtcItems'", subErr)
			return count, subErr
		} else {
			count += subCount
		}
	}
	{
		subCount, subErr := workspaces.WipeCleanEntity[TimezoneGroupEntity]()
		if subErr != nil {
			fmt.Println("Error while wiping 'TimezoneGroupEntity'", subErr)
			return count, subErr
		} else {
			count += subCount
		}
	}
	return count, err
}
func TimezoneGroupActionBulkUpdate(
	query workspaces.QueryDSL, dto *workspaces.BulkRecordRequest[TimezoneGroupEntity]) (
	*workspaces.BulkRecordRequest[TimezoneGroupEntity], *workspaces.IError,
) {
	result := []*TimezoneGroupEntity{}
	err := workspaces.GetDbRef().Transaction(func(tx *gorm.DB) error {
		query.Tx = tx
		for _, record := range dto.Records {
			item, err := TimezoneGroupActionUpdate(query, record)
			if err != nil {
				return err
			} else {
				result = append(result, item)
			}
		}
		return nil
	})
	if err == nil {
		return dto, nil
	}
	return nil, err.(*workspaces.IError)
}
func (x *TimezoneGroupEntity) Json() string {
	if x != nil {
		str, _ := json.MarshalIndent(x, "", "  ")
		return (string(str))
	}
	return ""
}

var TimezoneGroupEntityMeta = workspaces.TableMetaData{
	EntityName:    "TimezoneGroup",
	ExportKey:     "timezone-groups",
	TableNameInDb: "fb_timezone-group_entities",
	EntityObject:  &TimezoneGroupEntity{},
	ExportStream:  TimezoneGroupActionExportT,
	ImportQuery:   TimezoneGroupActionImport,
}

func TimezoneGroupActionExport(
	query workspaces.QueryDSL,
) (chan []byte, *workspaces.IError) {
	return workspaces.YamlExporterChannel[TimezoneGroupEntity](query, TimezoneGroupActionQuery, TimezoneGroupPreloadRelations)
}
func TimezoneGroupActionExportT(
	query workspaces.QueryDSL,
) (chan []interface{}, *workspaces.IError) {
	return workspaces.YamlExporterChannelT[TimezoneGroupEntity](query, TimezoneGroupActionQuery, TimezoneGroupPreloadRelations)
}
func TimezoneGroupActionImport(
	dto interface{}, query workspaces.QueryDSL,
) *workspaces.IError {
	var json = jsoniter.ConfigCompatibleWithStandardLibrary
	var content TimezoneGroupEntity
	cx, err2 := json.Marshal(dto)
	if err2 != nil {
		return workspaces.Create401Error(&workspaces.WorkspacesMessages.InvalidContent, []string{})
	}
	json.Unmarshal(cx, &content)
	_, err := TimezoneGroupActionCreate(&content, query)
	return err
}

var TimezoneGroupCommonCliFlags = []cli.Flag{
	&cli.StringFlag{
		Name:     "wid",
		Required: false,
		Usage:    "Provide workspace id, if you want to change the data workspace",
	},
	&cli.StringFlag{
		Name:     "uid",
		Required: false,
		Usage:    "uniqueId (primary key)",
	},
	&cli.StringFlag{
		Name:     "pid",
		Required: false,
		Usage:    " Parent record id of the same type",
	},
	&cli.StringFlag{
		Name:     "value",
		Required: false,
		Usage:    `value`,
	},
	&cli.StringFlag{
		Name:     "abbr",
		Required: false,
		Usage:    `abbr`,
	},
	&cli.Int64Flag{
		Name:     "offset",
		Required: false,
		Usage:    `offset`,
	},
	&cli.BoolFlag{
		Name:     "isdst",
		Required: false,
		Usage:    `isdst`,
	},
	&cli.StringFlag{
		Name:     "text",
		Required: false,
		Usage:    `text`,
	},
	&cli.StringSliceFlag{
		Name:     "utc-items",
		Required: false,
		Usage:    `utcItems`,
	},
}
var TimezoneGroupCommonInteractiveCliFlags = []workspaces.CliInteractiveFlag{
	{
		Name:        "value",
		StructField: "Value",
		Required:    false,
		Recommended: false,
		Usage:       `value`,
		Type:        "string",
	},
	{
		Name:        "abbr",
		StructField: "Abbr",
		Required:    false,
		Recommended: false,
		Usage:       `abbr`,
		Type:        "string",
	},
	{
		Name:        "offset",
		StructField: "Offset",
		Required:    false,
		Recommended: false,
		Usage:       `offset`,
		Type:        "int64",
	},
	{
		Name:        "isdst",
		StructField: "Isdst",
		Required:    false,
		Recommended: false,
		Usage:       `isdst`,
		Type:        "bool",
	},
	{
		Name:        "text",
		StructField: "Text",
		Required:    false,
		Recommended: false,
		Usage:       `text`,
		Type:        "string",
	},
}
var TimezoneGroupCommonCliFlagsOptional = []cli.Flag{
	&cli.StringFlag{
		Name:     "wid",
		Required: false,
		Usage:    "Provide workspace id, if you want to change the data workspace",
	},
	&cli.StringFlag{
		Name:     "uid",
		Required: false,
		Usage:    "uniqueId (primary key)",
	},
	&cli.StringFlag{
		Name:     "pid",
		Required: false,
		Usage:    " Parent record id of the same type",
	},
	&cli.StringFlag{
		Name:     "value",
		Required: false,
		Usage:    `value`,
	},
	&cli.StringFlag{
		Name:     "abbr",
		Required: false,
		Usage:    `abbr`,
	},
	&cli.Int64Flag{
		Name:     "offset",
		Required: false,
		Usage:    `offset`,
	},
	&cli.BoolFlag{
		Name:     "isdst",
		Required: false,
		Usage:    `isdst`,
	},
	&cli.StringFlag{
		Name:     "text",
		Required: false,
		Usage:    `text`,
	},
	&cli.StringSliceFlag{
		Name:     "utc-items",
		Required: false,
		Usage:    `utcItems`,
	},
}
var TimezoneGroupCreateCmd cli.Command = TIMEZONE_GROUP_ACTION_POST_ONE.ToCli()
var TimezoneGroupCreateInteractiveCmd cli.Command = cli.Command{
	Name:  "ic",
	Usage: "Creates a new template, using requied fields in an interactive name",
	Flags: []cli.Flag{
		&cli.BoolFlag{
			Name:  "all",
			Usage: "Interactively asks for all inputs, not only required ones",
		},
	},
	Action: func(c *cli.Context) {
		query := workspaces.CommonCliQueryDSLBuilderAuthorize(c, &workspaces.SecurityModel{
			ActionRequires: []workspaces.PermissionInfo{PERM_ROOT_TIMEZONE_GROUP_CREATE},
		})
		entity := &TimezoneGroupEntity{}
		workspaces.PopulateInteractively(entity, c, TimezoneGroupCommonInteractiveCliFlags)
		if entity, err := TimezoneGroupActionCreate(entity, query); err != nil {
			fmt.Println(err.Error())
		} else {
			f, _ := yaml.Marshal(entity)
			fmt.Println(workspaces.FormatYamlKeys(string(f)))
		}
	},
}
var TimezoneGroupUpdateCmd cli.Command = cli.Command{
	Name:    "update",
	Aliases: []string{"u"},
	Flags:   TimezoneGroupCommonCliFlagsOptional,
	Usage:   "Updates a template by passing the parameters",
	Action: func(c *cli.Context) error {
		query := workspaces.CommonCliQueryDSLBuilderAuthorize(c, &workspaces.SecurityModel{
			ActionRequires: []workspaces.PermissionInfo{PERM_ROOT_TIMEZONE_GROUP_UPDATE},
		})
		entity := CastTimezoneGroupFromCli(c)
		if entity, err := TimezoneGroupActionUpdate(query, entity); err != nil {
			fmt.Println(err.Error())
		} else {
			f, _ := json.MarshalIndent(entity, "", "  ")
			fmt.Println(string(f))
		}
		return nil
	},
}

func (x *TimezoneGroupEntity) FromCli(c *cli.Context) *TimezoneGroupEntity {
	return CastTimezoneGroupFromCli(c)
}
func CastTimezoneGroupFromCli(c *cli.Context) *TimezoneGroupEntity {
	template := &TimezoneGroupEntity{}
	if c.IsSet("uid") {
		template.UniqueId = c.String("uid")
	}
	if c.IsSet("pid") {
		x := c.String("pid")
		template.ParentId = &x
	}
	if c.IsSet("value") {
		value := c.String("value")
		template.Value = &value
	}
	if c.IsSet("abbr") {
		value := c.String("abbr")
		template.Abbr = &value
	}
	if c.IsSet("offset") {
		value := c.Int64("offset")
		template.Offset = &value
	}
	if c.IsSet("text") {
		value := c.String("text")
		template.Text = &value
	}
	return template
}
func TimezoneGroupSyncSeederFromFs(fsRef *embed.FS, fileNames []string) {
	workspaces.SeederFromFSImport(
		workspaces.QueryDSL{},
		TimezoneGroupActionCreate,
		reflect.ValueOf(&TimezoneGroupEntity{}).Elem(),
		fsRef,
		fileNames,
		true,
	)
}
func TimezoneGroupSyncSeeders() {
	workspaces.SeederFromFSImport(
		workspaces.QueryDSL{WorkspaceId: workspaces.USER_SYSTEM},
		TimezoneGroupActionCreate,
		reflect.ValueOf(&TimezoneGroupEntity{}).Elem(),
		timezoneGroupSeedersFs,
		[]string{},
		true,
	)
}
func TimezoneGroupImportMocks() {
	workspaces.SeederFromFSImport(
		workspaces.QueryDSL{},
		TimezoneGroupActionCreate,
		reflect.ValueOf(&TimezoneGroupEntity{}).Elem(),
		&mocks.ViewsFs,
		[]string{},
		false,
	)
}
func TimezoneGroupWriteQueryMock(ctx workspaces.MockQueryContext) {
	for _, lang := range ctx.Languages {
		itemsPerPage := 9999
		if ctx.ItemsPerPage > 0 {
			itemsPerPage = ctx.ItemsPerPage
		}
		f := workspaces.QueryDSL{ItemsPerPage: itemsPerPage, Language: lang, WithPreloads: ctx.WithPreloads, Deep: true}
		items, count, _ := TimezoneGroupActionQuery(f)
		result := workspaces.QueryEntitySuccessResult(f, items, count)
		workspaces.WriteMockDataToFile(lang, "", "TimezoneGroup", result)
	}
}

var TimezoneGroupImportExportCommands = []cli.Command{
	{
		Name:  "mock",
		Usage: "Generates mock records based on the entity definition",
		Flags: []cli.Flag{
			&cli.IntFlag{
				Name:  "count",
				Usage: "how many activation key do you need to be generated and stored in database",
				Value: 10,
			},
			&cli.BoolFlag{
				Name:  "batch",
				Usage: "Multiple insert into database mode. Might miss children and relations at the moment",
			},
		},
		Action: func(c *cli.Context) error {
			query := workspaces.CommonCliQueryDSLBuilderAuthorize(c, &workspaces.SecurityModel{
				ActionRequires: []workspaces.PermissionInfo{PERM_ROOT_TIMEZONE_GROUP_CREATE},
			})
			if c.Bool("batch") {
				TimezoneGroupActionSeederMultiple(query, c.Int("count"))
			} else {
				TimezoneGroupActionSeeder(query, c.Int("count"))
			}
			return nil
		},
	},
	{
		Name:    "init",
		Aliases: []string{"i"},
		Flags: []cli.Flag{
			&cli.StringFlag{
				Name:  "format",
				Usage: "Format of the export or import file. Can be 'yaml', 'yml', 'json'",
				Value: "yaml",
			},
		},
		Usage: "Creates a basic seeder file for you, based on the definition module we have. You can populate this file as an example",
		Action: func(c *cli.Context) error {
			seed := TimezoneGroupActionSeederInit()
			workspaces.CommonInitSeeder(strings.TrimSpace(c.String("format")), seed)
			return nil
		},
	},
	{
		Name:    "validate",
		Aliases: []string{"v"},
		Flags: []cli.Flag{
			&cli.StringFlag{
				Name:  "file",
				Usage: "Validates an import file, such as yaml, json, csv, and gives some insights how the after import it would look like",
				Value: "timezone-group-seeder-timezone-group.yml",
				// Uncomment before publish, they need to specify
				// Required: true,
			},
			&cli.StringFlag{
				Name:  "format",
				Usage: "Format of the export or import file. Can be 'yaml', 'yml', 'json'",
				Value: "yaml",
			},
		},
		Usage: "Reads a yaml file containing an array of timezone-groups, you can run this to validate if your import file is correct, and how it would look like after import",
		Action: func(c *cli.Context) error {
			data := &[]TimezoneGroupEntity{}
			workspaces.ReadYamlFile(c.String("file"), data)
			fmt.Println(data)
			return nil
		},
	},
	cli.Command{
		Name:  "list",
		Usage: "Prints the list of files attached to this module for syncing or bootstrapping project",
		Action: func(c *cli.Context) error {
			if entity, err := workspaces.GetSeederFilenames(timezoneGroupSeedersFs, ""); err != nil {
				fmt.Println(err.Error())
			} else {
				f, _ := json.MarshalIndent(entity, "", "  ")
				fmt.Println(string(f))
			}
			return nil
		},
	},
	cli.Command{
		Name:  "sync",
		Usage: "Tries to sync the embedded content into the database, the list could be seen by 'list' command",
		Action: func(c *cli.Context) error {
			workspaces.CommonCliImportEmbedCmd(c,
				TimezoneGroupActionCreate,
				reflect.ValueOf(&TimezoneGroupEntity{}).Elem(),
				timezoneGroupSeedersFs,
			)
			return nil
		},
	},
	cli.Command{
		Name:  "mocks",
		Usage: "Prints the list of mocks",
		Action: func(c *cli.Context) error {
			if entity, err := workspaces.GetSeederFilenames(&mocks.ViewsFs, ""); err != nil {
				fmt.Println(err.Error())
			} else {
				f, _ := json.MarshalIndent(entity, "", "  ")
				fmt.Println(string(f))
			}
			return nil
		},
	},
	cli.Command{
		Name:  "msync",
		Usage: "Tries to sync mocks into the system",
		Action: func(c *cli.Context) error {
			workspaces.CommonCliImportEmbedCmd(c,
				TimezoneGroupActionCreate,
				reflect.ValueOf(&TimezoneGroupEntity{}).Elem(),
				&mocks.ViewsFs,
			)
			return nil
		},
	},
	cli.Command{
		Name:    "export",
		Aliases: []string{"e"},
		Flags: append(workspaces.CommonQueryFlags,
			&cli.StringFlag{
				Name:     "file",
				Usage:    "The address of file you want the csv/yaml/json be exported to",
				Required: true,
			}),
		Usage: "Exports a query results into the csv/yaml/json format",
		Action: func(c *cli.Context) error {
			if strings.Contains(c.String("file"), ".csv") {
				workspaces.CommonCliExportCmd2(c,
					TimezoneGroupEntityStream,
					reflect.ValueOf(&TimezoneGroupEntity{}).Elem(),
					c.String("file"),
					&metas.MetaFs,
					"TimezoneGroupFieldMap.yml",
					TimezoneGroupPreloadRelations,
				)
			} else {
				workspaces.CommonCliExportCmd(c,
					TimezoneGroupActionQuery,
					reflect.ValueOf(&TimezoneGroupEntity{}).Elem(),
					c.String("file"),
					&metas.MetaFs,
					"TimezoneGroupFieldMap.yml",
					TimezoneGroupPreloadRelations,
				)
			}
			return nil
		},
	},
	cli.Command{
		Name: "import",
		Flags: append(
			append(
				workspaces.CommonQueryFlags,
				&cli.StringFlag{
					Name:     "file",
					Usage:    "The address of file you want the csv be imported from",
					Required: true,
				}),
			TimezoneGroupCommonCliFlagsOptional...,
		),
		Usage: "imports csv/yaml/json file and place it and its children into database",
		Action: func(c *cli.Context) error {
			workspaces.CommonCliImportCmdAuthorized(c,
				TimezoneGroupActionCreate,
				reflect.ValueOf(&TimezoneGroupEntity{}).Elem(),
				c.String("file"),
				&workspaces.SecurityModel{
					ActionRequires: []workspaces.PermissionInfo{PERM_ROOT_TIMEZONE_GROUP_CREATE},
				},
				func() TimezoneGroupEntity {
					v := CastTimezoneGroupFromCli(c)
					return *v
				},
			)
			return nil
		},
	},
}
var TimezoneGroupCliCommands []cli.Command = []cli.Command{
	TIMEZONE_GROUP_ACTION_QUERY.ToCli(),
	TIMEZONE_GROUP_ACTION_TABLE.ToCli(),
	TimezoneGroupCreateCmd,
	TimezoneGroupUpdateCmd,
	TimezoneGroupAskCmd,
	TimezoneGroupCreateInteractiveCmd,
	TimezoneGroupWipeCmd,
	workspaces.GetCommonRemoveQuery(reflect.ValueOf(&TimezoneGroupEntity{}).Elem(), TimezoneGroupActionRemove),
}

func TimezoneGroupCliFn() cli.Command {
	TimezoneGroupCliCommands = append(TimezoneGroupCliCommands, TimezoneGroupImportExportCommands...)
	return cli.Command{
		Name:        "tz",
		Description: "TimezoneGroups module actions",
		Usage:       `World timezone details`,
		Flags: []cli.Flag{
			&cli.StringFlag{
				Name:  "language",
				Value: "en",
			},
		},
		Subcommands: TimezoneGroupCliCommands,
	}
}

var TIMEZONE_GROUP_ACTION_TABLE = workspaces.Module2Action{
	Name:          "table",
	ActionName:    "table",
	ActionAliases: []string{"t"},
	Flags:         workspaces.CommonQueryFlags,
	Description:   "Table formatted queries all of the entities in database based on the standard query format",
	Action:        TimezoneGroupActionQuery,
	CliAction: func(c *cli.Context, security *workspaces.SecurityModel) error {
		workspaces.CommonCliTableCmd2(c,
			TimezoneGroupActionQuery,
			security,
			reflect.ValueOf(&TimezoneGroupEntity{}).Elem(),
		)
		return nil
	},
}
var TIMEZONE_GROUP_ACTION_QUERY = workspaces.Module2Action{
	Method:        "GET",
	Url:           "/timezone-groups",
	SecurityModel: &workspaces.SecurityModel{},
	Group:         "timezoneGroup",
	Handlers: []gin.HandlerFunc{
		func(c *gin.Context) {
			workspaces.HttpQueryEntity(c, TimezoneGroupActionQuery)
		},
	},
	Format:         "QUERY",
	Action:         TimezoneGroupActionQuery,
	ResponseEntity: &[]TimezoneGroupEntity{},
	Out: &workspaces.Module2ActionBody{
		Entity: "TimezoneGroupEntity",
	},
	CliAction: func(c *cli.Context, security *workspaces.SecurityModel) error {
		workspaces.CommonCliQueryCmd2(
			c,
			TimezoneGroupActionQuery,
			security,
		)
		return nil
	},
	CliName:       "query",
	ActionName:    "query",
	ActionAliases: []string{"q"},
	Flags:         workspaces.CommonQueryFlags,
	Description:   "Queries all of the entities in database based on the standard query format (s+)",
}
var TIMEZONE_GROUP_ACTION_EXPORT = workspaces.Module2Action{
	Method:        "GET",
	Url:           "/timezone-groups/export",
	SecurityModel: &workspaces.SecurityModel{},
	Group:         "timezoneGroup",
	Handlers: []gin.HandlerFunc{
		func(c *gin.Context) {
			workspaces.HttpStreamFileChannel(c, TimezoneGroupActionExport)
		},
	},
	Format:         "QUERY",
	Action:         TimezoneGroupActionExport,
	ResponseEntity: &[]TimezoneGroupEntity{},
	Out: &workspaces.Module2ActionBody{
		Entity: "TimezoneGroupEntity",
	},
}
var TIMEZONE_GROUP_ACTION_GET_ONE = workspaces.Module2Action{
	Method:        "GET",
	Url:           "/timezone-group/:uniqueId",
	SecurityModel: &workspaces.SecurityModel{},
	Group:         "timezoneGroup",
	Handlers: []gin.HandlerFunc{
		func(c *gin.Context) {
			workspaces.HttpGetEntity(c, TimezoneGroupActionGetOne)
		},
	},
	Format:         "GET_ONE",
	Action:         TimezoneGroupActionGetOne,
	ResponseEntity: &TimezoneGroupEntity{},
	Out: &workspaces.Module2ActionBody{
		Entity: "TimezoneGroupEntity",
	},
}
var TIMEZONE_GROUP_ACTION_POST_ONE = workspaces.Module2Action{
	ActionName:    "create",
	ActionAliases: []string{"c"},
	Description:   "Create new timezoneGroup",
	Flags:         TimezoneGroupCommonCliFlags,
	Method:        "POST",
	Url:           "/timezone-group",
	SecurityModel: &workspaces.SecurityModel{},
	Group:         "timezoneGroup",
	Handlers: []gin.HandlerFunc{
		func(c *gin.Context) {
			workspaces.HttpPostEntity(c, TimezoneGroupActionCreate)
		},
	},
	CliAction: func(c *cli.Context, security *workspaces.SecurityModel) error {
		result, err := workspaces.CliPostEntity(c, TimezoneGroupActionCreate, security)
		workspaces.HandleActionInCli(c, result, err, map[string]map[string]string{})
		return err
	},
	Action:         TimezoneGroupActionCreate,
	Format:         "POST_ONE",
	RequestEntity:  &TimezoneGroupEntity{},
	ResponseEntity: &TimezoneGroupEntity{},
	Out: &workspaces.Module2ActionBody{
		Entity: "TimezoneGroupEntity",
	},
	In: &workspaces.Module2ActionBody{
		Entity: "TimezoneGroupEntity",
	},
}
var TIMEZONE_GROUP_ACTION_PATCH = workspaces.Module2Action{
	ActionName:    "update",
	ActionAliases: []string{"u"},
	Flags:         TimezoneGroupCommonCliFlagsOptional,
	Method:        "PATCH",
	Url:           "/timezone-group",
	SecurityModel: &workspaces.SecurityModel{},
	Group:         "timezoneGroup",
	Handlers: []gin.HandlerFunc{
		func(c *gin.Context) {
			workspaces.HttpUpdateEntity(c, TimezoneGroupActionUpdate)
		},
	},
	Action:         TimezoneGroupActionUpdate,
	RequestEntity:  &TimezoneGroupEntity{},
	ResponseEntity: &TimezoneGroupEntity{},
	Format:         "PATCH_ONE",
	Out: &workspaces.Module2ActionBody{
		Entity: "TimezoneGroupEntity",
	},
	In: &workspaces.Module2ActionBody{
		Entity: "TimezoneGroupEntity",
	},
}
var TIMEZONE_GROUP_ACTION_PATCH_BULK = workspaces.Module2Action{
	Method:        "PATCH",
	Url:           "/timezone-groups",
	SecurityModel: &workspaces.SecurityModel{},
	Group:         "timezoneGroup",
	Handlers: []gin.HandlerFunc{
		func(c *gin.Context) {
			workspaces.HttpUpdateEntities(c, TimezoneGroupActionBulkUpdate)
		},
	},
	Action:         TimezoneGroupActionBulkUpdate,
	Format:         "PATCH_BULK",
	RequestEntity:  &workspaces.BulkRecordRequest[TimezoneGroupEntity]{},
	ResponseEntity: &workspaces.BulkRecordRequest[TimezoneGroupEntity]{},
	Out: &workspaces.Module2ActionBody{
		Entity: "TimezoneGroupEntity",
	},
	In: &workspaces.Module2ActionBody{
		Entity: "TimezoneGroupEntity",
	},
}
var TIMEZONE_GROUP_ACTION_DELETE = workspaces.Module2Action{
	Method:        "DELETE",
	Url:           "/timezone-group",
	Format:        "DELETE_DSL",
	SecurityModel: &workspaces.SecurityModel{},
	Group:         "timezoneGroup",
	Handlers: []gin.HandlerFunc{
		func(c *gin.Context) {
			workspaces.HttpRemoveEntity(c, TimezoneGroupActionRemove)
		},
	},
	Action:         TimezoneGroupActionRemove,
	RequestEntity:  &workspaces.DeleteRequest{},
	ResponseEntity: &workspaces.DeleteResponse{},
	TargetEntity:   &TimezoneGroupEntity{},
}
var TIMEZONE_GROUP_UTC_ITEMS_ACTION_PATCH = workspaces.Module2Action{
	Method:        "PATCH",
	Url:           "/timezone-group/:linkerId/utc_items/:uniqueId",
	SecurityModel: &workspaces.SecurityModel{},
	Group:         "timezoneGroup",
	Handlers: []gin.HandlerFunc{
		func(
			c *gin.Context,
		) {
			workspaces.HttpUpdateEntity(c, TimezoneGroupUtcItemsActionUpdate)
		},
	},
	Action:         TimezoneGroupUtcItemsActionUpdate,
	Format:         "PATCH_ONE",
	RequestEntity:  &TimezoneGroupUtcItems{},
	ResponseEntity: &TimezoneGroupUtcItems{},
	Out: &workspaces.Module2ActionBody{
		Entity: "TimezoneGroupUtcItems",
	},
	In: &workspaces.Module2ActionBody{
		Entity: "TimezoneGroupUtcItems",
	},
}
var TIMEZONE_GROUP_UTC_ITEMS_ACTION_GET = workspaces.Module2Action{
	Method:        "GET",
	Url:           "/timezone-group/utc_items/:linkerId/:uniqueId",
	SecurityModel: &workspaces.SecurityModel{},
	Group:         "timezoneGroup",
	Handlers: []gin.HandlerFunc{
		func(
			c *gin.Context,
		) {
			workspaces.HttpGetEntity(c, TimezoneGroupUtcItemsActionGetOne)
		},
	},
	Action:         TimezoneGroupUtcItemsActionGetOne,
	Format:         "GET_ONE",
	ResponseEntity: &TimezoneGroupUtcItems{},
	Out: &workspaces.Module2ActionBody{
		Entity: "TimezoneGroupUtcItems",
	},
}
var TIMEZONE_GROUP_UTC_ITEMS_ACTION_POST = workspaces.Module2Action{
	Method:        "POST",
	Url:           "/timezone-group/:linkerId/utc_items",
	SecurityModel: &workspaces.SecurityModel{},
	Group:         "timezoneGroup",
	Handlers: []gin.HandlerFunc{
		func(
			c *gin.Context,
		) {
			workspaces.HttpPostEntity(c, TimezoneGroupUtcItemsActionCreate)
		},
	},
	Action:         TimezoneGroupUtcItemsActionCreate,
	Format:         "POST_ONE",
	RequestEntity:  &TimezoneGroupUtcItems{},
	ResponseEntity: &TimezoneGroupUtcItems{},
	Out: &workspaces.Module2ActionBody{
		Entity: "TimezoneGroupUtcItems",
	},
	In: &workspaces.Module2ActionBody{
		Entity: "TimezoneGroupUtcItems",
	},
}

/**
 *	Override this function on TimezoneGroupEntityHttp.go,
 *	In order to add your own http
 **/
var AppendTimezoneGroupRouter = func(r *[]workspaces.Module2Action) {}

func GetTimezoneGroupModule2Actions() []workspaces.Module2Action {
	routes := []workspaces.Module2Action{
		TIMEZONE_GROUP_ACTION_QUERY,
		TIMEZONE_GROUP_ACTION_EXPORT,
		TIMEZONE_GROUP_ACTION_GET_ONE,
		TIMEZONE_GROUP_ACTION_POST_ONE,
		TIMEZONE_GROUP_ACTION_PATCH,
		TIMEZONE_GROUP_ACTION_PATCH_BULK,
		TIMEZONE_GROUP_ACTION_DELETE,
		TIMEZONE_GROUP_UTC_ITEMS_ACTION_PATCH,
		TIMEZONE_GROUP_UTC_ITEMS_ACTION_GET,
		TIMEZONE_GROUP_UTC_ITEMS_ACTION_POST,
	}
	// Append user defined functions
	AppendTimezoneGroupRouter(&routes)
	return routes
}

var PERM_ROOT_TIMEZONE_GROUP_DELETE = workspaces.PermissionInfo{
	CompleteKey: "root/modules/worldtimezone/timezone-group/delete",
	Name:        "Delete timezone group",
}
var PERM_ROOT_TIMEZONE_GROUP_CREATE = workspaces.PermissionInfo{
	CompleteKey: "root/modules/worldtimezone/timezone-group/create",
	Name:        "Create timezone group",
}
var PERM_ROOT_TIMEZONE_GROUP_UPDATE = workspaces.PermissionInfo{
	CompleteKey: "root/modules/worldtimezone/timezone-group/update",
	Name:        "Update timezone group",
}
var PERM_ROOT_TIMEZONE_GROUP_QUERY = workspaces.PermissionInfo{
	CompleteKey: "root/modules/worldtimezone/timezone-group/query",
	Name:        "Query timezone group",
}
var PERM_ROOT_TIMEZONE_GROUP = workspaces.PermissionInfo{
	CompleteKey: "root/modules/worldtimezone/timezone-group/*",
	Name:        "Entire timezone group actions (*)",
}
var ALL_TIMEZONE_GROUP_PERMISSIONS = []workspaces.PermissionInfo{
	PERM_ROOT_TIMEZONE_GROUP_DELETE,
	PERM_ROOT_TIMEZONE_GROUP_CREATE,
	PERM_ROOT_TIMEZONE_GROUP_UPDATE,
	PERM_ROOT_TIMEZONE_GROUP_QUERY,
	PERM_ROOT_TIMEZONE_GROUP,
}
var TimezoneGroupEntityBundle = workspaces.EntityBundle{
	Permissions: ALL_TIMEZONE_GROUP_PERMISSIONS,
	// Cli command has been exluded, since we use module to wrap all the entities
	// to be more easier to wrap up.
	// Create your own bundle if you need with Cli
	//CliCommands: []cli.Command{
	//	TimezoneGroupCliFn(),
	//},
	Actions:      GetTimezoneGroupModule2Actions(),
	MockProvider: TimezoneGroupImportMocks,
	AutoMigrationEntities: []interface{}{
		&TimezoneGroupEntity{},
		&TimezoneGroupUtcItems{},
		&TimezoneGroupEntityPolyglot{},
	},
}
