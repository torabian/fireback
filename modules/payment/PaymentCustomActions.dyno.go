package payment

/*
*	Generated by fireback 1.2.4
*	Written by Ali Torabi.
*	Checkout the repository for licenses and contribution: https://github.com/torabian/fireback
 */
import (
	"github.com/gin-gonic/gin"
	"github.com/torabian/fireback/modules/fireback"
	"github.com/urfave/cli"
)
import (
	"reflect"
)

// using shared actions here
type PayInvoiceQueryPathParams struct {
	UniqueId string `json:"uniqueId" xml:"uniqueId" yaml:"uniqueId"        `
}

var NotificationSecurityModel *fireback.SecurityModel = nil

type NotificationActionReqDto struct {
	// The session which has been assigned during payment process initially.
	SessionId string `json:"sessionId" xml:"sessionId" yaml:"sessionId"        `
	OrderId   int64  `json:"orderId" xml:"orderId" yaml:"orderId"        `
}

func (x *NotificationActionReqDto) RootObjectName() string {
	return "Payment"
}

var NotificationCommonCliFlagsOptional = []cli.Flag{
	&cli.StringFlag{
		Name:     "x-src",
		Required: false,
		Usage:    `Import the body of the request from a file (e.g. json/yaml) on the disk`,
	},
	&cli.StringFlag{
		Name:  "x-accept",
		Usage: "Return type of the the content, such as json or yaml",
	},
	&cli.StringFlag{
		Name:     "session-id",
		Required: false,
		Usage:    `The session which has been assigned during payment process initially. (string)`,
	},
	&cli.Int64Flag{
		Name:     "order-id",
		Required: false,
		Usage:    `orderId (int64)`,
	},
}

func NotificationActionReqValidator(dto *NotificationActionReqDto) *fireback.IError {
	err := fireback.CommonStructValidatorPointer(dto, false)
	return err
}
func CastNotificationFromCli(c *cli.Context) *NotificationActionReqDto {
	template := &NotificationActionReqDto{}
	fireback.HandleXsrc(c, template)
	if c.IsSet("session-id") {
		template.SessionId = c.String("session-id")
	}
	if c.IsSet("order-id") {
		value := c.Int64("order-id")
		template.OrderId = value
	}
	return template
}

type notificationActionImpSig func(
	req *NotificationActionReqDto,
	q fireback.QueryDSL) (string,
	*fireback.IError,
)

var NotificationActionImp notificationActionImpSig

func NotificationActionFn(
	req *NotificationActionReqDto,
	q fireback.QueryDSL,
) (
	string,
	*fireback.IError,
) {
	if NotificationActionImp == nil {
		return "", nil
	}
	return NotificationActionImp(req, q)
}

var NotificationActionCmd cli.Command = cli.Command{
	Name:  "notify",
	Usage: `A signal sent by P24 to give the order id into the system`,
	Flags: NotificationCommonCliFlagsOptional,
	Action: func(c *cli.Context) {
		query := fireback.CommonCliQueryDSLBuilderAuthorize(c, NotificationSecurityModel)
		dto := CastNotificationFromCli(c)
		result, err := NotificationActionFn(dto, query)
		fireback.HandleActionInCli(c, result, err, map[string]map[string]string{})
	},
}
var VerifyTransactionSecurityModel *fireback.SecurityModel = nil

type VerifyTransactionActionReqDto struct {
	// The session which has been assigned during payment process initially.
	SessionId string `json:"sessionId" xml:"sessionId" yaml:"sessionId"        `
	// The amount of transaction which will be payed. It's an integer, make sure you multiply the value by 100 instead of sending a float.
	Amount int64 `json:"amount" xml:"amount" yaml:"amount"        `
	// The orderId which has been assigned by P24 and sent via notification
	OrderId int64 `json:"orderId" xml:"orderId" yaml:"orderId"        `
}

func (x *VerifyTransactionActionReqDto) RootObjectName() string {
	return "Payment"
}

var VerifyTransactionCommonCliFlagsOptional = []cli.Flag{
	&cli.StringFlag{
		Name:     "x-src",
		Required: false,
		Usage:    `Import the body of the request from a file (e.g. json/yaml) on the disk`,
	},
	&cli.StringFlag{
		Name:  "x-accept",
		Usage: "Return type of the the content, such as json or yaml",
	},
	&cli.StringFlag{
		Name:     "session-id",
		Required: false,
		Usage:    `The session which has been assigned during payment process initially. (string)`,
	},
	&cli.Int64Flag{
		Name:     "amount",
		Required: false,
		Usage:    `The amount of transaction which will be payed. It's an integer, make sure you multiply the value by 100 instead of sending a float. (int64)`,
	},
	&cli.Int64Flag{
		Name:     "order-id",
		Required: false,
		Usage:    `The orderId which has been assigned by P24 and sent via notification (int64)`,
	},
}

func VerifyTransactionActionReqValidator(dto *VerifyTransactionActionReqDto) *fireback.IError {
	err := fireback.CommonStructValidatorPointer(dto, false)
	return err
}
func CastVerifyTransactionFromCli(c *cli.Context) *VerifyTransactionActionReqDto {
	template := &VerifyTransactionActionReqDto{}
	fireback.HandleXsrc(c, template)
	if c.IsSet("session-id") {
		template.SessionId = c.String("session-id")
	}
	if c.IsSet("amount") {
		value := c.Int64("amount")
		template.Amount = value
	}
	if c.IsSet("order-id") {
		value := c.Int64("order-id")
		template.OrderId = value
	}
	return template
}

type verifyTransactionActionImpSig func(
	req *VerifyTransactionActionReqDto,
	q fireback.QueryDSL) (string,
	*fireback.IError,
)

var VerifyTransactionActionImp verifyTransactionActionImpSig

func VerifyTransactionActionFn(
	req *VerifyTransactionActionReqDto,
	q fireback.QueryDSL,
) (
	string,
	*fireback.IError,
) {
	if VerifyTransactionActionImp == nil {
		return "", nil
	}
	return VerifyTransactionActionImp(req, q)
}

var VerifyTransactionActionCmd cli.Command = cli.Command{
	Name:  "verify",
	Usage: `Calls a external api to verify a transaction has been done correctly`,
	Flags: VerifyTransactionCommonCliFlagsOptional,
	Action: func(c *cli.Context) {
		query := fireback.CommonCliQueryDSLBuilderAuthorize(c, VerifyTransactionSecurityModel)
		dto := CastVerifyTransactionFromCli(c)
		result, err := VerifyTransactionActionFn(dto, query)
		fireback.HandleActionInCli(c, result, err, map[string]map[string]string{})
	},
}
var PayInvoiceSecurityModel *fireback.SecurityModel = nil

type PayInvoiceQuery struct {
	// Created invoice to be payed via strip
	InvoiceId  string                     `json:"invoiceId" xml:"invoiceId" yaml:"invoiceId"  validate:"required"          url:"invoiceId"  `
	PathParams *PayInvoiceQueryPathParams `json:"pathParams" xml:"pathParams" yaml:"pathParams"    gorm:"foreignKey:LinkerId;references:UniqueId;constraint:OnDelete:CASCADE"        url:"pathParams"  `
}
type payInvoiceActionImpSig func(
	q fireback.QueryDSL) (string,
	*fireback.IError,
)

var PayInvoiceActionImp payInvoiceActionImpSig

func PayInvoiceActionFn(
	q fireback.QueryDSL,
) (
	string,
	*fireback.IError,
) {
	if PayInvoiceActionImp == nil {
		return "", nil
	}
	return PayInvoiceActionImp(q)
}

var PayInvoiceActionCmd cli.Command = cli.Command{
	Name:  "pay-invoice",
	Usage: `Pay an invoice created independently`,
	Action: func(c *cli.Context) {
		query := fireback.CommonCliQueryDSLBuilderAuthorize(c, PayInvoiceSecurityModel)
		result, err := PayInvoiceActionFn(query)
		fireback.HandleActionInCli(c, result, err, map[string]map[string]string{})
	},
}
var RegisterTransactionSecurityModel *fireback.SecurityModel = nil

type RegisterTransactionActionReqDto struct {
	// Customer email address
	Email string `json:"email" xml:"email" yaml:"email"        `
	// Describe the reason for the transaction
	Description string `json:"description" xml:"description" yaml:"description"        `
	// The amount of transaction which will be payed. It's an integer, make sure you multiply the value by 100 instead of sending a float.
	Amount int64 `json:"amount" xml:"amount" yaml:"amount"        `
}

func (x *RegisterTransactionActionReqDto) RootObjectName() string {
	return "Payment"
}

var RegisterTransactionCommonCliFlagsOptional = []cli.Flag{
	&cli.StringFlag{
		Name:     "x-src",
		Required: false,
		Usage:    `Import the body of the request from a file (e.g. json/yaml) on the disk`,
	},
	&cli.StringFlag{
		Name:  "x-accept",
		Usage: "Return type of the the content, such as json or yaml",
	},
	&cli.StringFlag{
		Name:     "email",
		Required: false,
		Usage:    `Customer email address (string)`,
	},
	&cli.StringFlag{
		Name:     "description",
		Required: false,
		Usage:    `Describe the reason for the transaction (string)`,
	},
	&cli.Int64Flag{
		Name:     "amount",
		Required: false,
		Usage:    `The amount of transaction which will be payed. It's an integer, make sure you multiply the value by 100 instead of sending a float. (int64)`,
	},
}

func RegisterTransactionActionReqValidator(dto *RegisterTransactionActionReqDto) *fireback.IError {
	err := fireback.CommonStructValidatorPointer(dto, false)
	return err
}
func CastRegisterTransactionFromCli(c *cli.Context) *RegisterTransactionActionReqDto {
	template := &RegisterTransactionActionReqDto{}
	fireback.HandleXsrc(c, template)
	if c.IsSet("email") {
		template.Email = c.String("email")
	}
	if c.IsSet("description") {
		template.Description = c.String("description")
	}
	if c.IsSet("amount") {
		value := c.Int64("amount")
		template.Amount = value
	}
	return template
}

type registerTransactionActionImpSig func(
	req *RegisterTransactionActionReqDto,
	q fireback.QueryDSL) (string,
	*fireback.IError,
)

var RegisterTransactionActionImp registerTransactionActionImpSig

func RegisterTransactionActionFn(
	req *RegisterTransactionActionReqDto,
	q fireback.QueryDSL,
) (
	string,
	*fireback.IError,
) {
	if RegisterTransactionActionImp == nil {
		return "", nil
	}
	return RegisterTransactionActionImp(req, q)
}

var RegisterTransactionActionCmd cli.Command = cli.Command{
	Name:  "register",
	Usage: `Initiates a transaction with przelewy24`,
	Flags: RegisterTransactionCommonCliFlagsOptional,
	Action: func(c *cli.Context) {
		query := fireback.CommonCliQueryDSLBuilderAuthorize(c, RegisterTransactionSecurityModel)
		dto := CastRegisterTransactionFromCli(c)
		result, err := RegisterTransactionActionFn(dto, query)
		fireback.HandleActionInCli(c, result, err, map[string]map[string]string{})
	},
}
var CheckProductInventorySecurityModel *fireback.SecurityModel = nil

type checkProductInventoryActionImpSig func(
	q fireback.QueryDSL) (string,
	*fireback.IError,
)

var CheckProductInventoryActionImp checkProductInventoryActionImpSig

func CheckProductInventoryActionFn(
	q fireback.QueryDSL,
) (
	string,
	*fireback.IError,
) {
	if CheckProductInventoryActionImp == nil {
		return "", nil
	}
	return CheckProductInventoryActionImp(q)
}

var CheckProductInventoryActionCmd cli.Command = cli.Command{
	Name:  "check-product-inventory",
	Usage: `It would use the remote api for inventory to check if a product is available and sends it back to the front-end`,
	Action: func(c *cli.Context) {
		query := fireback.CommonCliQueryDSLBuilderAuthorize(c, CheckProductInventorySecurityModel)
		result, err := CheckProductInventoryActionFn(query)
		fireback.HandleActionInCli(c, result, err, map[string]map[string]string{})
	},
}

func PaymentCustomActions() []fireback.Module3Action {
	routes := []fireback.Module3Action{
		{
			Method:        "",
			Url:           "/notifications",
			SecurityModel: NotificationSecurityModel,
			Name:          "notification",
			Description:   "A signal sent by P24 to give the order id into the system",
			Handlers: []gin.HandlerFunc{
				func(c *gin.Context) {
					// POST_ONE -
				},
			},
			Format:         "POST_ONE",
			Action:         NotificationActionFn,
			ResponseEntity: string(""),
			Out: &fireback.Module3ActionBody{
				Entity: "",
			},
			RequestEntity: &NotificationActionReqDto{},
			In: &fireback.Module3ActionBody{
				Entity: "NotificationActionReqDto",
			},
		},
		{
			Method:        "",
			Url:           "/verify-transactions",
			SecurityModel: VerifyTransactionSecurityModel,
			Name:          "verifyTransaction",
			Description:   "Calls a external api to verify a transaction has been done correctly",
			Handlers: []gin.HandlerFunc{
				func(c *gin.Context) {
					// POST_ONE -
				},
			},
			Format:         "POST_ONE",
			Action:         VerifyTransactionActionFn,
			ResponseEntity: string(""),
			Out: &fireback.Module3ActionBody{
				Entity: "",
			},
			RequestEntity: &VerifyTransactionActionReqDto{},
			In: &fireback.Module3ActionBody{
				Entity: "VerifyTransactionActionReqDto",
			},
		},
		{
			Method:        "GET",
			Url:           "/payment/invoice/:uniqueId",
			SecurityModel: PayInvoiceSecurityModel,
			Name:          "payInvoice",
			Description:   "Pay an invoice created independently",
			Handlers: []gin.HandlerFunc{
				func(c *gin.Context) {
					// GET_ONE - get
					fireback.HttpGetEntity(c, PayInvoiceActionFn)
				},
			},
			Format:         "GET_ONE",
			Action:         PayInvoiceActionFn,
			ResponseEntity: string(""),
			Out: &fireback.Module3ActionBody{
				Entity: "",
			},
		},
		{
			Method:        "",
			Url:           "/register-transactions",
			SecurityModel: RegisterTransactionSecurityModel,
			Name:          "registerTransaction",
			Description:   "Initiates a transaction with przelewy24",
			Handlers: []gin.HandlerFunc{
				func(c *gin.Context) {
					// POST_ONE -
				},
			},
			Format:         "POST_ONE",
			Action:         RegisterTransactionActionFn,
			ResponseEntity: string(""),
			Out: &fireback.Module3ActionBody{
				Entity: "",
			},
			RequestEntity: &RegisterTransactionActionReqDto{},
			In: &fireback.Module3ActionBody{
				Entity: "RegisterTransactionActionReqDto",
			},
		},
		{
			Method:        "",
			Url:           "/check-product-inventories",
			SecurityModel: CheckProductInventorySecurityModel,
			Name:          "checkProductInventory",
			Description:   "It would use the remote api for inventory to check if a product is available and sends it back to the front-end",
			Handlers: []gin.HandlerFunc{
				func(c *gin.Context) {
					// POST_ONE -
				},
			},
			Format:         "POST_ONE",
			Action:         CheckProductInventoryActionFn,
			ResponseEntity: string(""),
			Out: &fireback.Module3ActionBody{
				Entity: "",
			},
		},
	}
	return routes
}

var PaymentCustomActionsCli = []cli.Command{
	NotificationActionCmd,
	VerifyTransactionActionCmd,
	PayInvoiceActionCmd,
	RegisterTransactionActionCmd,
	CheckProductInventoryActionCmd,
}

// Only to include some headers
func PaymentJsonInclude() {
	str4 := reflect.ValueOf(nil)
	_ = str4
}

// Use the actions bundle for ease and provide it to the ModuleProvider
// and it would gather all actions in the module level
var PaymentCliActionsBundle = &fireback.CliActionsBundle{
	Name:  "payment",
	Usage: ``,
	// Here we will include entities actions, as well as module level actions
	Subcommands: cli.Commands{
		NotificationActionCmd,
		VerifyTransactionActionCmd,
		PayInvoiceActionCmd,
		RegisterTransactionActionCmd,
		CheckProductInventoryActionCmd,
		PaymentConfigCliFn(),
		InvoiceCliFn(),
		InvoiceTransactionCliFn(),
		PaymentParameterCliFn(),
	},
}

func GetPaymentActionsBundle() *fireback.ModuleActionsBundle {
	return &fireback.ModuleActionsBundle{
		Actions:   PaymentCustomActions(),
		CliAction: PaymentCliActionsBundle,
	}
}
func GetPaymentActionsCli() []cli.Command {
	return PaymentCustomActionsCli
}
