package payment

/*
*	Generated by fireback 1.2.4
*	Written by Ali Torabi.
*	Checkout the repository for licenses and contribution: https://github.com/torabian/fireback
 */
import "github.com/torabian/fireback/modules/fireback"
import "encoding/json"
import "github.com/urfave/cli"
import "gopkg.in/yaml.v2"
import "fmt"
import (
	"github.com/hashicorp/go-retryablehttp"
	"net/http"
)

func PaymentJson() string {
	e := cli.BoolFlag{}
	_ = e
	fmt.Println("Module test config")
	str2, _ := yaml.Marshal("")
	_ = str2
	str, _ := json.MarshalIndent("dont remove me", "", "  ")
	return (string(str))
}

// Module dynamic things comes here. Don't touch it :D
var PERM_ROOT_PAYMENT_EVERYTHING = fireback.PermissionInfo{
	CompleteKey: "root.modules.payment.*",
}
var ALL_PERM_PAYMENT_MODULE = []fireback.PermissionInfo{
	PERM_ROOT_PAYMENT_EVERYTHING,
}

type VerifyTransactionResData struct {
	Token string `json:"token" xml:"token" yaml:"token"        `
}
type RegisterTransactionResData struct {
	Token string `json:"token" xml:"token" yaml:"token"        `
}
type paymentCode string

const (
	PaymentProviderFullyMissing         paymentCode = "PaymentProviderFullyMissing"
	PaymentProviderIsNotAvailable       paymentCode = "PaymentProviderIsNotAvailable"
	PaymentProviderMissingConfiguration paymentCode = "PaymentProviderMissingConfiguration"
	PaymentProviderMissingCrc           paymentCode = "PaymentProviderMissingCrc"
	PaymentProviderMissingMerchantId    paymentCode = "PaymentProviderMissingMerchantId"
	PaymentProviderMissingPosId         paymentCode = "PaymentProviderMissingPosId"
	PaymentProviderMissingSecretId      paymentCode = "PaymentProviderMissingSecretId"
	PaymentProviderMissingUrlReturn     paymentCode = "PaymentProviderMissingUrlReturn"
	PaymentProviderMissingUrlStatus     paymentCode = "PaymentProviderMissingUrlStatus"
	TransactionNotFound                 paymentCode = "TransactionNotFound"
)

var PaymentMessages = newPaymentMessageCode()

func newPaymentMessageCode() *paymentMsgs {
	return &paymentMsgs{
		PaymentProviderFullyMissing: fireback.ErrorItem{
			"$":  "PaymentProviderFullyMissing",
			"en": "Payment Parameters and configuration is fully missing, you need to create a configuration under root",
		},
		PaymentProviderIsNotAvailable: fireback.ErrorItem{
			"$":  "PaymentProviderIsNotAvailable",
			"en": "Payment providers are not available yet. This system doesn't accept any kind of payments at this moment",
		},
		PaymentProviderMissingConfiguration: fireback.ErrorItem{
			"$":  "PaymentProviderMissingConfiguration",
			"en": "You need to configurate the payment provider parameters, some are missing.",
		},
		PaymentProviderMissingCrc: fireback.ErrorItem{
			"$":  "PaymentProviderMissingCrc",
			"en": "CRC is missing",
		},
		PaymentProviderMissingMerchantId: fireback.ErrorItem{
			"$":  "PaymentProviderMissingMerchantId",
			"en": "Merchant Id is missing",
		},
		PaymentProviderMissingPosId: fireback.ErrorItem{
			"$":  "PaymentProviderMissingPosId",
			"en": "Pos Id is missing",
		},
		PaymentProviderMissingSecretId: fireback.ErrorItem{
			"$":  "PaymentProviderMissingSecretId",
			"en": "Secret Id is missing",
		},
		PaymentProviderMissingUrlReturn: fireback.ErrorItem{
			"$":  "PaymentProviderMissingUrlReturn",
			"en": "Url Return is missing",
		},
		PaymentProviderMissingUrlStatus: fireback.ErrorItem{
			"$":  "PaymentProviderMissingUrlStatus",
			"en": "Url Status is missing, P24 won't be able to signal",
		},
		TransactionNotFound: fireback.ErrorItem{
			"$":  "TransactionNotFound",
			"en": "Transaction not found.",
		},
	}
}

type paymentMsgs struct {
	PaymentProviderFullyMissing         fireback.ErrorItem
	PaymentProviderIsNotAvailable       fireback.ErrorItem
	PaymentProviderMissingConfiguration fireback.ErrorItem
	PaymentProviderMissingCrc           fireback.ErrorItem
	PaymentProviderMissingMerchantId    fireback.ErrorItem
	PaymentProviderMissingPosId         fireback.ErrorItem
	PaymentProviderMissingSecretId      fireback.ErrorItem
	PaymentProviderMissingUrlReturn     fireback.ErrorItem
	PaymentProviderMissingUrlStatus     fireback.ErrorItem
	TransactionNotFound                 fireback.ErrorItem
}
type paymentRemoteContext struct {
	client *retryablehttp.Client
}

var PaymentRemotes paymentRemoteContext = paymentRemoteContext{
	client: retryablehttp.NewClient(),
}

// / ProductInventoryAvailability
type ProductInventoryAvailabilityRemoteResponse struct {
	Name      string   `json:"name" xml:"name" yaml:"name"        `
	Platforms []string `json:"platforms" xml:"platforms" yaml:"platforms"        `
}

func (x *paymentRemoteContext) ProductInventoryAvailability(
	headers http.Header,
	opt2 *fireback.RemoteRequestOptions,
) (*ProductInventoryAvailabilityRemoteResponse, *http.Response, *fireback.IError) {
	if headers == nil {
		headers = http.Header{}
	}
	// It's super important to set the content type for request. By default, we assume
	// it's json, this can be extended in Fireback to be able to configurated via yaml
	if headers.Get("content-type") == "" {
		headers.Set("content-type", "application/json")
	}
	result, resp, err := fireback.MakeHTTPRequest(
		x.client,
		"https://api.gamestorm-shop.dev3.muchmore.pl/external-api/products/1",
		nil,
		fireback.HTTPRequestOptions{
			Method:  "get",
			Headers: headers,
		},
	)
	if err != nil {
		return nil, resp, err
	}
	// Let's cast it to the object
	var content *ProductInventoryAvailabilityRemoteResponse
	json.Unmarshal(result, &content)
	return content, resp, nil
}

// / VerifyTransaction
type VerifyTransactionRemoteResponse struct {
	Data  *VerifyTransactionResData `json:"data" xml:"data" yaml:"data"    gorm:"foreignKey:LinkerId;references:UniqueId;constraint:OnDelete:CASCADE"      `
	Error string                    `json:"error" xml:"error" yaml:"error"        `
}
type VerifyTransactionRemoteBody struct {
	PosId      int64  `json:"posId" xml:"posId" yaml:"posId"        `
	MerchantId int64  `json:"merchantId" xml:"merchantId" yaml:"merchantId"        `
	Amount     int64  `json:"amount" xml:"amount" yaml:"amount"        `
	OrderId    int64  `json:"orderId" xml:"orderId" yaml:"orderId"        `
	SessionId  string `json:"sessionId" xml:"sessionId" yaml:"sessionId"        `
	Currency   string `json:"currency" xml:"currency" yaml:"currency"        `
	Sign       string `json:"sign" xml:"sign" yaml:"sign"        `
}

func (x *VerifyTransactionRemoteBody) JsonByte() []byte {
	if x != nil {
		str, _ := json.MarshalIndent(x, "", "  ")
		return str
	}
	return []byte{}
}
func (x *VerifyTransactionRemoteBody) Json() string {
	return string(x.JsonByte())
}
func (x *paymentRemoteContext) VerifyTransaction(
	body *VerifyTransactionRemoteBody,
	headers http.Header,
	opt2 *fireback.RemoteRequestOptions,
) (*VerifyTransactionRemoteResponse, *http.Response, *fireback.IError) {
	if headers == nil {
		headers = http.Header{}
	}
	// It's super important to set the content type for request. By default, we assume
	// it's json, this can be extended in Fireback to be able to configurated via yaml
	if headers.Get("content-type") == "" {
		headers.Set("content-type", "application/json")
	}
	result, resp, err := fireback.MakeHTTPRequest(
		x.client,
		"https://sandbox.przelewy24.pl/api/v1/transaction/verify",
		nil,
		fireback.HTTPRequestOptions{
			Method:  "put",
			Body:    body.JsonByte(),
			Headers: headers,
		},
	)
	if err != nil {
		return nil, resp, err
	}
	// Let's cast it to the object
	var content *VerifyTransactionRemoteResponse
	json.Unmarshal(result, &content)
	return content, resp, nil
}

// / RegisterTransaction
type RegisterTransactionRemoteResponse struct {
	Data  *RegisterTransactionResData `json:"data" xml:"data" yaml:"data"    gorm:"foreignKey:LinkerId;references:UniqueId;constraint:OnDelete:CASCADE"      `
	Error string                      `json:"error" xml:"error" yaml:"error"        `
}
type RegisterTransactionRemoteBody struct {
	MerchantId  int64  `json:"merchantId" xml:"merchantId" yaml:"merchantId"        `
	PosId       int64  `json:"posId" xml:"posId" yaml:"posId"        `
	Amount      int64  `json:"amount" xml:"amount" yaml:"amount"  validate:"required"        `
	SessionId   string `json:"sessionId" xml:"sessionId" yaml:"sessionId"        `
	Country     string `json:"country" xml:"country" yaml:"country"        `
	Currency    string `json:"currency" xml:"currency" yaml:"currency"        `
	Description string `json:"description" xml:"description" yaml:"description"        `
	Email       string `json:"email" xml:"email" yaml:"email"        `
	UrlReturn   string `json:"urlReturn" xml:"urlReturn" yaml:"urlReturn"        `
	UrlStatus   string `json:"urlStatus" xml:"urlStatus" yaml:"urlStatus"        `
	Sign        string `json:"sign" xml:"sign" yaml:"sign"        `
}

func (x *RegisterTransactionRemoteBody) JsonByte() []byte {
	if x != nil {
		str, _ := json.MarshalIndent(x, "", "  ")
		return str
	}
	return []byte{}
}
func (x *RegisterTransactionRemoteBody) Json() string {
	return string(x.JsonByte())
}
func (x *paymentRemoteContext) RegisterTransaction(
	body *RegisterTransactionRemoteBody,
	headers http.Header,
	opt2 *fireback.RemoteRequestOptions,
) (*RegisterTransactionRemoteResponse, *http.Response, *fireback.IError) {
	if headers == nil {
		headers = http.Header{}
	}
	// It's super important to set the content type for request. By default, we assume
	// it's json, this can be extended in Fireback to be able to configurated via yaml
	if headers.Get("content-type") == "" {
		headers.Set("content-type", "application/json")
	}
	result, resp, err := fireback.MakeHTTPRequest(
		x.client,
		"https://sandbox.przelewy24.pl/api/v1/transaction/register",
		nil,
		fireback.HTTPRequestOptions{
			Method:  "post",
			Body:    body.JsonByte(),
			Headers: headers,
		},
	)
	if err != nil {
		return nil, resp, err
	}
	// Let's cast it to the object
	var content *RegisterTransactionRemoteResponse
	json.Unmarshal(result, &content)
	return content, resp, nil
}
