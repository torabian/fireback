package suggestion

/*
*	Generated by fireback 1.2.3
*	Written by Ali Torabi.
*	Checkout the repository for licenses and contribution: https://github.com/torabian/fireback
 */
import (
	"github.com/gin-gonic/gin"
	"github.com/torabian/fireback/modules/fireback"
	"github.com/urfave/cli"
)
import (
	"reflect"
)

// using shared actions here
type QueryResDtoItems struct {
	// The title of the content.
	Title string `json:"title" xml:"title" yaml:"title"        `
	// The excerpt
	Excerpt string `json:"excerpt" xml:"excerpt" yaml:"excerpt"        `
	// The content type group
	ContentType string `json:"contentType" xml:"contentType" yaml:"contentType"        `
}

var QuerySecurityModel *fireback.SecurityModel = nil

type QueryActionReqDto struct {
	// The number of items to return.
	ItemsPerPage int `json:"itemsPerPage" xml:"itemsPerPage" yaml:"itemsPerPage"        `
	// The index of the first item to return.
	StartIndex int `json:"startIndex" xml:"startIndex" yaml:"startIndex"        `
	// The query to search for. It is a string that will be used to search for the content.
	Phrase string `json:"phrase" xml:"phrase" yaml:"phrase"        `
}

func (x *QueryActionReqDto) RootObjectName() string {
	return "Suggestion"
}

var QueryCommonCliFlagsOptional = []cli.Flag{
	&cli.StringFlag{
		Name:     "x-src",
		Required: false,
		Usage:    `Import the body of the request from a file (e.g. json/yaml) on the disk`,
	},
	&cli.StringFlag{
		Name:  "x-accept",
		Usage: "Return type of the the content, such as json or yaml",
	},
	&cli.IntFlag{
		Name:     "items-per-page",
		Required: false,
		Usage:    `The number of items to return. (int)`,
		Value:    10,
	},
	&cli.IntFlag{
		Name:     "start-index",
		Required: false,
		Usage:    `The index of the first item to return. (int)`,
	},
	&cli.StringFlag{
		Name:     "phrase",
		Required: false,
		Usage:    `The query to search for. It is a string that will be used to search for the content. (string)`,
	},
}

func QueryActionReqValidator(dto *QueryActionReqDto) *fireback.IError {
	err := fireback.CommonStructValidatorPointer(dto, false)
	return err
}
func CastQueryFromCli(c *cli.Context) *QueryActionReqDto {
	template := &QueryActionReqDto{}
	fireback.HandleXsrc(c, template)
	if c.IsSet("items-per-page") {
		value := c.Int("items-per-page")
		template.ItemsPerPage = value
	}
	if c.IsSet("start-index") {
		value := c.Int("start-index")
		template.StartIndex = value
	}
	if c.IsSet("phrase") {
		template.Phrase = c.String("phrase")
	}
	return template
}

type QueryActionResDto struct {
	Items []*QueryResDtoItems `json:"items" xml:"items" yaml:"items"    gorm:"foreignKey:LinkerId;references:UniqueId;constraint:OnDelete:CASCADE"      `
}

func (x *QueryActionResDto) RootObjectName() string {
	return "Suggestion"
}

type queryActionImpSig func(
	req *QueryActionReqDto,
	q fireback.QueryDSL) (*QueryActionResDto,
	*fireback.IError,
)

var QueryActionImp queryActionImpSig

func QueryActionFn(
	req *QueryActionReqDto,
	q fireback.QueryDSL,
) (
	*QueryActionResDto,
	*fireback.IError,
) {
	if QueryActionImp == nil {
		return nil, nil
	}
	return QueryActionImp(req, q)
}

var QueryActionCmd cli.Command = cli.Command{
	Name:  "query",
	Usage: `The final result of the query, it is a list of content entities based on the search. It is a list of content entities based on the search.`,
	Flags: QueryCommonCliFlagsOptional,
	Action: func(c *cli.Context) {
		query := fireback.CommonCliQueryDSLBuilderAuthorize(c, QuerySecurityModel)
		dto := CastQueryFromCli(c)
		result, err := QueryActionFn(dto, query)
		fireback.HandleActionInCli(c, result, err, map[string]map[string]string{})
	},
}
var RestoreSecurityModel *fireback.SecurityModel = nil

type restoreActionImpSig func(
	q fireback.QueryDSL) (string,
	*fireback.IError,
)

var RestoreActionImp restoreActionImpSig

func RestoreActionFn(
	q fireback.QueryDSL,
) (
	string,
	*fireback.IError,
) {
	if RestoreActionImp == nil {
		return "", nil
	}
	return RestoreActionImp(q)
}

var RestoreActionCmd cli.Command = cli.Command{
	Name:  "restore",
	Usage: `Deletes the FTS5 table (sqlite) and recreates it.`,
	Action: func(c *cli.Context) {
		query := fireback.CommonCliQueryDSLBuilderAuthorize(c, RestoreSecurityModel)
		result, err := RestoreActionFn(query)
		fireback.HandleActionInCli(c, result, err, map[string]map[string]string{})
	},
}
var ResyncSecurityModel *fireback.SecurityModel = nil

type resyncActionImpSig func(
	q fireback.QueryDSL) (string,
	*fireback.IError,
)

var ResyncActionImp resyncActionImpSig

func ResyncActionFn(
	q fireback.QueryDSL,
) (
	string,
	*fireback.IError,
) {
	if ResyncActionImp == nil {
		return "", nil
	}
	return ResyncActionImp(q)
}

var ResyncActionCmd cli.Command = cli.Command{
	Name:  "resync",
	Usage: `Resyncs the content_virtual table with the content_entities table.`,
	Action: func(c *cli.Context) {
		query := fireback.CommonCliQueryDSLBuilderAuthorize(c, ResyncSecurityModel)
		result, err := ResyncActionFn(query)
		fireback.HandleActionInCli(c, result, err, map[string]map[string]string{})
	},
}

func SuggestionCustomActions() []fireback.Module3Action {
	routes := []fireback.Module3Action{
		{
			Method:        "POST",
			Url:           "/suggestion/query",
			SecurityModel: QuerySecurityModel,
			Name:          "query",
			Description:   "The final result of the query, it is a list of content entities based on the search. It is a list of content entities based on the search.",
			Handlers: []gin.HandlerFunc{
				func(c *gin.Context) {
					// POST_ONE - post
					fireback.HttpPostEntity(c, QueryActionFn)
				},
			},
			Format:         "POST_ONE",
			Action:         QueryActionFn,
			ResponseEntity: &QueryActionResDto{},
			Out: &fireback.Module3ActionBody{
				Entity: "QueryActionResDto",
			},
			RequestEntity: &QueryActionReqDto{},
			In: &fireback.Module3ActionBody{
				Entity: "QueryActionReqDto",
			},
		},
		{
			Method:        "POST",
			Url:           "/restores",
			SecurityModel: RestoreSecurityModel,
			Name:          "restore",
			Description:   "Deletes the FTS5 table (sqlite) and recreates it.",
			Handlers: []gin.HandlerFunc{
				func(c *gin.Context) {
					// POST_ONE - post
					fireback.HttpPost(c, RestoreActionFn)
				},
			},
			Format:         "POST_ONE",
			Action:         RestoreActionFn,
			ResponseEntity: string(""),
			Out: &fireback.Module3ActionBody{
				Entity: "",
			},
		},
		{
			Method:        "POST",
			Url:           "/suggestion/resync",
			SecurityModel: ResyncSecurityModel,
			Name:          "resync",
			Description:   "Resyncs the content_virtual table with the content_entities table.",
			Handlers: []gin.HandlerFunc{
				func(c *gin.Context) {
					// POST_ONE - post
					fireback.HttpPost(c, ResyncActionFn)
				},
			},
			Format:         "POST_ONE",
			Action:         ResyncActionFn,
			ResponseEntity: string(""),
			Out: &fireback.Module3ActionBody{
				Entity: "",
			},
		},
	}
	return routes
}

var SuggestionCustomActionsCli = []cli.Command{
	QueryActionCmd,
	RestoreActionCmd,
	ResyncActionCmd,
}

// Only to include some headers
func SuggestionJsonInclude() {
	str4 := reflect.ValueOf(nil)
	_ = str4
}

// Use the actions bundle for ease and provide it to the ModuleProvider
// and it would gather all actions in the module level
var SuggestionCliActionsBundle = &fireback.CliActionsBundle{
	Name:  "suggestion",
	Usage: `Suggestion module is a way to rank contents, such as video, posts, etc to users, based on full text search, user interaction, location, and so on. Aims to be general purpose, and allow to be extended.`,
	// Here we will include entities actions, as well as module level actions
	Subcommands: cli.Commands{
		QueryActionCmd,
		RestoreActionCmd,
		ResyncActionCmd,
		ContentCliFn(),
	},
}

func GetSuggestionActionsBundle() *fireback.ModuleActionsBundle {
	return &fireback.ModuleActionsBundle{
		Actions:   SuggestionCustomActions(),
		CliAction: SuggestionCliActionsBundle,
	}
}
func GetSuggestionActionsCli() []cli.Command {
	return SuggestionCustomActionsCli
}
