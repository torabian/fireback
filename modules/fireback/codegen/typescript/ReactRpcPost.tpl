/*
*	Generated by fireback {{ .fv }}
*	Written by Ali Torabi.
* The code is generated for react-query@v3.39.3
*	Checkout the repository for licenses and contribution: https://github.com/torabian/fireback
*/

import { FormikHelpers } from "formik";
import { useContext, useState, useRef } from "react";
import { useMutation } from "react-query";
import { 
  execApiFn,
  IResponse,
  mutationErrorsToFormik,
  IResponseList
} from "../../core/http-tools";

import {
  RemoteQueryContext,
  UseRemoteQuery,
  queryBeforeSend,
  {{ if eq .r.MethodUpper "WEBRTC" }}
  useWebrtcConnection,
  {{ end }}

} from "../../core/react-tools";

{{ template "tsimport" . }}


export function use{{ .r.GetFuncNameUpper}}(
  props?: UseRemoteQuery & { 
    {{ if eq .r.MethodUpper "WEBRTC" }}
    autoConnect?: boolean 
    {{ end }}
  }
) {
  let {queryClient, query, execFnOverride} = props || {};

  query = query || {}
  
  const { options, execFn } = useContext(RemoteQueryContext);
 

  // Calculare the function which will do the remote calls.
  // We consider to use global override, this specific override, or default which
  // comes with the sdk.
  const rpcFn = execFnOverride
    ? execFnOverride(options)
    : execFn
    ? execFn(options)
    : execApiFn(options);

  // Url of the remote affix.
  const url = "{{ .r.Url}}".substr(1);

  let computedUrl = `${url}?${new URLSearchParams(
    queryBeforeSend(query)
  ).toString()}`;

  {{ template "routeUrl" .r }}

  // Attach the details of the request to the fn
  const fn = (body: any) => rpcFn("{{ .r.MethodUpper }}", computedUrl, body);

  const mutation = useMutation<
    IResponse<{{ .r.ResponseEntityComputed}}>,
    IResponse<{{ .r.ResponseEntityComputed}}>,
    {{ if eq .r.RequestEntityComputed ""}}
    any
    {{ else }}
    Partial<{{ .r.RequestEntityComputed}}>
    {{ end }}
  >(fn);

  // Only entities are having a store in front-end

  const fnUpdater = (
    data: IResponseList<{{ .r.ResponseEntityComputed}}> | undefined,
    item: IResponse<{{ .r.ResponseEntityComputed}}>
  ) => {
    if (!data) {
      return {
        data: { items: [] },
      };
    }

    // To me it seems this is not a good or any correct strategy to update the store.
    // When we are posting, we want to add it there, that's it. Not updating it.
    // We have patch, but also posting with ID is possible.
    if (data.data && item?.data) {
      data.data.items = [item.data, ...(data?.data?.items || [])];
    }
 
    return data;
  };
 

  const submit = (
    {{ if eq .r.RequestEntityComputed ""}}
    values: any,
    {{ else }}
    values: Partial<{{ .r.RequestEntityComputed}}>,
    {{ end }}
    formikProps?: FormikHelpers<Partial<{{ .r.ResponseEntityComputed}}>>
  ): Promise<IResponse<{{ .r.ResponseEntityComputed}}>> => {
    return new Promise((resolve, reject) => {
      
      mutation.mutate(values, {
        onSuccess(response: IResponse<{{ .r.ResponseEntityComputed}}>) {
          queryClient?.setQueryData<IResponseList<{{ .r.ResponseEntityComputed}}>>(
            "{{ .r.EntityKey }}",
            (data) => fnUpdater(data, response) as any
          );

          resolve(response);
        },

        onError(error: any) {
          formikProps?.setErrors(mutationErrorsToFormik(error));

          reject(error);
        },
      });
    });
  };


  {{ if eq .r.MethodUpper "WEBRTC" }}
  let pc = useRef<RTCPeerConnection>();
  let dataChannel = useRef<{
    mouse: RTCDataChannel;
    ram: RTCDataChannel;
  }>();

  const dataChannels = [
    {
      name: "mouse",
    },
    {
      name: "ram",
    },
  ];

  const { initiate, state } = useWebrtcConnection({
    pc,
    dataChannel,
    dataChannels,
    submit,
    autoConnect: props.autoConnect,
  });

  return { mutation, submit, fnUpdater, dataChannel, initiate, state };

  {{ else}}

  return { mutation, submit, fnUpdater };

  {{ end }}
}
