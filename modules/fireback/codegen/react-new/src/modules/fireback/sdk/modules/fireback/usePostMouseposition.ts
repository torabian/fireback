/*
 *	Generated by fireback 1.2.2
 *	Written by Ali Torabi.
 * The code is generated for react-query@v3.39.3
 *	Checkout the repository for licenses and contribution: https://github.com/torabian/fireback
 */
import { FormikHelpers } from "formik";
import {
  MutableRefObject,
  useContext,
  useEffect,
  useRef,
  useState,
} from "react";
import { useMutation } from "react-query";
import {
  execApiFn,
  IResponse,
  mutationErrorsToFormik,
  IResponseList,
} from "../../core/http-tools";
import {
  RemoteQueryContext,
  UseRemoteQuery,
  queryBeforeSend,
} from "../../core/react-tools";
import {
  MousePositionCaptureActionReqDto,
  MousePositionCaptureActionResDto,
} from "../fireback/FirebackActionsDto";
export function usePostMouseposition(
  props?: UseRemoteQuery & { autoConnect?: boolean }
) {
  let { queryClient, query, execFnOverride } = props || {};
  query = query || {};
  const { options, execFn } = useContext(RemoteQueryContext);
  // Calculare the function which will do the remote calls.
  // We consider to use global override, this specific override, or default which
  // comes with the sdk.
  const rpcFn = execFnOverride
    ? execFnOverride(options)
    : execFn
    ? execFn(options)
    : execApiFn(options);
  // Url of the remote affix.
  const url = "/mouseposition".substr(1);
  let computedUrl = `${url}?${new URLSearchParams(
    queryBeforeSend(query)
  ).toString()}`;
  let completeRouteUrls = true;
  // Attach the details of the request to the fn
  const fn = (body: any) => rpcFn("POST", computedUrl, body);
  const mutation = useMutation<
    IResponse<MousePositionCaptureActionResDto>,
    IResponse<MousePositionCaptureActionResDto>,
    Partial<MousePositionCaptureActionReqDto>
  >(fn);
  // Only entities are having a store in front-end
  const fnUpdater = (
    data: IResponseList<MousePositionCaptureActionResDto> | undefined,
    item: IResponse<MousePositionCaptureActionResDto>
  ) => {
    if (!data) {
      return {
        data: { items: [] },
      };
    }
    // To me it seems this is not a good or any correct strategy to update the store.
    // When we are posting, we want to add it there, that's it. Not updating it.
    // We have patch, but also posting with ID is possible.
    if (data.data && item?.data) {
      data.data.items = [item.data, ...(data?.data?.items || [])];
    }
    return data;
  };
  const submit = (
    values: Partial<MousePositionCaptureActionReqDto>,
    formikProps?: FormikHelpers<Partial<MousePositionCaptureActionResDto>>
  ): Promise<IResponse<MousePositionCaptureActionResDto>> => {
    return new Promise((resolve, reject) => {
      mutation.mutate(values, {
        onSuccess(response: IResponse<MousePositionCaptureActionResDto>) {
          queryClient?.setQueryData<
            IResponseList<MousePositionCaptureActionResDto>
          >(
            "*fireback.MousePositionCaptureActionResDto",
            (data) => fnUpdater(data, response) as any
          );
          resolve(response);
        },
        onError(error: any) {
          formikProps?.setErrors(mutationErrorsToFormik(error));
          reject(error);
        },
      });
    });
  };

  let pc = useRef<RTCPeerConnection>();
  let dataChannel = useRef<{
    mouse: RTCDataChannel;
    ram: RTCDataChannel;
  }>();

  const dataChannels = [
    {
      name: "mouse",
    },
    {
      name: "ram",
    },
  ];

  const { initiate, state } = useWebrtcConnection({
    pc,
    dataChannel,
    dataChannels,
    submit,
    autoConnect: props.autoConnect,
  });

  return { mutation, submit, fnUpdater, dataChannel, initiate, state };
}

const useWebrtcConnection = ({
  pc,
  submit,
  dataChannels,
  dataChannel,
  autoConnect,
}: {
  pc: MutableRefObject<RTCPeerConnection>;
  submit: any;
  dataChannels: Array<{ name: string }>;
  dataChannel: MutableRefObject<any>;
  autoConnect?: boolean;
}) => {
  const [state, setState] = useState("idle");

  const executeInit = async () => {
    setState("initiating");
    const offer = await pc.current.createOffer();
    setState("offerCreated");
    await pc.current.setLocalDescription(offer);

    await new Promise((resolve) => {
      if (pc.current.iceGatheringState === "complete") {
        resolve(true);
      } else {
        pc.current.onicegatheringstatechange = () => {
          if (pc.current.iceGatheringState === "complete") resolve(true);
        };
      }
    });

    setState("iceComplete");
    const answer = await submit({ offer: offer } as any);

    setState("answerReady");
    await pc.current.setRemoteDescription(answer.data.sessionDescription);

    setState("connected");
  };

  const initiate = async () => {
    // let's initiate the webrtc
    pc.current = new RTCPeerConnection({
      iceServers: [{ urls: "stun:stun.l.google.com:19302" }],
    });

    for (const channel of dataChannels) {
      dataChannel.current = {
        ...dataChannel.current,
        [channel.name]: pc.current.createDataChannel(channel.name),
      };
    }

    executeInit().catch((err) => {
      console.log(err);
    });
  };

  useEffect(() => {
    if (autoConnect !== false) {
      initiate();
    }
  }, []);

  return {
    initiate,
    state,
  };
};
