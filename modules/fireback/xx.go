package fireback

/*
*	Generated by fireback 1.2.1
*	Written by Ali Torabi.
*	Checkout the repository for licenses and contribution: https://github.com/torabian/fireback
 */
import (
	"errors"
	"fmt"
	"log"
	"regexp"
	"strconv"

	"github.com/gin-gonic/gin"
	"github.com/manifoldco/promptui"
	"github.com/urfave/cli"
	"go.uber.org/zap"
	"gopkg.in/yaml.v2"
	"gorm.io/gorm"
)

func GetCommonWebServerCliActions(xapp *FirebackApp) cli.Commands {

	return cli.Commands{
		CLIInit(xapp),
		EnvManagement(xapp),
		CodeGenTools(xapp),
		GetApplicationTasks(xapp),
		CLIDoctor,
		CLIServiceCommand,
		ConfigCommand,
		GetMigrationCommand(xapp),
		GetHttpCommand(func(cfg HttpServerInstanceConfig) *gin.Engine {
			return SetupHttpServer(xapp, cfg)
		}),
		GetCliMockTools(xapp),
		GetSeeder(xapp),
		GetReportsTool(xapp),
		GetCapabilityRefreshCommand(xapp),

		// Keep these in the last
		CLIAboutCommand,
		Cliversion,
	}
}
func GetCommonMicroserviceCliActions(xapp *FirebackApp) cli.Commands {

	return cli.Commands{
		CLIInit(xapp),
		GetApplicationTasks(xapp),
		CLIDoctor,
		CLIServiceCommand,
		ConfigCommand,
		GetMigrationCommand(xapp),
		GetHttpCommand(func(cfg HttpServerInstanceConfig) *gin.Engine {
			return SetupHttpServer(xapp, cfg)
		}),
		GetCliMockTools(xapp),
		GetSeeder(xapp),
		GetReportsTool(xapp),
	}
}

var ROOT_ALL_ACCESS = "root.*"
var ROOT_ALL_MODULES = "root.modules.*"

func UpsertPermission(permInfo *PermissionInfo, hasChildren bool, db *gorm.DB) {
	var entity *CapabilityEntity = nil
	perm := permInfo.CompleteKey

	if hasChildren {
		perm = perm + ".*"
	}

	system := "system"

	if (db.Where(CapabilityEntity{UniqueId: perm}).First(&entity).Error != nil) {
		err := db.Create(&CapabilityEntity{
			UniqueId:    perm,
			WorkspaceId: NewString(system),
			Visibility:  NewString("A"),
			Description: permInfo.Description,
			Name:        permInfo.Name,
		}).Error

		if err != nil {
			log.Fatalln("Cannot start the app because a permission creation failed.", perm, err)
		}
	}
}

var USER_SYSTEM = "system"

func FormatYamlKeys(yamlStr string) string {
	// Regular expression to match YAML keys
	keyRegex := regexp.MustCompile(`(?m)^( *)([^:]+):`)

	// Replace keys with green bold text
	formattedYaml := keyRegex.ReplaceAllString(yamlStr, fmt.Sprintf("$1%s$2%s:", GreenBold, Reset))

	return formattedYaml
}

var DATABASE_TYPE_MYSQL string = "mysql"
var DATABASE_TYPE_SQLITE string = "sqlite"
var DATABASE_TYPE_SQLITE_MEMORY string = "sqlite (:memory:)"
var DATABASE_TYPE_POSTGRES string = "postgres"
var DATABASE_TYPE_MARIADB string = "mariadb"

var ROOT_VAR = "root"

var WithSocketAuthorization = func(securityModel *SecurityModel) gin.HandlerFunc {
	return func(c *gin.Context) {

	}
}

var WithAuthorizationFn = func(securityModel *SecurityModel) gin.HandlerFunc {

	return func(c *gin.Context) {

	}
}

type UserAccessPerWorkspaceDto map[string]*struct {

	// The access which are available to this workspace, not to the specific user.
	// Even a user has access to many things, these accesses need to reduce those
	WorkspacesAccesses []string

	// The permissions which user has access to
	UserRoles map[string]*struct {
		Name     string
		Accesses []string
	}
}

var WithAuthorizationPure = func(context *AuthContextDto) (*AuthResultDto, *IError) {
	return &AuthResultDto{}, nil
}

type DoctorHeadData struct {
	ConfigurationUrl    string `yaml:"configurationUrl"`
	FirebackVersion     string `yaml:"firebackVersion"`
	DatabaseVendor      string `yaml:"databaseVendor"`
	ComputedDataBaseDsn string `yaml:"computedDataBaseDsn"`
}
type GeneralDoctorData struct {
	General         DoctorHeadData   `yaml:"general"`
	EnvironmentUris *EnvironmentUris `yaml:"environmentUris"`
	Config          Config           `yaml:"config"`
}

func (x *GeneralDoctorData) Yaml() string {
	if x != nil {
		str, _ := yaml.Marshal(x)
		return (string(str))
	}
	return ""
}

func Doctor() {

	uri, _ := ResolveConfigurationUri()
	vendor, dsn := GetDatabaseDsn(config)
	data := GeneralDoctorData{
		General: DoctorHeadData{
			ConfigurationUrl:    uri,
			FirebackVersion:     FIREBACK_VERSION,
			DatabaseVendor:      vendor,
			ComputedDataBaseDsn: dsn,
		},
		EnvironmentUris: GetEnvironmentUris(),
		Config:          config,
	}

	fmt.Println(Bold + "General information:" + Reset)
	fmt.Println(FormatYamlKeys(data.Yaml()))

	fmt.Println()
	fmt.Println(Bold + "Environment urls:" + Reset)
	fmt.Println(FormatYamlKeys(GetEnvironmentUris().Yaml()))

	fmt.Println()
	fmt.Println(Bold + "Configuration:" + Reset)
	fmt.Println(FormatYamlKeys(config.Yaml()))
}

const (
	Reset     = "\033[0m"
	Green     = "\033[32m"
	Orange    = "\033[31m"
	Bold      = "\033[1m"
	GreenBold = "\033[32;1m"
)

var CLIDoctor cli.Command = cli.Command{

	Name:  "doctor",
	Usage: "Gives some information about the app, operating system, for remote debugging",

	Action: func(c *cli.Context) error {
		Doctor()
		return nil
	},
}

func ConfigSetBoolean(c *cli.Context, currentValue bool, setValue func(value bool)) error {
	if len(c.Args()) > 0 {
		var value bool = false
		read := c.Args()[0]
		if read == "true" || read == "1" || read == "yes" {
			value = true
		} else if read == "false" || read == "0" || read == "no" {
			value = false
		} else {
			return errors.New("the value for boolean needs to be true, false, 0, 1, yes, no")
		}

		setValue(value)
	} else {
		curr := "unknown"
		if currentValue {
			curr = "true"
		} else {
			curr = "false"
		}
		result := AskForSelect("Set the value to? Current value: "+curr, []string{"true", "false"})

		if result == "true" {
			setValue(true)
		}
		if result == "false" {
			setValue(false)
		}
	}

	return config.Save(".env")
}
func ConfigSetString(c *cli.Context, currentValue string, setValue func(value string)) error {
	if len(c.Args()) > 0 {
		var value string = c.Args()[0]
		setValue(value)
	} else {
		result := AskForInput("Set the value to?", currentValue)
		setValue(result)
	}

	return config.Save(".env")
}

func ConfigSetInt64(c *cli.Context, currentValue int64, setValue func(value int64)) error {
	if len(c.Args()) > 0 {
		var value string = c.Args()[0]

		intValue, err := strconv.ParseInt(value, 10, 64)
		if err != nil {
			fmt.Println("Error:", err)
		} else {
			setValue(intValue)
		}

	} else {
		result := AskForInput("Set the value to?", strconv.FormatInt(currentValue, 10))
		intValue, err := strconv.ParseInt(result, 10, 64)

		if err != nil {
			fmt.Println("Error:", err)
		} else {
			setValue(intValue)
		}
	}

	return config.Save(".env")
}

func ConfigSetInt(c *cli.Context, currentValue int, setValue func(value int)) error {
	if len(c.Args()) > 0 {
		var value string = c.Args()[0]

		intValue, err := strconv.ParseInt(value, 10, 64)
		if err != nil {
			fmt.Println("Error:", err)
		} else {
			setValue(int(intValue))
		}

	} else {
		result := AskForInput("Set the value to?", strconv.FormatInt(int64(currentValue), 10))
		intValue, err := strconv.ParseInt(result, 10, 64)

		if err != nil {
			fmt.Println("Error:", err)
		} else {
			setValue(int(intValue))
		}
	}

	return config.Save(".env")
}

func ConfigSetFloat64(c *cli.Context, currentValue float64, setValue func(value float64)) error {
	if len(c.Args()) > 0 {
		var value string = c.Args()[0]

		floatValue, err := strconv.ParseFloat(value, 64)
		if err != nil {
			fmt.Println("Error:", err)
		} else {
			setValue(floatValue)
		}

	} else {
		result := AskForInput("Set the value to?", fmt.Sprintf("%f", currentValue))
		floatValue, err := strconv.ParseFloat(result, 64)

		if err != nil {
			fmt.Println("Error:", err)
		} else {
			setValue(floatValue)
		}
	}

	return config.Save(".env")
}

func GetHttpCommand(engineFn func(cfg2 HttpServerInstanceConfig) *gin.Engine) cli.Command {
	return cli.Command{
		Flags: []cli.Flag{
			&cli.Int64Flag{
				Name:  "port",
				Usage: "The port that the server will come up. Defaults to the user configuration file",
			},
			&cli.BoolFlag{
				Name:  "watch",
				Usage: "Monitor server stat using charts and interactive graphics",
			},
			&cli.BoolFlag{
				Name:  "ssl",
				Usage: "Runs ssl server on 443 port",
			},
			&cli.BoolFlag{
				Name:  "slow",
				Usage: "Makes a delay on serving xattach files to mimic slow server, might slow down also API calls",
			},
		},
		Name:    "start",
		Aliases: []string{"s"},
		Usage:   "Starts http server only",
		Action: func(c *cli.Context) error {

			initLogger()
			if !config.Production {
				Doctor()
			}
			cfg2 := HttpServerInstanceConfig{
				Monitor: c.Bool("watch"),
				Port:    c.Int64("port"),
				SSL:     c.Bool("ssl"),
				Slow:    c.Bool("slow"),
			}
			engine := engineFn(cfg2)
			CreateHttpServer(engine, cfg2)

			return nil
		},
	}
}

func initLogger() {

	if config.Production {
		logger, _ := zap.NewProduction()
		LOG = logger
		defer logger.Sync() // Flushes buffer, if any
	} else {
		logger, _ := zap.NewDevelopment()
		LOG = logger
		defer logger.Sync() // Flushes buffer, if any
	}

}

var ConfigCommand cli.Command = cli.Command{

	Name:  "config",
	Usage: "Set of tools to configurate the product",
	Subcommands: append([]cli.Command{
		{

			Name:  "db",
			Usage: "Configurates the database of the project",
			Action: func(c *cli.Context) error {

				databaseData, err := askProjectDatabase(config.Name)
				if err != nil {
					log.Fatalln("Database could not be determined after all", err)
					return nil
				}

				config.DbUsername = databaseData.Username
				p, _ := strconv.Atoi(databaseData.Port)
				config.DbPort = int64(p)
				config.DbHost = databaseData.Host
				config.DbPassword = databaseData.Password
				config.DbName = databaseData.Database
				config.DbVendor = databaseData.Vendor
				config.DbDsn = databaseData.Dsn

				if _, err := DirectConnectToDb(config); err != nil {
					fmt.Println("Connection to database failed:", err)
					return nil
				} else {
					fmt.Println("Database connected")
				}

				config.Save(".env")

				return nil
			},
		},
		{

			Name:  "dbdsn",
			Usage: "Returns the database dsn which will be used",
			Action: func(c *cli.Context) error {
				fmt.Println(GetDatabaseDsn(config))

				return nil
			},
		},
		{

			Name:  "ssl",
			Usage: "Wizard to configurate the ssl on the server",
			Action: func(c *cli.Context) error {

				AskSSL(&config)

				config.Save(".env")

				return nil
			},
		},
		{

			Name:  "sqllog",
			Usage: "Change the sql log level",
			Action: func(c *cli.Context) error {

				askSqlLogLevel(&config)

				config.Save(".env")

				return nil
			},
		},
	}, GetConfigCli()...),
}

func askProjectDatabase(projectName string) (Database, error) {
	db := Database{}

	promptVariable := promptui.Select{
		Label: "Database type",
		Items: []string{
			DATABASE_TYPE_SQLITE_MEMORY,
			DATABASE_TYPE_SQLITE,
			DATABASE_TYPE_MYSQL,
			DATABASE_TYPE_MARIADB,
			// Postgres is not well tested yet, we are not adding production ready
			// features anymore in fireback at all.
			// DATABASE_TYPE_POSTGRES,
		},
	}

	_, databaseType, err := promptVariable.Run()
	if err != nil {
		fmt.Printf("Prompt failed %v\n", err)
		return db, err
	}

	db.Vendor = databaseType

	if db.Vendor == "sqlite" {
		path, err := askSQLiteDatabaseLocation(projectName)
		if err != nil {
			fmt.Printf("cannot access the sqlite database, or cannot create it %v\n", err)
			return db, err
		}
		db.Database = path
	} else if db.Vendor == DATABASE_TYPE_SQLITE_MEMORY {
		db.Database = ":memory:"
		db.Vendor = "sqlite"
	} else if db.Vendor == DATABASE_TYPE_MYSQL || db.Vendor == DATABASE_TYPE_MARIADB {
		askMysqlDetails(&db)
	} else if db.Vendor == DATABASE_TYPE_POSTGRES {
		askPostgresDetails(&db)
	}

	return db, nil
}

func askMysqlDetails(db *Database) (*Database, error) {

	promptVariable := promptui.Select{
		Label: "Do you have dsn string or port, host , username?",
		Items: []string{USE_DSN_OPTION, USE_MANUAL_OPTION},
	}

	_, actionType, err := promptVariable.Run()
	if err != nil {
		fmt.Printf("Prompt failed %v\n", err)
		return db, err
	}

	if actionType == USE_DSN_OPTION {
		value, err := askMysqlDsn()

		if err != nil {
			fmt.Printf("Prompt failed %v\n", err)
			return db, err
		}

		db.Dsn = value

		return db, nil
	}

	if actionType == USE_MANUAL_OPTION {

		db.Host = askHostName()
		db.Port = askHostPort("3306")
		db.Database = askDatabaseName()
		db.Username = askHostUsername("root")
		db.Password = askHostPassword()
	}

	return db, nil
}

func askHostUsername(defaultUsername string) string {
	validate := func(input string) error {
		if input == "" {
			return errors.New("enter database username")
		}
		return nil
	}

	promptVariable := promptui.Prompt{
		Label:    "Database username",
		Validate: validate,
		Default:  defaultUsername,
	}

	hostname, err := promptVariable.Run()
	if err != nil {
		fmt.Printf("Prompt failed %v\n", err)
		return ""
	}

	return hostname
}

func promptInput(label, defaultValue string, validate func(string) error) string {
	promptVariable := promptui.Prompt{
		Label:    label,
		Default:  defaultValue,
		Validate: validate,
	}

	result, err := promptVariable.Run()
	if err != nil {
		fmt.Printf("Prompt failed: %v\n", err)
		return ""
	}

	return result
}

func askDatabaseName() string {
	validateDatabaseName := func(input string) error {
		if input == "" {
			return errors.New("database name is required on this type of databse.")
		}
		return nil
	}

	return promptInput("Database name", "", validateDatabaseName)
}

func askHostName() string {
	validate := func(input string) error {
		if input == "" {
			return errors.New("enter the mysql host, for example localhost")
		}
		return nil
	}

	promptVariable := promptui.Prompt{
		Label:    "The host, ip which mysql is installed. (eg. 127.0.0.1 or localhost or 210.231.20.30",
		Validate: validate,
		Default:  "localhost",
	}

	hostname, err := promptVariable.Run()
	if err != nil {
		fmt.Printf("Prompt failed %v\n", err)
		return ""
	}

	return hostname
}

func AskPortName(label string, defaultPort string) string {
	validate := func(input string) error {
		if input == "" {
			return errors.New("port should be between 0 to 65536")
		}
		return nil
	}

	promptVariable := promptui.Prompt{
		Label:    label,
		Validate: validate,
		Default:  defaultPort,
	}

	hostname, err := promptVariable.Run()
	if err != nil {
		fmt.Printf("Prompt failed %v\n", err)
		return ""
	}

	return hostname
}

func AskFolderName(label string, defaultFolder string) string {
	validate := func(input string) error {
		if input == "" {
			return errors.New("this folder is necessary for file uploads")
		}
		return nil
	}

	promptVariable := promptui.Prompt{
		Label:    label,
		Validate: validate,
		Default:  defaultFolder,
	}

	hostname, err := promptVariable.Run()
	if err != nil {
		fmt.Printf("Prompt failed %v\n", err)
		return ""
	}

	return hostname
}

func askHostPassword() string {

	promptVariable := promptui.Prompt{
		Label:   "password",
		Default: "",
	}

	hostname, err := promptVariable.Run()
	if err != nil {
		fmt.Printf("Prompt failed %v\n", err)
		return ""
	}

	return hostname
}

func askHostPort(defaultp string) string {
	validate := func(input string) error {
		if input == "" {
			return errors.New("enter the database port")
		}
		return nil
	}

	promptVariable := promptui.Prompt{
		Label:    "port",
		Validate: validate,
		Default:  defaultp,
	}

	hostname, err := promptVariable.Run()
	if err != nil {
		fmt.Printf("Prompt failed %v\n", err)
		return ""
	}

	return hostname
}

var USE_DSN_OPTION = "I have dsn query string for connection"
var USE_MANUAL_OPTION = "I enter port, host, username of database manually"

var TRY_TO_SOLVE = "Let me retry to configurate the database parameters"
var FORCE_CONTINUE = "Use the configuration without connection test"

func askSqlLogLevel(cfg *Config) {

	SILENT_PICK := "Silent - shows nothing, useful for production environment"
	ERROR_PICK := "Error - Show sql errors"
	WARNING_PICK := "Warning - show only warnings"
	INFO_PICK := "Info - prints all queries to the database"

	level := AskForSelect("Select the database log level for SQL queries", []string{
		SILENT_PICK,
		ERROR_PICK,
		WARNING_PICK,
		INFO_PICK,
	})

	if level == SILENT_PICK {
		cfg.DbLogLevel = "silent"
	}
	if level == INFO_PICK {
		cfg.DbLogLevel = "info"
	}
	if level == WARNING_PICK {
		cfg.DbLogLevel = "warning"
	}
	if level == ERROR_PICK {
		cfg.DbLogLevel = "error"
	}

	cfg.Save(".env")
}

func AskSSL(config *Config) {

	if r := AskForSelect("Use SSL instead of Plain Http?", []string{"no", "yes"}); r == "yes" {
		config.UseSSL = true

		config.CertFile = AskFolderName("Certfile address", "/etc/letsencrypt/live/")
		config.KeyFile = AskFolderName("Keyfile address", "/etc/letsencrypt/live/")

	} else {
		config.UseSSL = false
	}

	config.Save(".env")
}

func askPostgresDetails(db *Database) (*Database, error) {

	promptVariable := promptui.Select{
		Label: "Do you have dsn string or port, host , username?",
		Items: []string{USE_DSN_OPTION, USE_MANUAL_OPTION},
	}

	_, actionType, err := promptVariable.Run()
	if err != nil {
		fmt.Printf("Prompt failed %v\n", err)
		return db, err
	}

	if actionType == USE_DSN_OPTION {
		value, err := askPostgresDsn()

		if err != nil {
			fmt.Printf("Prompt failed %v\n", err)
			return db, err
		}

		db.Dsn = value

		return db, nil
	}

	if actionType == USE_MANUAL_OPTION {

		db.Host = askHostName()
		db.Port = askHostPort("5432")
		db.Database = askDatabaseName()
		db.Username = askHostUsername("postgres")
		db.Password = askHostPassword()
	}

	return db, nil
}

func GetCliMockTools(xapp *FirebackApp) cli.Command {
	return cli.Command{
		Name:  "mock",
		Usage: "Generates or export mocks based on all available content inside the database",
		Subcommands: cli.Commands{
			{

				Name:  "import",
				Usage: "Execute the mock services, and populates the entire backend with data and instructions",
				Action: func(c *cli.Context) error {

					fmt.Println("This function would create a virtual product, by first running mock data into database, and then run some actions as specified")
					ExecuteMockImport(xapp)
					return nil
				},
			},
			{
				Name:  "write",
				Usage: "Writes the instructions and module mock data into the sample json files. Clean system before, run mock-import, and then execute this to keep data safe",
				Action: func(c *cli.Context) error {

					fmt.Println("Writing all mocks into artifacts folder...")
					ExecuteMockWriter(xapp)
					return nil
				},
			},
		},
	}
}

var CLIServiceCommand cli.Command = cli.Command{

	Name:  "service",
	Usage: "Manages the system service on operating system",
	Subcommands: []cli.Command{
		{

			Name:    "unload",
			Aliases: []string{"u"},
			Usage:   "Unloads the system service",
			Action: func(c *cli.Context) error {
				SystemServiceHandler("unload", c)

				return nil
			},
		},
		{

			Name:    "reload",
			Aliases: []string{"r"},
			Usage:   "Unloads the service, and basically loads it once again.",
			Action: func(c *cli.Context) error {
				SystemServiceHandler("reload", c)

				return nil
			},
		},
		{

			Name:    "mac-daemon",
			Aliases: []string{"mac"},
			Usage:   "Shows the mac daemon path",
			Action: func(c *cli.Context) error {
				fmt.Println("Daemon path:", GetMacDaemon())
				return nil
			},
		},
		{
			Flags: []cli.Flag{
				&cli.StringFlag{
					Name:  "stderr",
					Value: "",
					Usage: "Where to log the error messages, such as /tmp/fireback-err.log",
				},
				&cli.StringFlag{
					Name:  "stdout",
					Value: "",
					Usage: "Where to log the standard output messages, such as /tmp/fireback.log",
				},
			},
			Name:    "load",
			Aliases: []string{"l"},
			Usage:   "Starts the system service",
			Action: func(c *cli.Context) error {
				SystemServiceHandler("load", c)

				return nil
			},
		},
	},
}

func CLIInit(xapp *FirebackApp) cli.Command {

	return cli.Command{
		Name:  "init",
		Usage: "Creates a environment for project, by configurating database connection, http port, etc.",
		Flags: GetConfigCliFlags(),
		Action: func(c *cli.Context) error {
			if c.NumFlags() > 0 {
				CastConfigFromCli(&config, c)

				if !c.IsSet("mac-identifier") {
					config.MacIdentifier = config.Name
				}

				if !c.IsSet("debian-identifier") {
					config.DebianIdentifier = config.Name
				}

				if !c.IsSet("windows-identifier") {
					config.WindowsIdentifier = config.Name
				}

				config.Save(".env")
			} else {
				InitEnvironment(xapp, ".env")
			}
			return nil
		},
	}
}

func DataBaseConfigEnv(xapp *FirebackApp) error {

	// 2. Determine the database type, test the connection, create tables
	for {
		databaseData, err := askProjectDatabase(config.Name)
		if err != nil {
			log.Fatalln("cannot determine the database config", err)
			return nil
		}

		// 3. Check if the database could be connected, if not show error and move on
		config.DbUsername = databaseData.Username
		p, _ := strconv.Atoi(databaseData.Port)
		config.DbPort = int64(p)
		config.DbHost = databaseData.Host
		config.DbPassword = databaseData.Password
		config.DbName = databaseData.Database
		config.DbVendor = databaseData.Vendor
		config.DbDsn = databaseData.Dsn

		db, err := DirectConnectToDb(config)
		if err == nil && db.Exec("select 1").Error == nil {
			config.Save(".env")
			fmt.Println("✔ connection is successful")
			break
		}

		fmt.Println(err)

		if !askRetry() {
			break
		}
	}

	return nil
}

func ExecuteSeeders(xapp *FirebackApp) error {
	if r := AskForSelect("Do you want to add the seed data, menu items, etc?", []string{"yes", "no"}); r == "yes" {
		db, dbErr := CreateDatabasePool()
		if db == nil && dbErr != nil {
			log.Fatalln("Database error on initialize connection:", dbErr)
		}

		ExecuteSeederImport(xapp)
	}

	return nil
}

func EnvRunMigration(xapp *FirebackApp) error {
	if r := AskForSelect("Do you want to run migration, adding tables or columns to database?", []string{"yes", "no"}); r == "yes" {
		db, dbErr := CreateDatabasePool()
		if db == nil && dbErr != nil {
			log.Fatalln("Database error on initialize connection:", dbErr)
		}

		ApplyMigration(xapp, 2)
	}

	return nil
}

func InitEnvironment(xapp *FirebackApp, envFileName string) error {

	datum := ""
	var err error

	// 1. Determine the project name
	datum, err = askEnvironmentName(config.Name)
	if err != nil {
		log.Fatalln("cannot determine the project name", err)
		return nil
	}
	config.Name = datum
	config.DebianIdentifier = datum
	config.MacIdentifier = datum
	config.WindowsIdentifier = datum

	if isProd := AskForSelect("Is this a production environment?", []string{"no", "yes"}); isProd == "yes" {
		if isProd == "yes" {
			config.Production = true
		}
	}

	if err := DataBaseConfigEnv(xapp); err != nil {
		return err
	}

	askSqlLogLevel(&config)

	// 4. Ask for the ports, it's important.
	po, _ := strconv.Atoi(AskPortName("Http port which fireback will be lifted:", fmt.Sprintf("%v", config.Port)))
	config.Port = int64(po)

	// microserivce has lighter migration

	EnvRunMigration(xapp)

	ExecuteSeeders(xapp)

	AskSSL(&config)

	for _, module := range xapp.Modules {
		if module.OnEnvInit != nil {
			module.OnEnvInit()
		}
	}

	config.Save(".env")

	return nil
}

func askRetry() bool {
	promptVariable := promptui.Select{
		Label: "Database connection failed, do you want retry again?",
		Items: []string{TRY_TO_SOLVE,
			FORCE_CONTINUE},
	}

	_, actionType, err := promptVariable.Run()
	if err != nil {
		fmt.Printf("Prompt failed %v\n", err)
		return false
	}

	if actionType == TRY_TO_SOLVE {
		return true
	}

	return false
}

var Cliversion cli.Command = cli.Command{

	Name:  "version",
	Usage: "Returns the version of the fireback: " + FIREBACK_VERSION,

	Action: func(c *cli.Context) error {
		fmt.Println(FIREBACK_VERSION)
		fmt.Println("Written with love by Ali Torabi")
		return nil
	},
}

var CLIAboutCommand cli.Command = cli.Command{

	Name:  "about",
	Usage: "About Fireback, the author of software, support and contact :)",

	Action: func(c *cli.Context) error {

		fmt.Println("Written by passion by Ali Torabi, distributed under torabi.io - reach me on 0048783538796 or https://github.com/torabian")

		fmt.Println(",.. .     /  .(  (                 .,/***/(%#(#####%&&%@@@@@@&&&&&&&&&&&&&&&&@@@")
		fmt.Println(",.. , (/ **,. , ,      .  ..  ,. ./(#((%###((((###(&&#@@@@@  ,&&&&&&&&&&&&&@@@@&")
		fmt.Println("*...   .   .                   ,*(#@&&#&@%&@&((###%#(#@@@@@%%%&&&&&&&&&&&&@@@&&&")
		fmt.Println("/*,,......,,.,,,,,,,,,,***#%%##%&&@@@@@&@@@@@@@&%%#(#&&@@@@&&&&&&&&&&&&@@@@&&&&&")
		fmt.Println("####(((((((((((((#/*,*//(#@@@&%&&&#%%%@@@@@@@@@@@&%#%%#&@&%%%%%%%%%%%%@@@&&&&&&@")
		fmt.Println("((((((((//(((((#(#*****/(#%%%##%&@&&@&%#&@@&@@@@&%&%%#%%#%%&@@@@@@@@@@@@&&%&@@@@")
		fmt.Println("((((((((((((#( *(#(((((##%&&#%#%%@@@&%@@&@@@@@%&&@@@#####%%##&@@@@@@@@&&&@@@@@@@")
		fmt.Println("#######%#(#(/*///(((#((&&%@@@@@&&&@@@@@&@@&@@@@@@@&&&%%%%&%&%%%%%%%&%%@@@@@@@@@@")
		fmt.Println("//,.,((((#/,&#/(((/((#%&&%#&&&&@@@@@&&&@@@@@@@&&&&&&%%&&&&%%%#%##%%%@@@@@@@@@&&&")
		fmt.Println("#((%%&#&%#%#(((/##/((##&@&&%&&&&@%@@@@@&@@@@@@@@&@&&&&&&&&&%%%%&%%@@@@@@@@&%%%&@")
		fmt.Println("#%##&&&&%&#&%#####(/(/(&&@@@@@@@&@@@@&@@@@@@@&@&&&&&&@@@&####%&&&%%(%&%%%%&@@@@@")
		fmt.Println("//(#%%##(##%%%/**(#///#%&@@@@@@@@@@@@@@@@@&&%%%%&&&&&&@%%&&%#(%%(/(((@@@@@@@@@@(")
		fmt.Println("####(//(**(/#%/, ,/**/(%%@@@@@@@@@@@@@@@%#((####%&&&(#&&&&&(///(/////%%%&&&&&&&/")
		fmt.Println("%#(#/(///((,(** ./(*/#/((##%%@@@&&&#(%@&%###%%%%%#(##%#&*##*,*##%%###//(%&&@@&%#")
		fmt.Println("(.*(./**(* ,/*,,,(/##((((######@@(###((#%%%%%%%%##(((((.     /%&@/       .*@&*..")
		fmt.Println("%%%##(@/****%/#*,/(((#######&&&(@&((((((#####%%%####((((((((((#&&(*.    #@@(#@%%")
		fmt.Println("//////(/*//*//#%##(#%&&%&&&&@@@@%##(((((((##((####((((#@@@@%##%%&(/#.,. ,.*,##(*")
		fmt.Println("				   ##(((((###((%%%%%(#/  ####%%%%##////(#(,.,/&%")
		fmt.Println("/#(#/*#(#*/(*((**((*,/((..((*  #&@@@%%#(%#%##(((##(#&@@%&%%#%%%%%##(///((((((###")
		fmt.Println("/( *//, #/(./.(*/../*/.,/@@@@@@@@@@@@#&%#(((((##((#%@%%@%%@&#&#/////**/(((((%%%%")
		fmt.Println("##(###########((/,.*@@@@@@@@@@@@@@@@@@#(%%###((##%&@@(%%&&&&&&&&@&,,,,,(****//((")
		fmt.Println("############%&%#///*,#@@@@@@@@@@@@@@@@#(#(((&###%@@%##.@&&%&&%@@@&&(///#/(#((##%")
		fmt.Println("((###%%%##(/&&&&(/(((/**,..,,%@@@@@@@@@(%/(/(((#@((#%%/&@%@@@&&@@&@&********,*/,")
		fmt.Println("/%#(/(((((###%%%/.  ......,,*(#((#%%&@@%#((//,/(%%%(%%,%&%&@%%&@%@&@****/(((((#&")
		fmt.Println("////(###(/(%,*#///,,,,**//#/...,/@@@@@@(/,..*(%#(#&%%#*%@&&@&%&%&@@&,***********")
		fmt.Println("/////(///(*/#((((///(###/,,.*(#/**@@@@@@((%#(((#%(%#%%(/@@@&#&@@&@@@,,,,,,,*****")
		fmt.Println("////////&%###%%%%##(((///(,...,,.,@@@@@@###(%###%(%#%&#/@@@@&&@@@@@@,,,,,,*,,***")
		fmt.Println("#&####%&&&#%%%##((((#%#/,,****../@@@@@@@&##%&%#&%###%&((@%&@@@@@@@@@/,,,,,,*,**,")
		fmt.Println("#&&@&%@&&&#(((((#####(/*/###**(@@@@@@@@@&&##%&%#%%#&%&(#@@@@@@@@@@@@(,,,,*,,*,**")
		fmt.Println("%&&@&@@&%%%%#(###((((/*/**/*%@@@@@@@@@@@@&&##%&#%%#&&@@@@&&@@@@@@@@@/..*,,,*,,*/")
		fmt.Println("@&&&&&&&&&&&#%%/**///******(@@@@@@@@@@@@@%%&%&@%%&%&@@@@@@@@&@@@@@@@@*,,,**,,*/*")
		fmt.Println("&&&&&&&&&&&&#&&%%#((//****#@@@@@@@@@@@@@@&%&%&@&&&&@@@@@@@&@@@@@@&@@#(**,*****/*")
		return nil
	},
}
