package fireback

import (
	"embed"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"os"
	"strings"
	"time"

	"github.com/gin-contrib/gzip"
	"github.com/gin-gonic/gin"
	statics "github.com/torabian/fireback/modules/fireback/static"
	"github.com/urfave/cli"
	"golang.org/x/exp/maps"
	"gopkg.in/yaml.v2"
	"gorm.io/gorm"
)

/*
FirebackApp is representing a fireback application, generally
a wrapper around modules, and some configuration for the project web server instance.
*/
type FirebackApp struct {

	// application title, or name. it will be used only on cli or other descriptive places
	Title string

	// Indication that this project is microservice. Some functionalities might be limited
	MicroService bool

	// prefixes the entire api generated by fireback into a prefix, for example /api
	// it's useful to move all api in a prefix
	ApiPrefix string

	// the language and locales of the project, it's an indication of error translations
	SupportedLanguages []string

	// modules created by fireback are injected here
	Modules []*ModuleProvider

	// Custom cli actions or command that you might want to add to the project
	CliActions func() []cli.Command

	InjectSearchEndpoint func(*gin.Engine, *FirebackApp)
	SetupWebServerHook   func(*gin.Engine, *FirebackApp)
	SearchProviders      []SearchProviderFn
	SeedersSync          func()
	MockSync             func()
	PublicFolders        []PublicFolderInfo
}

/*
Public folders are used when you want to make a embed folder available though the web
server publicly. Quite useful on serving static content, also you can prefix them
*/
type PublicFolderInfo struct {
	Fs     *embed.FS
	Folder string
	Prefix string
}

type SearchProviderFn = func(query QueryDSL, chanStream chan *ReactiveSearchResultDto)

/*

This function would read a web server modules, and recursively convert them into a
cli application

*/

func GetCliCommands(x *FirebackApp) []cli.Command {
	var commands []cli.Command

	// Helper function to recursively collect CLI commands
	var collectCommands func(modules []*ModuleProvider) []cli.Command
	collectCommands = func(modules []*ModuleProvider) []cli.Command {
		var collected []cli.Command
		for _, module := range modules {
			if len(module.Children) > 0 {
				if module.ActionsBundle != nil && module.ActionsBundle.CliAction != nil {
					// command := cli.Command{
					// 	Name:        "child2x",
					// 	Subcommands: collectCommands(module.Children),
					// }
					// fmt.Println(module.CliActionsBundle.Subcommands)
					module.ActionsBundle.CliAction.Subcommands = append(module.ActionsBundle.CliAction.Subcommands, collectCommands(module.Children)...)

				}
			}

			// Add CLI handlers from the module
			collected = append(collected, module.CliHandlers...)

			// Add commands from entity bundles
			for _, bundle := range module.EntityBundles {
				collected = append(collected, bundle.CliCommands...)
			}

			// Add actions from CliActionsBundle
			if module.ActionsBundle != nil && module.ActionsBundle.CliAction != nil {
				collected = append(collected, *module.ActionsBundle.CliAction)
			}

			// Recursively collect from children

		}
		return collected
	}

	// Collect commands from the root modules
	commands = collectCommands(x.Modules)

	// Add any CLI actions from x itself
	commands = append(commands, x.CliActions()...)

	return commands
}

// func GetCliCommands(x *FirebackApp) []cli.Command {
// 	commands := []cli.Command{}

// 	for _, module := range x.Modules {
// 		commands = append(commands, module.CliHandlers...)
// 		for _, bundle := range module.EntityBundles {
// 			commands = append(commands, bundle.CliCommands...)
// 		}

// 		if module.CliActionsBundle != nil {
// 			commands = append(commands, *module.CliActionsBundle)
// 		}

// 	}

// 	commands = append(commands, x.CliActions()...)

// 	return commands
// }

func GetReportCommands(x *FirebackApp) []cli.Command {
	commands := []cli.Command{}

	for _, item := range x.Modules {
		commands = append(commands, item.CliHandlers...)
	}

	commands = append(commands, x.CliActions()...)

	return commands
}

func ExecuteMockImport(x *FirebackApp) {

	for _, item := range x.Modules {
		if item.MockHandler != nil {
			item.MockHandler()
		}
	}

	for _, item := range x.Modules {
		for _, entity := range item.EntityBundles {
			if entity.MockProvider != nil {
				entity.MockProvider()
			}
		}
	}

	if x.SeedersSync != nil {
		x.SeedersSync()
	}

	if x.MockSync != nil {
		x.MockSync()
	}

}
func ExecuteSeederImport(x *FirebackApp) {

	for _, item := range x.Modules {
		if item.SeederHandler != nil {

			item.SeederHandler()
		}

	}

	if x.SeedersSync != nil {
		x.SeedersSync()
	}
}

func GetAppReportsString(items []Report) ([]string, error) {

	result := []string{}
	for _, entity := range items {
		result = append(result, entity.UniqueId+" >>> "+entity.Title+" ("+entity.Description+")")
	}
	return result, nil
}

func ExecuteMockWriter(x *FirebackApp) {

	for _, item := range x.Modules {
		if item.MockWriterHandler != nil {
			item.MockWriterHandler(x.SupportedLanguages)
		}

	}

}
func hasSuffix(path string, suffixes []string) bool {
	for _, suffix := range suffixes {
		if strings.HasSuffix(path, suffix) {
			return true
		}
	}
	return false
}

type HttpServerInstanceConfig struct {

	// Shows some charts and keeps track of active connections
	Monitor bool

	// Override the port
	Port int64

	SSL bool

	Slow bool
}

func SetupHttpServer(x *FirebackApp, cfg HttpServerInstanceConfig) *gin.Engine {

	if config.Production {
		gin.SetMode(gin.ReleaseMode)
	} else {
		if config.GinMode == "release" {
			gin.SetMode(gin.ReleaseMode)
		}

		if config.GinMode == "test" {
			gin.SetMode(gin.TestMode)
		}

		if config.GinMode == "gin" {
			gin.SetMode(gin.EnvGinMode)
		}

		if config.GinMode == "debug" {
			gin.SetMode(gin.DebugMode)
		}
	}

	r := gin.New()

	r.Use(GinMiddleware())
	r.Use(gzip.Gzip(gzip.DefaultCompression))

	r.Use(func(c *gin.Context) {
		cacheableSuffixes := []string{
			".js",
			".css",
			".svg",
			".png",
			".jpg",
			".woff",
			".woff2",
			".ttf",
		}

		if c.Request.Method == http.MethodGet && hasSuffix(c.Request.URL.Path, cacheableSuffixes) {
			c.Header("Cache-Control", "public, max-age=604800") // 1 year cache
		}

		c.Next()
	})

	r.Use(trackConnectionsMiddleware())

	if config.WithTaskServer {
		go taskServerLifter(x)
	}

	translations := map[string]map[string]string{}
	for _, item := range x.Modules {
		maps.Copy(translations, item.Translations)
	}
	maps.Copy(translations, BasicTranslations)

	if x.SetupWebServerHook != nil {
		x.SetupWebServerHook(r, x)
	}

	if x.InjectSearchEndpoint != nil {
		x.InjectSearchEndpoint(r, x)
	}

	r.GET("/stoplight.js", func(c *gin.Context) {
		file, err := statics.StaticFs.ReadFile("stoplight.js")
		if err != nil {
			c.String(http.StatusInternalServerError, "File not found")
			return
		}
		c.Data(http.StatusOK, "application/javascript", file)
	})

	r.GET("/stoplight.css", func(c *gin.Context) {
		file, err := statics.StaticFs.ReadFile("stoplight.css")
		if err != nil {
			c.String(http.StatusInternalServerError, "File not found")
			return
		}
		c.Data(http.StatusOK, "text/css", file)
	})

	{

		if config.DriveEnabled {
			prefix := "/xattach/"
			fileServer := http.StripPrefix(prefix, http.FileServer(http.Dir(config.Storage)))

			r.GET(prefix+"/*filepath", func(c *gin.Context) {
				if cfg.Slow {
					time.Sleep(5 * time.Second)
				}
				c.Header("Cache-Control", "public, max-age=31536000") // 1 year
				fileServer.ServeHTTP(c.Writer, c.Request)
			})
		}
	}

	r.GET("/docs", func(c *gin.Context) {

		c.Header("content-type", "text/html")
		c.String(200, `<!doctype html>
		<html lang="en">
		  <head>
			<meta charset="utf-8">
			<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
			<title>Fireback OpenAPI3 Docs</title>
			<script src="stoplight.js"></script>
			<link rel="stylesheet" href="stoplight.css">
		  </head>
		  <style>
			#mosaic-provider-react-aria-0-1 > div > div > div > div.sl-flex > div.sl-flex.sl-overflow-y-auto.sl-flex-col.sl-sticky.sl-inset-y-0.sl-pt-8.sl-bg-canvas-100.sl-border-r {
				height: 100vh;
				overflow-y: scroll;	
			}
		  </style>
		  <body>
		
			<elements-api
			  apiDescriptionUrl="/openapi.yml"
			  router="hash"
			  layout="sidebar"
			/>
		
		  </body>
		</html>
		`)
	})

	r.GET("/swagger", func(c *gin.Context) {

		c.Header("content-type", "text/html")
		c.String(200, `<!DOCTYPE html>
<html>
  <head>
    <title>Swagger UI</title>
    <link rel="stylesheet" href="https://unpkg.com/swagger-ui-dist/swagger-ui.css" />
  </head>
  <body>
    <div id="swagger-ui"></div>

    <script src="https://unpkg.com/swagger-ui-dist/swagger-ui-bundle.js"></script>
    <script>
      SwaggerUIBundle({
        url: "/openapi.yml",
        dom_id: '#swagger-ui'
      });
    </script>
  </body>
</html>

		`)
	})

	r.GET("/openapi.yml", func(c *gin.Context) {
		data, err := ConvertStructToOpenAPIYaml(x)

		if err != nil {
			c.AbortWithStatusJSON(400, err)
			return
		}

		c.Header("content-type", "application/yaml")

		// Marshal the OpenAPI document to YAML
		yamlData, err := yaml.Marshal(data)
		if err != nil {
			c.AbortWithStatusJSON(400, err)
			return
		}

		c.String(200, string(yamlData))
	})

	r.GET("/openapi.json", func(c *gin.Context) {
		data, err := ConvertStructToOpenAPIYaml(x)

		if err != nil {
			c.AbortWithStatusJSON(400, err)
			return
		}

		c.Header("content-type", "application/json")

		// Marshal the OpenAPI document to YAML
		jsonData, err := json.MarshalIndent(data, "", "  ")
		if err != nil {
			c.AbortWithStatusJSON(400, err)
			return
		}

		c.String(200, string(jsonData))
	})

	// r.Use(GinPostTranslateErrorMessages(translations))

	r.GET("/ping", func(c *gin.Context) {
		if config.Production {
			c.JSON(200, gin.H{
				"data": gin.H{
					"pong": "yes",
				},
			})
		} else {
			socketUsers, socketUserErr := GetEventBusInstance().ListUsers(SERVER_INSTANCE)
			c.JSON(200, gin.H{
				"data": gin.H{
					"pong":           "yes",
					"instanceId":     SERVER_INSTANCE,
					"socketUsers":    socketUsers,
					"socketUserErr":  socketUserErr,
					"socketSnapshot": SocketSessionPool,
				},
			})
		}
	})

	for _, item := range x.PublicFolders {
		EmbedFolderForGin(item.Fs, item.Folder, r, item.Prefix)
	}

	// Enable the mvc app from here, if it's needed. Work on your static website on
	// website.go instead of here, and only uncomment line below
	// ServeMVCWebsite(r)

	group := r.Group(x.ApiPrefix)
	FirebackAppToGin(x, group, "")

	return r
}

func FirebackAppToGin(x *FirebackApp, g *gin.RouterGroup, prefix string) {

	for _, item := range x.Modules {
		moduleNamespace := g.Group(item.Namespace)

		for _, actions := range item.Actions {
			CastRoutes2(actions, moduleNamespace)
		}

		if item.ActionsBundle != nil {
			CastRoutes2(item.ActionsBundle.Actions, moduleNamespace)
		}

		for _, bundle := range item.EntityBundles {
			CastRoutes2(bundle.Actions, moduleNamespace)
		}

		if len(item.Children) > 0 {
			// FirebackAppToGin(x, g, prefix+"/"+item.Name)
		}
	}
}

func SyncDatabase(x *FirebackApp, db *gorm.DB) {

	for _, item := range x.Modules {
		if item.EntityProvider != nil {
			item.EntityProvider(db)
		}

		for _, bundle := range item.EntityBundles {
			if err := dbref.AutoMigrate(bundle.AutoMigrationEntities...); err != nil {
				fmt.Println("There is an error on migrating:", bundle)
				log.Fatalln(err.Error())
			}

			for _, funx := range bundle.MigrationScripts {
				if funx.Exec != nil {
					fmt.Println(funx.Exec())
					os.Exit(0)
				}
			}
		}
	}

}

func RunApp(xapp *FirebackApp) {

	app := &cli.App{
		EnableBashCompletion: true,
		Name:                 xapp.Title,
		Flags:                cliGlobalFlags,
		Commands:             GetCliCommands(xapp),
	}

	err := app.Run(os.Args)
	if err != nil {
		log.Fatal(err)
	}
}
