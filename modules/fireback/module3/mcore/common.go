package mcore

import (
	"fmt"
	"reflect"
	"regexp"
	"strings"
	"text/template"
)

type H map[string]any

type ActionCodeGenerator = func(action *Module3Action, ctx MicroGenContext) (*CodeChunkCompiled, error)

type MicroGenContext struct {

	// Tags and features which will be enabled or disabled.
	Tags string

	// Output file or directory for generation context
	Output string
}

// Each generated file can have a set of tokens, such as classes, strings, enums, etc.
// since we cannot parse the generated code into AST (for language not go), we provide such details
// out of a generated code snipped to work on top of the other.
type GeneratedScriptToken struct {
	Name     string
	Value    string
	Children []GeneratedScriptToken
}

type CodeChunkCompiled struct {

	// The code which has been generated on the process.
	ActualScript []byte

	CodeChunkDependenies []CodeChunkDependency

	SuggestedFileName string

	SuggestedExtension string

	Tokens []GeneratedScriptToken
}

type CodeChunkDependency struct {
	// things to import, for example import {map, fork}
	Objects []string

	// Location or package name
	Location string
}

var CommonMap = template.FuncMap{
	"endsWithDto": func(s string) bool {
		return strings.HasSuffix(s, "Dto")
	},
	"last": func(x int, a interface{}) bool {
		return x == reflect.ValueOf(a).Len()-1
	},
	"goComment":         GoComment,
	"until":             GenerateRange,
	"typescriptComment": TypescriptComment,
	"join":              strings.Join,
	"b2s":               func(b []byte) string { return string(b) },
	"trim":              strings.TrimSpace,
	"upper":             ToUpper,
	"lower":             ToLower,
	"snakeUpper":        ToSnakeUpper,
	"escape":            EscapeDoubleQuotes,
	"safeIndex":         SafeIndex,
	"hasSuffix":         strings.HasSuffix,
	"regex":             RegexReplace,
	"arr":               func(els ...any) []any { return els },
	"inc": func(i int) int {
		return i + 1
	},
	"fx": func(fieldName string, depth int) string {
		return fieldName + "[index" + fmt.Sprintf("%v", depth) + "]."
	},
}

func GoComment(comment string) string {
	// Escape problematic characters and split into lines
	lines := strings.Split(comment, "\n")
	for i, line := range lines {
		lines[i] = "// " + strings.ReplaceAll(line, "*/", "* /") // Escape `*/`
	}
	return strings.Join(lines, "\n")
}

func GenerateRange(start, end int) []int {
	result := make([]int, end-start+1)
	for i := range result {
		result[i] = i + start
	}
	return result
}

func TypescriptComment(comment string) string {
	// Escape problematic characters and split into lines
	lines := strings.Split(comment, "\n")
	for i, line := range lines {
		lines[i] = strings.ReplaceAll(line, "*/", "* /") // Escape `*/`
	}
	return strings.Join(lines, "\n")
}

func EscapeDoubleQuotes(input string) string {
	return strings.ReplaceAll(input, `"`, `\"`)
}

func SafeIndex(slice []interface{}, index int) bool {
	if index < 0 || index >= len(slice) {
		return false
	}
	return true
}

func RegexReplace(input, pattern, replacement string) (string, error) {
	re, err := regexp.Compile(pattern)
	if err != nil {
		return "", err
	}
	return re.ReplaceAllString(input, replacement), nil
}

// Represent a file generated by codegen
type VirtualFile struct {
	Name         string
	MimeType     string
	Location     string
	ActualScript string
	Extension    string
}

type CompleteModuleGenerator = func(module *Module3, ctx MicroGenContext) ([]VirtualFile, error)

func ClaimRender(claims []JsFnArgument, ctx MicroGenContext) map[string]string {

	claimsRendered := make(map[string]string)
	for _, c := range claims {
		if strings.Contains(ctx.Tags, "typescript") {
			claimsRendered[c.Key] = c.CompileTs()
		} else {
			claimsRendered[c.Key] = c.CompileJs()
		}
	}

	return claimsRendered

}
