package m3js

import (
	"bytes"
	"fmt"
	"regexp"
	"strings"
	"text/template"
	"unicode"

	"github.com/torabian/fireback/modules/fireback/module3/mcore"
)

type renderedJsHeader struct {
	PropertyName string
	Type         string
	Description  string
	GetterFunc   string
	SetterFunc   string
}

func normalizeJsHeaderType(value string) (string, error) {
	switch value {
	case "string":
		return "string | null", nil
	case "int64", "float64":
		return "number | null", nil
	case "bool":
		return "boolean | null", nil
	}
	return "any", nil
}

func renderJsTsCommonHeadersInfo(action *mcore.Module3Action) ([]renderedJsHeader, error) {
	headers := []renderedJsHeader{}
	for _, header := range action.Headers {
		headerType, err := normalizeJsHeaderType(header.Type)
		if err != nil {
			return nil, err
		}
		funcName := mcore.ToUpper(headerNameNormalize(header.Name))
		headers = append(headers, renderedJsHeader{
			PropertyName: header.Name,
			Type:         headerType,
			Description:  header.Description,
			GetterFunc:   "get" + funcName,
			SetterFunc:   "set" + funcName,
		})
	}
	return headers, nil
}

var GEN_NEST_JS_COMPATIBILITY string = "nestjs-headers-decorator"
var GEN_TYPESCRIPT_COMPATIBILITY string = "typescript"

// generic renderer
func renderTsJsHeaderClass(ctx mcore.MicroGenContext, action *mcore.Module3Action, headers []renderedJsHeader, tmpl string) (*mcore.CodeChunkCompiled, error) {
	t := template.Must(template.New("headerclass").Funcs(mcore.CommonMap).Parse(tmpl))
	nestJsDecorator := strings.Contains(ctx.Tags, GEN_NEST_JS_COMPATIBILITY)
	className := fmt.Sprintf("%vHeaders", mcore.ToUpper(action.Name))

	var buf bytes.Buffer
	if err := t.Execute(&buf, mcore.H{
		"action":          action,
		"headers":         headers,
		"shouldExport":    true,
		"nestjsDecorator": nestJsDecorator,
		"className":       className,
	}); err != nil {
		return nil, err
	}

	res := &mcore.CodeChunkCompiled{
		ActualScript: buf.Bytes(),
		Tokens: []mcore.GeneratedScriptToken{
			{
				Name:  TOKEN_ROOT_CLASS,
				Value: className,
			},
		},
	}

	// If the code needs
	if nestJsDecorator {
		res.CodeChunkDependenies = append(res.CodeChunkDependenies, mcore.CodeChunkDependency{
			Objects: []string{
				"createParamDecorator", "ExecutionContext",
			},
			Location: "@nestjs/common",
		})
	}

	return res, nil
}

func JsActionHeaderClass(action *mcore.Module3Action, ctx mcore.MicroGenContext) (*mcore.CodeChunkCompiled, error) {
	const tmpl = `/**
 * {{.className}} class
 * Auto-generated from Module3Action
 */
{{ if .shouldExport -}} export {{- end }} class {{.className}} extends Headers {

  {{- range .headers }}
  /**
   * @returns { {{.Type}} }
   * @description {{ .Description }}
   */
  {{.GetterFunc}} () {
    return this.#getTyped('{{.PropertyName}}', '{{.Type}}');
  }
  /**
   * @param { {{.Type}} } value
   * @description {{ .Description }}
   */
  {{.SetterFunc}} (value) {
    this.set('{{.PropertyName}}', value);
    return this;
  }
  {{- end }}

  // the getters generated by us would be casting types before returning.
  // you still can use .get function to get the string value.
  #getTyped(key, type) {
    const val = this.get(key);
    if (val == null) return null;

    const t = type.toLowerCase();

    if (t.includes('number')) return Number(val);
    if (t.includes('bool')) return val === 'true';
    return val; // string or any other fallback
  }


  /**
   * @returns {Record<string, string>}
   * Converts Headers to plain object
   */
  toObject() {
    return Object.fromEntries(this.entries());
  }

  {{ if .nestjsDecorator }}
  /**
   * Nest.js decorator for controller headers. Instead of using @Headers() value: any, now you can use for example:
   * @example
   * @Get()
   * getHello(@{{.className}}.Nest() headers: {{.className}}): string {
   *  return JSON.stringify(headers.getContentType());
   * }
   */
  static Nest = createParamDecorator(
	(_data, ctx) => {
		// @ts-ignore
		const request = ctx.switchToHttp().getRequest();
		// @ts-ignore
		return new {{ .className }}(Object.entries(request.headers));
	},
  );

  {{ end }}
}
`
	result, err := renderJsTsCommonHeadersInfo(action)
	if err != nil {
		return nil, err
	}
	return renderTsJsHeaderClass(ctx, action, result, tmpl)
}

var camelCaseRe = regexp.MustCompile(`^[a-z][a-zA-Z0-9]*$`)

func headerNameNormalize(s string) string {
	if camelCaseRe.MatchString(s) {
		return s
	}
	re := regexp.MustCompile(`[^a-zA-Z0-9]+`)
	s = re.ReplaceAllString(s, " ")
	parts := strings.Fields(s)
	if len(parts) == 0 {
		return ""
	}
	result := strings.ToLower(parts[0])
	for _, p := range parts[1:] {
		if p == "" {
			continue
		}
		runes := []rune(p)
		runes[0] = unicode.ToUpper(runes[0])
		result += string(runes)
	}
	return result
}
