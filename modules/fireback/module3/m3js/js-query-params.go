// Contains code to generate type-safe query class for javascript, and typescript definitions
// Basically, it would extend the queries class from native javascript, and add the keys there.
// It's a direct drop in for UrlSearchParams, and works as expected with all libraries.

// When modifiying this file, test both js and ts definition are in sync.

package m3js

import (
	"bytes"
	"fmt"
	"strings"
	"text/template"

	"github.com/gin-gonic/gin"
	"github.com/torabian/fireback/modules/fireback/module3/mcore"
)

type renderedQsField struct {
	PropertyName string
	Type         string
	Description  string
	GetterFunc   string
	SetterFunc   string
}

func renderJsTsCommonQsInfo(action *mcore.Module3Action) ([]renderedQsField, error) {
	fields := []renderedQsField{}
	for _, query := range action.Query {
		queryType, err := normalizeJsHeaderType(query.Type)
		if err != nil {
			return nil, err
		}
		funcName := mcore.ToUpper(headerNameNormalize(query.Name))
		fields = append(fields, renderedQsField{
			PropertyName: query.Name,
			Type:         queryType,
			Description:  query.Description,
			GetterFunc:   "get" + funcName,
			SetterFunc:   "set" + funcName,
		})
	}

	return fields, nil
}

// generic renderer
func renderTsJsQsClass(ctx mcore.MicroGenContext, action *mcore.Module3Action, fields []renderedQsField, tmpl string) (*mcore.CodeChunkCompiled, error) {
	t := template.Must(template.New("qsclass").Funcs(mcore.CommonMap).Parse(tmpl))
	nestJsDecorator := strings.Contains(ctx.Tags, GEN_NEST_JS_COMPATIBILITY)
	className := fmt.Sprintf("%vQueryParams", mcore.ToUpper(action.Name))

	var buf bytes.Buffer
	if err := t.Execute(&buf, gin.H{
		"action":          action,
		"fields":          fields,
		"shouldExport":    true,
		"nestjsDecorator": nestJsDecorator,
		"className":       className,
	}); err != nil {
		return nil, err
	}

	res := &mcore.CodeChunkCompiled{
		ActualScript: buf.Bytes(),
	}

	res.CodeChunkDependenies = append(res.CodeChunkDependenies, mcore.CodeChunkDependency{
		Objects: []string{
			"URLSearchParamsX",
		},
		Location: INTERNAL_SDK_LOCATION,
	})

	res.Tokens = append(res.Tokens, mcore.GeneratedScriptToken{
		Name:  TOKEN_ROOT_CLASS,
		Value: className,
	})

	// If the code needs
	if nestJsDecorator {
		res.CodeChunkDependenies = append(res.CodeChunkDependenies, mcore.CodeChunkDependency{
			Objects: []string{
				"createParamDecorator", "ExecutionContext",
			},
			Location: "@nestjs/common",
		})
	}

	return res, nil
}

func JsActionQsClass(action *mcore.Module3Action, ctx mcore.MicroGenContext) (*mcore.CodeChunkCompiled, error) {
	const tmpl = `/**
 * {{.className}} class
 * Auto-generated from Module3Action
 */
{{ if .shouldExport -}} export {{- end }} class {{.className}} extends URLSearchParamsX {

  {{- range .fields }}
  /**
   * @returns { {{.Type}} }
   * @description {{ .Description }}
   */
  {{.GetterFunc}} () {
    return this.#getTyped('{{.PropertyName}}' , '{{.Type}}');
  }
  /**
   * @param { {{.Type}} } value
   * @description {{ .Description }}
   */
  {{.SetterFunc}} (value) {
    this.set('{{.PropertyName}}', value);
    return this;
  }
  {{- end }}


  // the getters generated by us would be casting types before returning.
  // you still can use .get function to get the string value.
  #getTyped(key, type) {
    const val = this.get(key);
    if (val == null) return null;

    const t = type.toLowerCase();

    if (t.includes('number')) return Number(val);
    if (t.includes('bool')) return val === 'true';
    return val; // string or any other fallback
  }


  {{ if .nestjsDecorator }}
  /**
   * Nest.js decorator for controller query. Instead of using @Query() value: any, now you can use for example:
   * @example
   * @Get()
   * getHello(@{{ .className }}.Nest() query: {{ .className }}): string {
   *  return JSON.stringify(query.getMyfield());
   * }
   */
  static Nest = createParamDecorator(
	(_data, ctx) => {
		// @ts-ignore
		const request = ctx.switchToHttp().getRequest();
		// @ts-ignore
		return new {{ .className }}(request.query);
	},
  );

  {{ end }}
}
`
	result, err := renderJsTsCommonQsInfo(action)
	if err != nil {
		return nil, err
	}
	return renderTsJsQsClass(ctx, action, result, tmpl)
}
