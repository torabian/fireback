package workspaces

/*
*	Generated by fireback 1.1.28
*	Written by Ali Torabi.
*	Checkout the repository for licenses and contribution: https://github.com/torabian/fireback
 */
import (
	"github.com/gin-gonic/gin"
	"github.com/urfave/cli"
)

// using shared actions here
type CheckClassicPassportResDtoOtpInfo struct {
	SuspendUntil int64 `json:"suspendUntil" yaml:"suspendUntil"        `
	ValidUntil   int64 `json:"validUntil" yaml:"validUntil"        `
	BlockedUntil int64 `json:"blockedUntil" yaml:"blockedUntil"        `
	// The amount of time left to unblock for next request
	SecondsToUnblock int64 `json:"secondsToUnblock" yaml:"secondsToUnblock"        `
}

var UserPassportsSecurityModel = &SecurityModel{
	ActionRequires: []PermissionInfo{},
}

type UserPassportsActionResDto struct {
	// The passport value, such as email address or phone number
	Value string `json:"value" yaml:"value"        `
	// Unique identifier of the passport to operate some action on top of it
	UniqueId string `json:"uniqueId" yaml:"uniqueId"        `
	// The type of the passport, such as email, phone number
	Type string `json:"type" yaml:"type"        `
	// Regardless of the secret, user needs to confirm his secret. There is an extra action to confirm user totp, could be used after signup or prior to login.
	TotpConfirmed bool `json:"totpConfirmed" yaml:"totpConfirmed"        `
}

func (x *UserPassportsActionResDto) RootObjectName() string {
	return "Workspaces"
}

type userPassportsActionImpSig func(
	q QueryDSL) ([]*UserPassportsActionResDto,
	*QueryResultMeta,
	*IError,
)

var UserPassportsActionImp userPassportsActionImpSig

func UserPassportsActionFn(
	q QueryDSL,
) (
	[]*UserPassportsActionResDto,
	*QueryResultMeta,
	*IError,
) {
	if UserPassportsActionImp == nil {
		return nil, nil, nil
	}
	return UserPassportsActionImp(q)
}

var UserPassportsActionCmd cli.Command = cli.Command{
	Name:  "user-passports",
	Usage: `Returns list of passports belongs to an specific user.`,
	Flags: CommonQueryFlags,
	Action: func(c *cli.Context) {
		query := CommonCliQueryDSLBuilderAuthorize(c, UserPassportsSecurityModel)
		result, _, err := UserPassportsActionFn(query)
		HandleActionInCli(c, result, err, map[string]map[string]string{})
	},
}
var ChangePasswordSecurityModel = &SecurityModel{
	ActionRequires: []PermissionInfo{},
}

type ChangePasswordActionReqDto struct {
	// New password meeting the security requirements.
	Password string `json:"password" yaml:"password"  validate:"required"        `
	// The passport uniqueId (not the email or phone number) which password would be applied to. Don't confuse with value.
	UniqueId string `json:"uniqueId" yaml:"uniqueId"  validate:"required"        `
}

func (x *ChangePasswordActionReqDto) RootObjectName() string {
	return "Workspaces"
}

var ChangePasswordCommonCliFlagsOptional = []cli.Flag{
	&cli.StringFlag{
		Name:     "password",
		Required: true,
		Usage:    `New password meeting the security requirements. (string)`,
	},
	&cli.StringFlag{
		Name:     "unique-id",
		Required: true,
		Usage:    `The passport uniqueId (not the email or phone number) which password would be applied to. Don't confuse with value. (string)`,
	},
}

func ChangePasswordActionReqValidator(dto *ChangePasswordActionReqDto) *IError {
	err := CommonStructValidatorPointer(dto, false)
	return err
}
func CastChangePasswordFromCli(c *cli.Context) *ChangePasswordActionReqDto {
	template := &ChangePasswordActionReqDto{}
	if c.IsSet("password") {
		template.Password = c.String("password")
	}
	if c.IsSet("unique-id") {
		template.UniqueId = c.String("unique-id")
	}
	return template
}

type changePasswordActionImpSig func(
	req *ChangePasswordActionReqDto,
	q QueryDSL) (string,
	*IError,
)

var ChangePasswordActionImp changePasswordActionImpSig

func ChangePasswordActionFn(
	req *ChangePasswordActionReqDto,
	q QueryDSL,
) (
	string,
	*IError,
) {
	if ChangePasswordActionImp == nil {
		return "", nil
	}
	return ChangePasswordActionImp(req, q)
}

var ChangePasswordActionCmd cli.Command = cli.Command{
	Name:  "change-password",
	Usage: `Change the password for a given passport of the user. User needs to be authenticated in order to be able to change the password for a given account.`,
	Flags: ChangePasswordCommonCliFlagsOptional,
	Action: func(c *cli.Context) {
		query := CommonCliQueryDSLBuilderAuthorize(c, ChangePasswordSecurityModel)
		dto := CastChangePasswordFromCli(c)
		result, err := ChangePasswordActionFn(dto, query)
		HandleActionInCli(c, result, err, map[string]map[string]string{})
	},
}
var ConfirmClassicPassportTotpSecurityModel *SecurityModel = nil

type ConfirmClassicPassportTotpActionReqDto struct {
	// Passport value, email or phone number which is already successfully registered.
	Value string `json:"value" yaml:"value"  validate:"required"        `
	// Password related to the passport. Totp is only available for passports with a password. Basically totp is protecting passport, not otp over email or sms.
	Password string `json:"password" yaml:"password"  validate:"required"        `
	// The totp code generated by authenticator such as google or microsft apps.
	TotpCode string `json:"totpCode" yaml:"totpCode"  validate:"required"        `
}

func (x *ConfirmClassicPassportTotpActionReqDto) RootObjectName() string {
	return "Workspaces"
}

var ConfirmClassicPassportTotpCommonCliFlagsOptional = []cli.Flag{
	&cli.StringFlag{
		Name:     "value",
		Required: true,
		Usage:    `Passport value, email or phone number which is already successfully registered. (string)`,
	},
	&cli.StringFlag{
		Name:     "password",
		Required: true,
		Usage:    `Password related to the passport. Totp is only available for passports with a password. Basically totp is protecting passport, not otp over email or sms. (string)`,
	},
	&cli.StringFlag{
		Name:     "totp-code",
		Required: true,
		Usage:    `The totp code generated by authenticator such as google or microsft apps. (string)`,
	},
}

func ConfirmClassicPassportTotpActionReqValidator(dto *ConfirmClassicPassportTotpActionReqDto) *IError {
	err := CommonStructValidatorPointer(dto, false)
	return err
}
func CastConfirmClassicPassportTotpFromCli(c *cli.Context) *ConfirmClassicPassportTotpActionReqDto {
	template := &ConfirmClassicPassportTotpActionReqDto{}
	if c.IsSet("value") {
		template.Value = c.String("value")
	}
	if c.IsSet("password") {
		template.Password = c.String("password")
	}
	if c.IsSet("totp-code") {
		template.TotpCode = c.String("totp-code")
	}
	return template
}

type ConfirmClassicPassportTotpActionResDto struct {
	Session   *UserSessionDto `json:"session" yaml:"session"    gorm:"foreignKey:SessionId;references:UniqueId"      `
	SessionId String          `json:"sessionId" yaml:"sessionId"`
}

func (x *ConfirmClassicPassportTotpActionResDto) RootObjectName() string {
	return "Workspaces"
}

type confirmClassicPassportTotpActionImpSig func(
	req *ConfirmClassicPassportTotpActionReqDto,
	q QueryDSL) (*ConfirmClassicPassportTotpActionResDto,
	*IError,
)

var ConfirmClassicPassportTotpActionImp confirmClassicPassportTotpActionImpSig

func ConfirmClassicPassportTotpActionFn(
	req *ConfirmClassicPassportTotpActionReqDto,
	q QueryDSL,
) (
	*ConfirmClassicPassportTotpActionResDto,
	*IError,
) {
	if ConfirmClassicPassportTotpActionImp == nil {
		return nil, nil
	}
	return ConfirmClassicPassportTotpActionImp(req, q)
}

var ConfirmClassicPassportTotpActionCmd cli.Command = cli.Command{
	Name:  "confirm-classic-passport-totp",
	Usage: `When user requires to setup the totp for an specifc passport, they can use this endpoint to confirm it.`,
	Flags: ConfirmClassicPassportTotpCommonCliFlagsOptional,
	Action: func(c *cli.Context) {
		query := CommonCliQueryDSLBuilderAuthorize(c, ConfirmClassicPassportTotpSecurityModel)
		dto := CastConfirmClassicPassportTotpFromCli(c)
		result, err := ConfirmClassicPassportTotpActionFn(dto, query)
		HandleActionInCli(c, result, err, map[string]map[string]string{})
	},
}
var CheckPassportMethodsSecurityModel *SecurityModel = nil

type CheckPassportMethodsActionResDto struct {
	Email               bool   `json:"email" yaml:"email"        `
	Phone               bool   `json:"phone" yaml:"phone"        `
	Google              bool   `json:"google" yaml:"google"        `
	EnabledRecaptcha2   bool   `json:"enabledRecaptcha2" yaml:"enabledRecaptcha2"        `
	Recaptcha2ClientKey string `json:"recaptcha2ClientKey" yaml:"recaptcha2ClientKey"        `
}

func (x *CheckPassportMethodsActionResDto) RootObjectName() string {
	return "Workspaces"
}

type checkPassportMethodsActionImpSig func(
	q QueryDSL) (*CheckPassportMethodsActionResDto,
	*IError,
)

var CheckPassportMethodsActionImp checkPassportMethodsActionImpSig

func CheckPassportMethodsActionFn(
	q QueryDSL,
) (
	*CheckPassportMethodsActionResDto,
	*IError,
) {
	if CheckPassportMethodsActionImp == nil {
		return nil, nil
	}
	return CheckPassportMethodsActionImp(q)
}

var CheckPassportMethodsActionCmd cli.Command = cli.Command{
	Name:  "check-passport-methods",
	Usage: `Publicly available information to create the authentication form, and show users how they can signin or signup to the system. Based on the PassportMethod entities, it will compute the available methods for the user, considering their region (IP for example)`,
	Action: func(c *cli.Context) {
		query := CommonCliQueryDSLBuilderAuthorize(c, CheckPassportMethodsSecurityModel)
		result, err := CheckPassportMethodsActionFn(query)
		HandleActionInCli(c, result, err, map[string]map[string]string{})
	},
}
var QueryWorkspaceTypesPubliclySecurityModel *SecurityModel = nil

type QueryWorkspaceTypesPubliclyActionResDto struct {
	Title       string `json:"title" yaml:"title"        `
	Description string `json:"description" yaml:"description"        `
	UniqueId    string `json:"uniqueId" yaml:"uniqueId"        `
	Slug        string `json:"slug" yaml:"slug"        `
}

func (x *QueryWorkspaceTypesPubliclyActionResDto) RootObjectName() string {
	return "Workspaces"
}

type queryWorkspaceTypesPubliclyActionImpSig func(
	q QueryDSL) ([]*QueryWorkspaceTypesPubliclyActionResDto,
	*QueryResultMeta,
	*IError,
)

var QueryWorkspaceTypesPubliclyActionImp queryWorkspaceTypesPubliclyActionImpSig

func QueryWorkspaceTypesPubliclyActionFn(
	q QueryDSL,
) (
	[]*QueryWorkspaceTypesPubliclyActionResDto,
	*QueryResultMeta,
	*IError,
) {
	if QueryWorkspaceTypesPubliclyActionImp == nil {
		return nil, nil, nil
	}
	return QueryWorkspaceTypesPubliclyActionImp(q)
}

var QueryWorkspaceTypesPubliclyActionCmd cli.Command = cli.Command{
	Name:  "public-types",
	Usage: `Returns the workspaces types available in the project publicly without authentication, and the value could be used upon signup to go different route.`,
	Flags: CommonQueryFlags,
	Action: func(c *cli.Context) {
		query := CommonCliQueryDSLBuilderAuthorize(c, QueryWorkspaceTypesPubliclySecurityModel)
		result, _, err := QueryWorkspaceTypesPubliclyActionFn(query)
		HandleActionInCli(c, result, err, map[string]map[string]string{})
	},
}
var ReactiveSearchSecurityModel *SecurityModel = nil
var ReactiveSearchActionImp = DefaultEmptyReactiveAction

// Reactive action does not have that
var ReactiveSearchActionCmd cli.Command = cli.Command{
	Name:  "reactive-search",
	Usage: `Reactive search is a general purpose search mechanism for different modules, and could be used in mobile apps or front-end to quickly search for a entity.`,
	Action: func(c *cli.Context) {
		query := CommonCliQueryDSLBuilderAuthorize(c, ReactiveSearchSecurityModel)
		CliReactivePipeHandler(query, ReactiveSearchActionImp)
	},
}
var ImportUserSecurityModel *SecurityModel = nil

type ImportUserActionReqDto struct {
	Path string `json:"path" yaml:"path"        `
}

func (x *ImportUserActionReqDto) RootObjectName() string {
	return "Workspaces"
}

var ImportUserCommonCliFlagsOptional = []cli.Flag{
	&cli.StringFlag{
		Name:     "path",
		Required: false,
		Usage:    `path (string)`,
	},
}

func ImportUserActionReqValidator(dto *ImportUserActionReqDto) *IError {
	err := CommonStructValidatorPointer(dto, false)
	return err
}
func CastImportUserFromCli(c *cli.Context) *ImportUserActionReqDto {
	template := &ImportUserActionReqDto{}
	if c.IsSet("path") {
		template.Path = c.String("path")
	}
	return template
}

type importUserActionImpSig func(
	req *ImportUserActionReqDto,
	q QueryDSL) (*OkayResponseDto,
	*IError,
)

var ImportUserActionImp importUserActionImpSig

func ImportUserActionFn(
	req *ImportUserActionReqDto,
	q QueryDSL,
) (
	*OkayResponseDto,
	*IError,
) {
	if ImportUserActionImp == nil {
		return nil, nil
	}
	return ImportUserActionImp(req, q)
}

var ImportUserActionCmd cli.Command = cli.Command{
	Name:  "import-user",
	Usage: `Imports users, and creates their passports, and all details`,
	Flags: ImportUserCommonCliFlagsOptional,
	Action: func(c *cli.Context) {
		query := CommonCliQueryDSLBuilderAuthorize(c, ImportUserSecurityModel)
		dto := CastImportUserFromCli(c)
		result, err := ImportUserActionFn(dto, query)
		HandleActionInCli(c, result, err, map[string]map[string]string{})
	},
}
var SendEmailSecurityModel *SecurityModel = nil

type SendEmailActionReqDto struct {
	ToAddress string `json:"toAddress" yaml:"toAddress"  validate:"required"        `
	Body      string `json:"body" yaml:"body"  validate:"required"        `
}

func (x *SendEmailActionReqDto) RootObjectName() string {
	return "Workspaces"
}

var SendEmailCommonCliFlagsOptional = []cli.Flag{
	&cli.StringFlag{
		Name:     "to-address",
		Required: true,
		Usage:    `toAddress (string)`,
	},
	&cli.StringFlag{
		Name:     "body",
		Required: true,
		Usage:    `body (string)`,
	},
}

func SendEmailActionReqValidator(dto *SendEmailActionReqDto) *IError {
	err := CommonStructValidatorPointer(dto, false)
	return err
}
func CastSendEmailFromCli(c *cli.Context) *SendEmailActionReqDto {
	template := &SendEmailActionReqDto{}
	if c.IsSet("to-address") {
		template.ToAddress = c.String("to-address")
	}
	if c.IsSet("body") {
		template.Body = c.String("body")
	}
	return template
}

type SendEmailActionResDto struct {
	QueueId string `json:"queueId" yaml:"queueId"        `
}

func (x *SendEmailActionResDto) RootObjectName() string {
	return "Workspaces"
}

type sendEmailActionImpSig func(
	req *SendEmailActionReqDto,
	q QueryDSL) (*SendEmailActionResDto,
	*IError,
)

var SendEmailActionImp sendEmailActionImpSig

func SendEmailActionFn(
	req *SendEmailActionReqDto,
	q QueryDSL,
) (
	*SendEmailActionResDto,
	*IError,
) {
	if SendEmailActionImp == nil {
		return nil, nil
	}
	return SendEmailActionImp(req, q)
}

var SendEmailActionCmd cli.Command = cli.Command{
	Name:  "email",
	Usage: `Send a email using default root notification configuration`,
	Flags: SendEmailCommonCliFlagsOptional,
	Action: func(c *cli.Context) {
		query := CommonCliQueryDSLBuilderAuthorize(c, SendEmailSecurityModel)
		dto := CastSendEmailFromCli(c)
		result, err := SendEmailActionFn(dto, query)
		HandleActionInCli(c, result, err, map[string]map[string]string{})
	},
}
var ListCapabilitiesSecurityModel *SecurityModel = nil

type listCapabilitiesActionImpSig func(
	q QueryDSL) ([]string,
	*IError,
)

var ListCapabilitiesActionImp listCapabilitiesActionImpSig

func ListCapabilitiesActionFn(
	q QueryDSL,
) (
	[]string,
	*IError,
) {
	if ListCapabilitiesActionImp == nil {
		return nil, nil
	}
	return ListCapabilitiesActionImp(q)
}

var ListCapabilitiesActionCmd cli.Command = cli.Command{
	Name:  "list",
	Usage: `Lists all of the capabilities in database as a array of string as root access`,
	Action: func(c *cli.Context) {
		query := CommonCliQueryDSLBuilderAuthorize(c, ListCapabilitiesSecurityModel)
		result, err := ListCapabilitiesActionFn(query)
		HandleActionInCli(c, result, err, map[string]map[string]string{})
	},
}
var SendEmailWithProviderSecurityModel *SecurityModel = nil

type SendEmailWithProviderActionReqDto struct {
	EmailProvider   *EmailProviderEntity `json:"emailProvider" yaml:"emailProvider"    gorm:"foreignKey:EmailProviderId;references:UniqueId"      `
	EmailProviderId String               `json:"emailProviderId" yaml:"emailProviderId"`
	ToAddress       string               `json:"toAddress" yaml:"toAddress"  validate:"required"        `
	Body            string               `json:"body" yaml:"body"  validate:"required"        `
}

func (x *SendEmailWithProviderActionReqDto) RootObjectName() string {
	return "Workspaces"
}

var SendEmailWithProviderCommonCliFlagsOptional = []cli.Flag{
	&cli.StringFlag{
		Name:     "email-provider-id",
		Required: false,
		Usage:    `emailProvider (one)`,
	},
	&cli.StringFlag{
		Name:     "to-address",
		Required: true,
		Usage:    `toAddress (string)`,
	},
	&cli.StringFlag{
		Name:     "body",
		Required: true,
		Usage:    `body (string)`,
	},
}

func SendEmailWithProviderActionReqValidator(dto *SendEmailWithProviderActionReqDto) *IError {
	err := CommonStructValidatorPointer(dto, false)
	return err
}
func CastSendEmailWithProviderFromCli(c *cli.Context) *SendEmailWithProviderActionReqDto {
	template := &SendEmailWithProviderActionReqDto{}
	if c.IsSet("email-provider-id") {
		template.EmailProviderId = NewStringAutoNull(c.String("email-provider-id"))
	}
	if c.IsSet("to-address") {
		template.ToAddress = c.String("to-address")
	}
	if c.IsSet("body") {
		template.Body = c.String("body")
	}
	return template
}

type SendEmailWithProviderActionResDto struct {
	QueueId string `json:"queueId" yaml:"queueId"        `
}

func (x *SendEmailWithProviderActionResDto) RootObjectName() string {
	return "Workspaces"
}

type sendEmailWithProviderActionImpSig func(
	req *SendEmailWithProviderActionReqDto,
	q QueryDSL) (*SendEmailWithProviderActionResDto,
	*IError,
)

var SendEmailWithProviderActionImp sendEmailWithProviderActionImpSig

func SendEmailWithProviderActionFn(
	req *SendEmailWithProviderActionReqDto,
	q QueryDSL,
) (
	*SendEmailWithProviderActionResDto,
	*IError,
) {
	if SendEmailWithProviderActionImp == nil {
		return nil, nil
	}
	return SendEmailWithProviderActionImp(req, q)
}

var SendEmailWithProviderActionCmd cli.Command = cli.Command{
	Name:  "emailp",
	Usage: `Send a text message using an specific gsm provider`,
	Flags: SendEmailWithProviderCommonCliFlagsOptional,
	Action: func(c *cli.Context) {
		query := CommonCliQueryDSLBuilderAuthorize(c, SendEmailWithProviderSecurityModel)
		dto := CastSendEmailWithProviderFromCli(c)
		result, err := SendEmailWithProviderActionFn(dto, query)
		HandleActionInCli(c, result, err, map[string]map[string]string{})
	},
}
var InviteToWorkspaceSecurityModel *SecurityModel = nil

type inviteToWorkspaceActionImpSig func(
	req *WorkspaceInviteEntity,
	q QueryDSL) (*WorkspaceInviteEntity,
	*IError,
)

var InviteToWorkspaceActionImp inviteToWorkspaceActionImpSig

func InviteToWorkspaceActionFn(
	req *WorkspaceInviteEntity,
	q QueryDSL,
) (
	*WorkspaceInviteEntity,
	*IError,
) {
	if InviteToWorkspaceActionImp == nil {
		return nil, nil
	}
	return InviteToWorkspaceActionImp(req, q)
}

var InviteToWorkspaceActionCmd cli.Command = cli.Command{
	Name:  "invite",
	Usage: `Invite a new person (either a user, with passport or without passport)`,
	Flags: WorkspaceInviteCommonCliFlagsOptional,
	Action: func(c *cli.Context) {
		query := CommonCliQueryDSLBuilderAuthorize(c, InviteToWorkspaceSecurityModel)
		dto := CastWorkspaceInviteFromCli(c)
		result, err := InviteToWorkspaceActionFn(dto, query)
		HandleActionInCli(c, result, err, map[string]map[string]string{})
	},
}
var GsmSendSmsSecurityModel *SecurityModel = nil

type GsmSendSmsActionReqDto struct {
	ToNumber string `json:"toNumber" yaml:"toNumber"  validate:"required"        `
	Body     string `json:"body" yaml:"body"  validate:"required"        `
}

func (x *GsmSendSmsActionReqDto) RootObjectName() string {
	return "Workspaces"
}

var GsmSendSmsCommonCliFlagsOptional = []cli.Flag{
	&cli.StringFlag{
		Name:     "to-number",
		Required: true,
		Usage:    `toNumber (string)`,
	},
	&cli.StringFlag{
		Name:     "body",
		Required: true,
		Usage:    `body (string)`,
	},
}

func GsmSendSmsActionReqValidator(dto *GsmSendSmsActionReqDto) *IError {
	err := CommonStructValidatorPointer(dto, false)
	return err
}
func CastGsmSendSmsFromCli(c *cli.Context) *GsmSendSmsActionReqDto {
	template := &GsmSendSmsActionReqDto{}
	if c.IsSet("to-number") {
		template.ToNumber = c.String("to-number")
	}
	if c.IsSet("body") {
		template.Body = c.String("body")
	}
	return template
}

type GsmSendSmsActionResDto struct {
	QueueId string `json:"queueId" yaml:"queueId"        `
}

func (x *GsmSendSmsActionResDto) RootObjectName() string {
	return "Workspaces"
}

type gsmSendSmsActionImpSig func(
	req *GsmSendSmsActionReqDto,
	q QueryDSL) (*GsmSendSmsActionResDto,
	*IError,
)

var GsmSendSmsActionImp gsmSendSmsActionImpSig

func GsmSendSmsActionFn(
	req *GsmSendSmsActionReqDto,
	q QueryDSL,
) (
	*GsmSendSmsActionResDto,
	*IError,
) {
	if GsmSendSmsActionImp == nil {
		return nil, nil
	}
	return GsmSendSmsActionImp(req, q)
}

var GsmSendSmsActionCmd cli.Command = cli.Command{
	Name:  "sms",
	Usage: `Send a text message using default root notification configuration`,
	Flags: GsmSendSmsCommonCliFlagsOptional,
	Action: func(c *cli.Context) {
		query := CommonCliQueryDSLBuilderAuthorize(c, GsmSendSmsSecurityModel)
		dto := CastGsmSendSmsFromCli(c)
		result, err := GsmSendSmsActionFn(dto, query)
		HandleActionInCli(c, result, err, map[string]map[string]string{})
	},
}
var GsmSendSmsWithProviderSecurityModel *SecurityModel = nil

type GsmSendSmsWithProviderActionReqDto struct {
	GsmProvider   *GsmProviderEntity `json:"gsmProvider" yaml:"gsmProvider"    gorm:"foreignKey:GsmProviderId;references:UniqueId"      `
	GsmProviderId String             `json:"gsmProviderId" yaml:"gsmProviderId"`
	ToNumber      string             `json:"toNumber" yaml:"toNumber"  validate:"required"        `
	Body          string             `json:"body" yaml:"body"  validate:"required"        `
}

func (x *GsmSendSmsWithProviderActionReqDto) RootObjectName() string {
	return "Workspaces"
}

var GsmSendSmsWithProviderCommonCliFlagsOptional = []cli.Flag{
	&cli.StringFlag{
		Name:     "gsm-provider-id",
		Required: false,
		Usage:    `gsmProvider (one)`,
	},
	&cli.StringFlag{
		Name:     "to-number",
		Required: true,
		Usage:    `toNumber (string)`,
	},
	&cli.StringFlag{
		Name:     "body",
		Required: true,
		Usage:    `body (string)`,
	},
}

func GsmSendSmsWithProviderActionReqValidator(dto *GsmSendSmsWithProviderActionReqDto) *IError {
	err := CommonStructValidatorPointer(dto, false)
	return err
}
func CastGsmSendSmsWithProviderFromCli(c *cli.Context) *GsmSendSmsWithProviderActionReqDto {
	template := &GsmSendSmsWithProviderActionReqDto{}
	if c.IsSet("gsm-provider-id") {
		template.GsmProviderId = NewStringAutoNull(c.String("gsm-provider-id"))
	}
	if c.IsSet("to-number") {
		template.ToNumber = c.String("to-number")
	}
	if c.IsSet("body") {
		template.Body = c.String("body")
	}
	return template
}

type GsmSendSmsWithProviderActionResDto struct {
	QueueId string `json:"queueId" yaml:"queueId"        `
}

func (x *GsmSendSmsWithProviderActionResDto) RootObjectName() string {
	return "Workspaces"
}

type gsmSendSmsWithProviderActionImpSig func(
	req *GsmSendSmsWithProviderActionReqDto,
	q QueryDSL) (*GsmSendSmsWithProviderActionResDto,
	*IError,
)

var GsmSendSmsWithProviderActionImp gsmSendSmsWithProviderActionImpSig

func GsmSendSmsWithProviderActionFn(
	req *GsmSendSmsWithProviderActionReqDto,
	q QueryDSL,
) (
	*GsmSendSmsWithProviderActionResDto,
	*IError,
) {
	if GsmSendSmsWithProviderActionImp == nil {
		return nil, nil
	}
	return GsmSendSmsWithProviderActionImp(req, q)
}

var GsmSendSmsWithProviderActionCmd cli.Command = cli.Command{
	Name:  "smsp",
	Usage: `Send a text message using an specific gsm provider`,
	Flags: GsmSendSmsWithProviderCommonCliFlagsOptional,
	Action: func(c *cli.Context) {
		query := CommonCliQueryDSLBuilderAuthorize(c, GsmSendSmsWithProviderSecurityModel)
		dto := CastGsmSendSmsWithProviderFromCli(c)
		result, err := GsmSendSmsWithProviderActionFn(dto, query)
		HandleActionInCli(c, result, err, map[string]map[string]string{})
	},
}
var ClassicSigninSecurityModel *SecurityModel = nil

type ClassicSigninActionReqDto struct {
	Value    string `json:"value" yaml:"value"  validate:"required"        `
	Password string `json:"password" yaml:"password"  validate:"required"        `
	// Accepts login with totp code. If enabled, first login would return a success response with next[enter-totp] value and ui can understand that user needs to be navigated into the screen other screen.
	TotpCode string `json:"totpCode" yaml:"totpCode"        `
	// Session secret when logging in to the application requires more steps to complete.
	SessionSecret string `json:"sessionSecret" yaml:"sessionSecret"        `
}

func (x *ClassicSigninActionReqDto) RootObjectName() string {
	return "Workspaces"
}

var ClassicSigninCommonCliFlagsOptional = []cli.Flag{
	&cli.StringFlag{
		Name:     "value",
		Required: true,
		Usage:    `value (string)`,
	},
	&cli.StringFlag{
		Name:     "password",
		Required: true,
		Usage:    `password (string)`,
	},
	&cli.StringFlag{
		Name:     "totp-code",
		Required: false,
		Usage:    `Accepts login with totp code. If enabled, first login would return a success response with next[enter-totp] value and ui can understand that user needs to be navigated into the screen other screen. (string)`,
	},
	&cli.StringFlag{
		Name:     "session-secret",
		Required: false,
		Usage:    `Session secret when logging in to the application requires more steps to complete. (string)`,
	},
}

func ClassicSigninActionReqValidator(dto *ClassicSigninActionReqDto) *IError {
	err := CommonStructValidatorPointer(dto, false)
	return err
}
func CastClassicSigninFromCli(c *cli.Context) *ClassicSigninActionReqDto {
	template := &ClassicSigninActionReqDto{}
	if c.IsSet("value") {
		template.Value = c.String("value")
	}
	if c.IsSet("password") {
		template.Password = c.String("password")
	}
	if c.IsSet("totp-code") {
		template.TotpCode = c.String("totp-code")
	}
	if c.IsSet("session-secret") {
		template.SessionSecret = c.String("session-secret")
	}
	return template
}

type ClassicSigninActionResDto struct {
	Session   *UserSessionDto `json:"session" yaml:"session"    gorm:"foreignKey:SessionId;references:UniqueId"      `
	SessionId String          `json:"sessionId" yaml:"sessionId"`
	// The next possible action which is suggested.
	Next []string `json:"next" yaml:"next"        `
	// In case the account doesn't have totp, but enforced by installation, this value will contain the link
	TotpUrl string `json:"totpUrl" yaml:"totpUrl"        `
	// Returns a secret session if the authentication requires more steps.
	SessionSecret string `json:"sessionSecret" yaml:"sessionSecret"        `
}

func (x *ClassicSigninActionResDto) RootObjectName() string {
	return "Workspaces"
}

type classicSigninActionImpSig func(
	req *ClassicSigninActionReqDto,
	q QueryDSL) (*ClassicSigninActionResDto,
	*IError,
)

var ClassicSigninActionImp classicSigninActionImpSig

func ClassicSigninActionFn(
	req *ClassicSigninActionReqDto,
	q QueryDSL,
) (
	*ClassicSigninActionResDto,
	*IError,
) {
	if ClassicSigninActionImp == nil {
		return nil, nil
	}
	return ClassicSigninActionImp(req, q)
}

var ClassicSigninActionCmd cli.Command = cli.Command{
	Name:  "in",
	Usage: `Signin publicly to and account using class passports (email, password)`,
	Flags: ClassicSigninCommonCliFlagsOptional,
	Action: func(c *cli.Context) {
		query := CommonCliQueryDSLBuilderAuthorize(c, ClassicSigninSecurityModel)
		dto := CastClassicSigninFromCli(c)
		result, err := ClassicSigninActionFn(dto, query)
		HandleActionInCli(c, result, err, map[string]map[string]string{})
	},
}
var ClassicSignupSecurityModel *SecurityModel = nil

type ClassicSignupActionReqDto struct {
	Value string `json:"value" yaml:"value"  validate:"required"        `
	// Required when the account creation requires recaptcha, or otp approval first. If such requirements are there, you first need to follow the otp apis, get the session secret and pass it here to complete the setup.
	SessionSecret   string `json:"sessionSecret" yaml:"sessionSecret"        `
	Type            string `json:"type" yaml:"type"  validate:"required"        `
	Password        string `json:"password" yaml:"password"  validate:"required"        `
	FirstName       string `json:"firstName" yaml:"firstName"  validate:"required"        `
	LastName        string `json:"lastName" yaml:"lastName"  validate:"required"        `
	InviteId        String `json:"inviteId" yaml:"inviteId"        `
	PublicJoinKeyId String `json:"publicJoinKeyId" yaml:"publicJoinKeyId"        `
	WorkspaceTypeId String `json:"workspaceTypeId" yaml:"workspaceTypeId"  validate:"required"        `
}

func (x *ClassicSignupActionReqDto) RootObjectName() string {
	return "Workspaces"
}

var ClassicSignupCommonCliFlagsOptional = []cli.Flag{
	&cli.StringFlag{
		Name:     "value",
		Required: true,
		Usage:    `value (string)`,
	},
	&cli.StringFlag{
		Name:     "session-secret",
		Required: false,
		Usage:    `Required when the account creation requires recaptcha, or otp approval first. If such requirements are there, you first need to follow the otp apis, get the session secret and pass it here to complete the setup. (string)`,
	},
	&cli.StringFlag{
		Name:     "type",
		Required: true,
		Usage:    `One of: 'phonenumber', 'email' (enum)`,
	},
	&cli.StringFlag{
		Name:     "password",
		Required: true,
		Usage:    `password (string)`,
	},
	&cli.StringFlag{
		Name:     "first-name",
		Required: true,
		Usage:    `firstName (string)`,
	},
	&cli.StringFlag{
		Name:     "last-name",
		Required: true,
		Usage:    `lastName (string)`,
	},
	&cli.StringFlag{
		Name:     "invite-id",
		Required: false,
		Usage:    `inviteId (string?)`,
	},
	&cli.StringFlag{
		Name:     "public-join-key-id",
		Required: false,
		Usage:    `publicJoinKeyId (string?)`,
	},
	&cli.StringFlag{
		Name:     "workspace-type-id",
		Required: true,
		Usage:    `workspaceTypeId (string?)`,
	},
}

func ClassicSignupActionReqValidator(dto *ClassicSignupActionReqDto) *IError {
	err := CommonStructValidatorPointer(dto, false)
	return err
}
func CastClassicSignupFromCli(c *cli.Context) *ClassicSignupActionReqDto {
	template := &ClassicSignupActionReqDto{}
	if c.IsSet("value") {
		template.Value = c.String("value")
	}
	if c.IsSet("session-secret") {
		template.SessionSecret = c.String("session-secret")
	}
	if c.IsSet("type") {
		template.Type = c.String("type")
	}
	if c.IsSet("password") {
		template.Password = c.String("password")
	}
	if c.IsSet("first-name") {
		template.FirstName = c.String("first-name")
	}
	if c.IsSet("last-name") {
		template.LastName = c.String("last-name")
	}
	if c.IsSet("invite-id") {
		template.InviteId = NewStringAutoNull(c.String("invite-id"))
	}
	if c.IsSet("public-join-key-id") {
		template.PublicJoinKeyId = NewStringAutoNull(c.String("public-join-key-id"))
	}
	if c.IsSet("workspace-type-id") {
		template.WorkspaceTypeId = NewStringAutoNull(c.String("workspace-type-id"))
	}
	return template
}

type ClassicSignupActionResDto struct {
	// Returns the user session in case that signup is completely successful.
	Session   *UserSessionDto `json:"session" yaml:"session"    gorm:"foreignKey:SessionId;references:UniqueId"      `
	SessionId String          `json:"sessionId" yaml:"sessionId"`
	// If time based otp is available, we add it response to make it easier for ui.
	TotpUrl string `json:"totpUrl" yaml:"totpUrl"        `
	// Returns true and session will be empty if, the totp is required by the installation. In such scenario, you need to forward user to setup totp screen.
	ContinueToTotp bool `json:"continueToTotp" yaml:"continueToTotp"        `
	// Determines if user must complete totp in order to continue based on workspace or installation
	ForcedTotp bool `json:"forcedTotp" yaml:"forcedTotp"        `
}

func (x *ClassicSignupActionResDto) RootObjectName() string {
	return "Workspaces"
}

type classicSignupActionImpSig func(
	req *ClassicSignupActionReqDto,
	q QueryDSL) (*ClassicSignupActionResDto,
	*IError,
)

var ClassicSignupActionImp classicSignupActionImpSig

func ClassicSignupActionFn(
	req *ClassicSignupActionReqDto,
	q QueryDSL,
) (
	*ClassicSignupActionResDto,
	*IError,
) {
	if ClassicSignupActionImp == nil {
		return nil, nil
	}
	return ClassicSignupActionImp(req, q)
}

var ClassicSignupActionCmd cli.Command = cli.Command{
	Name:  "up",
	Usage: `Signup a user into system via public access (aka website visitors) using either email or phone number.`,
	Flags: ClassicSignupCommonCliFlagsOptional,
	Action: func(c *cli.Context) {
		query := CommonCliQueryDSLBuilderAuthorize(c, ClassicSignupSecurityModel)
		dto := CastClassicSignupFromCli(c)
		result, err := ClassicSignupActionFn(dto, query)
		HandleActionInCli(c, result, err, map[string]map[string]string{})
	},
}
var CreateWorkspaceSecurityModel *SecurityModel = nil

type CreateWorkspaceActionReqDto struct {
	Name        string           `json:"name" yaml:"name"        `
	Workspace   *WorkspaceEntity `json:"workspace" yaml:"workspace"    gorm:"foreignKey:WorkspaceId;references:UniqueId"      `
	WorkspaceId String           `json:"workspaceId" yaml:"workspaceId"        `
}

func (x *CreateWorkspaceActionReqDto) RootObjectName() string {
	return "Workspaces"
}

var CreateWorkspaceCommonCliFlagsOptional = []cli.Flag{
	&cli.StringFlag{
		Name:     "name",
		Required: false,
		Usage:    `name (string)`,
	},
	&cli.StringFlag{
		Name:     "workspace-id",
		Required: false,
		Usage:    `workspace (one)`,
	},
	&cli.StringFlag{
		Name:     "workspace-id",
		Required: false,
		Usage:    `workspaceId (string?)`,
	},
}

func CreateWorkspaceActionReqValidator(dto *CreateWorkspaceActionReqDto) *IError {
	err := CommonStructValidatorPointer(dto, false)
	return err
}
func CastCreateWorkspaceFromCli(c *cli.Context) *CreateWorkspaceActionReqDto {
	template := &CreateWorkspaceActionReqDto{}
	if c.IsSet("name") {
		template.Name = c.String("name")
	}
	if c.IsSet("workspace-id") {
		template.WorkspaceId = NewStringAutoNull(c.String("workspace-id"))
	}
	if c.IsSet("workspace-id") {
		template.WorkspaceId = NewStringAutoNull(c.String("workspace-id"))
	}
	return template
}

type createWorkspaceActionImpSig func(
	req *CreateWorkspaceActionReqDto,
	q QueryDSL) (*WorkspaceEntity,
	*IError,
)

var CreateWorkspaceActionImp createWorkspaceActionImpSig

func CreateWorkspaceActionFn(
	req *CreateWorkspaceActionReqDto,
	q QueryDSL,
) (
	*WorkspaceEntity,
	*IError,
) {
	if CreateWorkspaceActionImp == nil {
		return nil, nil
	}
	return CreateWorkspaceActionImp(req, q)
}

var CreateWorkspaceActionCmd cli.Command = cli.Command{
	Name:  "create-workspace",
	Usage: ``,
	Flags: CreateWorkspaceCommonCliFlagsOptional,
	Action: func(c *cli.Context) {
		query := CommonCliQueryDSLBuilderAuthorize(c, CreateWorkspaceSecurityModel)
		dto := CastCreateWorkspaceFromCli(c)
		result, err := CreateWorkspaceActionFn(dto, query)
		HandleActionInCli(c, result, err, map[string]map[string]string{})
	},
}
var CheckClassicPassportSecurityModel *SecurityModel = nil

type CheckClassicPassportActionReqDto struct {
	Value string `json:"value" yaml:"value"  validate:"required"        `
	// This can be the value of recaptcha2, recaptch3, or generate security image or voice for verification. Will be used based on the configuration.
	SecurityToken string `json:"securityToken" yaml:"securityToken"        `
}

func (x *CheckClassicPassportActionReqDto) RootObjectName() string {
	return "Workspaces"
}

var CheckClassicPassportCommonCliFlagsOptional = []cli.Flag{
	&cli.StringFlag{
		Name:     "value",
		Required: true,
		Usage:    `value (string)`,
	},
	&cli.StringFlag{
		Name:     "security-token",
		Required: false,
		Usage:    `This can be the value of recaptcha2, recaptch3, or generate security image or voice for verification. Will be used based on the configuration. (string)`,
	},
}

func CheckClassicPassportActionReqValidator(dto *CheckClassicPassportActionReqDto) *IError {
	err := CommonStructValidatorPointer(dto, false)
	return err
}
func CastCheckClassicPassportFromCli(c *cli.Context) *CheckClassicPassportActionReqDto {
	template := &CheckClassicPassportActionReqDto{}
	if c.IsSet("value") {
		template.Value = c.String("value")
	}
	if c.IsSet("security-token") {
		template.SecurityToken = c.String("security-token")
	}
	return template
}

type CheckClassicPassportActionResDto struct {
	// The next possible action which is suggested.
	Next []string `json:"next" yaml:"next"        `
	// Extra information that can be useful actually when doing onboarding. Make sure sensetive information doesn't go out.
	Flags []string `json:"flags" yaml:"flags"        `
	// If the endpoint automatically triggers a send otp, then it would be holding that information, Also the otp information can become available.
	OtpInfo *CheckClassicPassportResDtoOtpInfo `json:"otpInfo" yaml:"otpInfo"    gorm:"foreignKey:LinkerId;references:UniqueId;constraint:OnDelete:CASCADE"      `
}

func (x *CheckClassicPassportActionResDto) RootObjectName() string {
	return "Workspaces"
}

type checkClassicPassportActionImpSig func(
	req *CheckClassicPassportActionReqDto,
	q QueryDSL) (*CheckClassicPassportActionResDto,
	*IError,
)

var CheckClassicPassportActionImp checkClassicPassportActionImpSig

func CheckClassicPassportActionFn(
	req *CheckClassicPassportActionReqDto,
	q QueryDSL,
) (
	*CheckClassicPassportActionResDto,
	*IError,
) {
	if CheckClassicPassportActionImp == nil {
		return nil, nil
	}
	return CheckClassicPassportActionImp(req, q)
}

var CheckClassicPassportActionCmd cli.Command = cli.Command{
	Name:  "ccp",
	Usage: `Checks if a classic passport (email, phone) exists or not, used in multi step authentication`,
	Flags: CheckClassicPassportCommonCliFlagsOptional,
	Action: func(c *cli.Context) {
		query := CommonCliQueryDSLBuilderAuthorize(c, CheckClassicPassportSecurityModel)
		dto := CastCheckClassicPassportFromCli(c)
		result, err := CheckClassicPassportActionFn(dto, query)
		HandleActionInCli(c, result, err, map[string]map[string]string{})
	},
}
var ClassicPassportOtpSecurityModel *SecurityModel = nil

type ClassicPassportOtpActionReqDto struct {
	Value string `json:"value" yaml:"value"  validate:"required"        `
	Otp   string `json:"otp" yaml:"otp"  validate:"required"        `
}

func (x *ClassicPassportOtpActionReqDto) RootObjectName() string {
	return "Workspaces"
}

var ClassicPassportOtpCommonCliFlagsOptional = []cli.Flag{
	&cli.StringFlag{
		Name:     "value",
		Required: true,
		Usage:    `value (string)`,
	},
	&cli.StringFlag{
		Name:     "otp",
		Required: true,
		Usage:    `otp (string)`,
	},
}

func ClassicPassportOtpActionReqValidator(dto *ClassicPassportOtpActionReqDto) *IError {
	err := CommonStructValidatorPointer(dto, false)
	return err
}
func CastClassicPassportOtpFromCli(c *cli.Context) *ClassicPassportOtpActionReqDto {
	template := &ClassicPassportOtpActionReqDto{}
	if c.IsSet("value") {
		template.Value = c.String("value")
	}
	if c.IsSet("otp") {
		template.Otp = c.String("otp")
	}
	return template
}

type ClassicPassportOtpActionResDto struct {
	Session   *UserSessionDto `json:"session" yaml:"session"    gorm:"foreignKey:SessionId;references:UniqueId"      `
	SessionId String          `json:"sessionId" yaml:"sessionId"`
	// If time based otp is available, we add it response to make it easier for ui.
	TotpUrl string `json:"totpUrl" yaml:"totpUrl"        `
	// The session secret will be used to call complete user registeration api.
	SessionSecret string `json:"sessionSecret" yaml:"sessionSecret"        `
	// If return true, means the OTP is correct and user needs to be created before continue the authentication processs.
	ContinueWithCreation bool `json:"continueWithCreation" yaml:"continueWithCreation"        `
}

func (x *ClassicPassportOtpActionResDto) RootObjectName() string {
	return "Workspaces"
}

type classicPassportOtpActionImpSig func(
	req *ClassicPassportOtpActionReqDto,
	q QueryDSL) (*ClassicPassportOtpActionResDto,
	*IError,
)

var ClassicPassportOtpActionImp classicPassportOtpActionImpSig

func ClassicPassportOtpActionFn(
	req *ClassicPassportOtpActionReqDto,
	q QueryDSL,
) (
	*ClassicPassportOtpActionResDto,
	*IError,
) {
	if ClassicPassportOtpActionImp == nil {
		return nil, nil
	}
	return ClassicPassportOtpActionImp(req, q)
}

var ClassicPassportOtpActionCmd cli.Command = cli.Command{
	Name:  "otp",
	Usage: `Authenticate the user publicly for classic methods using communication service, such as sms, call, or email. You need to call classicPassportRequestOtp beforehand to send a otp code, and then validate it with this API. Also checkClassicPassport action might already sent the otp, so make sure you don't send it twice.`,
	Flags: ClassicPassportOtpCommonCliFlagsOptional,
	Action: func(c *cli.Context) {
		query := CommonCliQueryDSLBuilderAuthorize(c, ClassicPassportOtpSecurityModel)
		dto := CastClassicPassportOtpFromCli(c)
		result, err := ClassicPassportOtpActionFn(dto, query)
		HandleActionInCli(c, result, err, map[string]map[string]string{})
	},
}
var ClassicPassportRequestOtpSecurityModel *SecurityModel = nil

type ClassicPassportRequestOtpActionReqDto struct {
	// Passport value (email, phone number) which would be recieving the otp code.
	Value string `json:"value" yaml:"value"  validate:"required"        `
}

func (x *ClassicPassportRequestOtpActionReqDto) RootObjectName() string {
	return "Workspaces"
}

var ClassicPassportRequestOtpCommonCliFlagsOptional = []cli.Flag{
	&cli.StringFlag{
		Name:     "value",
		Required: true,
		Usage:    `Passport value (email, phone number) which would be recieving the otp code. (string)`,
	},
}

func ClassicPassportRequestOtpActionReqValidator(dto *ClassicPassportRequestOtpActionReqDto) *IError {
	err := CommonStructValidatorPointer(dto, false)
	return err
}
func CastClassicPassportRequestOtpFromCli(c *cli.Context) *ClassicPassportRequestOtpActionReqDto {
	template := &ClassicPassportRequestOtpActionReqDto{}
	if c.IsSet("value") {
		template.Value = c.String("value")
	}
	return template
}

type ClassicPassportRequestOtpActionResDto struct {
	SuspendUntil int64 `json:"suspendUntil" yaml:"suspendUntil"        `
	ValidUntil   int64 `json:"validUntil" yaml:"validUntil"        `
	BlockedUntil int64 `json:"blockedUntil" yaml:"blockedUntil"        `
	// The amount of time left to unblock for next request
	SecondsToUnblock int64 `json:"secondsToUnblock" yaml:"secondsToUnblock"        `
}

func (x *ClassicPassportRequestOtpActionResDto) RootObjectName() string {
	return "Workspaces"
}

type classicPassportRequestOtpActionImpSig func(
	req *ClassicPassportRequestOtpActionReqDto,
	q QueryDSL) (*ClassicPassportRequestOtpActionResDto,
	*IError,
)

var ClassicPassportRequestOtpActionImp classicPassportRequestOtpActionImpSig

func ClassicPassportRequestOtpActionFn(
	req *ClassicPassportRequestOtpActionReqDto,
	q QueryDSL,
) (
	*ClassicPassportRequestOtpActionResDto,
	*IError,
) {
	if ClassicPassportRequestOtpActionImp == nil {
		return nil, nil
	}
	return ClassicPassportRequestOtpActionImp(req, q)
}

var ClassicPassportRequestOtpActionCmd cli.Command = cli.Command{
	Name:  "otp-request",
	Usage: `Triggers an otp request, and will send an sms or email to the passport. This endpoint is not used for login, but rather makes a request at initial step. Later you can call classicPassportOtp to get in.`,
	Flags: ClassicPassportRequestOtpCommonCliFlagsOptional,
	Action: func(c *cli.Context) {
		query := CommonCliQueryDSLBuilderAuthorize(c, ClassicPassportRequestOtpSecurityModel)
		dto := CastClassicPassportRequestOtpFromCli(c)
		result, err := ClassicPassportRequestOtpActionFn(dto, query)
		HandleActionInCli(c, result, err, map[string]map[string]string{})
	},
}

func WorkspacesCustomActions() []Module3Action {
	routes := []Module3Action{
		{
			Method:        "GET",
			Url:           "/user/passports",
			SecurityModel: UserPassportsSecurityModel,
			Name:          "userPassports",
			Description:   "Returns list of passports belongs to an specific user.",
			Handlers: []gin.HandlerFunc{
				func(c *gin.Context) {
					// QUERY - get
					HttpQueryEntity2(c, UserPassportsActionFn)
				},
			},
			Format:         "QUERY",
			Action:         UserPassportsActionFn,
			ResponseEntity: &UserPassportsActionResDto{},
			Out: &Module3ActionBody{
				Entity: "UserPassportsActionResDto",
			},
		},
		{
			Method:        "POST",
			Url:           "/passport/change-password",
			SecurityModel: ChangePasswordSecurityModel,
			Name:          "changePassword",
			Description:   "Change the password for a given passport of the user. User needs to be authenticated in order to be able to change the password for a given account.",
			Handlers: []gin.HandlerFunc{
				func(c *gin.Context) {
					// POST_ONE - post
					HttpPostEntity(c, ChangePasswordActionFn)
				},
			},
			Format:         "POST_ONE",
			Action:         ChangePasswordActionFn,
			ResponseEntity: string(""),
			Out: &Module3ActionBody{
				Entity: "",
			},
			RequestEntity: &ChangePasswordActionReqDto{},
			In: &Module3ActionBody{
				Entity: "ChangePasswordActionReqDto",
			},
		},
		{
			Method:        "POST",
			Url:           "/passport/totp/confirm",
			SecurityModel: ConfirmClassicPassportTotpSecurityModel,
			Name:          "confirmClassicPassportTotp",
			Description:   "When user requires to setup the totp for an specifc passport, they can use this endpoint to confirm it.",
			Handlers: []gin.HandlerFunc{
				func(c *gin.Context) {
					// POST_ONE - post
					HttpPostEntity(c, ConfirmClassicPassportTotpActionFn)
				},
			},
			Format:         "POST_ONE",
			Action:         ConfirmClassicPassportTotpActionFn,
			ResponseEntity: &ConfirmClassicPassportTotpActionResDto{},
			Out: &Module3ActionBody{
				Entity: "ConfirmClassicPassportTotpActionResDto",
			},
			RequestEntity: &ConfirmClassicPassportTotpActionReqDto{},
			In: &Module3ActionBody{
				Entity: "ConfirmClassicPassportTotpActionReqDto",
			},
		},
		{
			Method:        "GET",
			Url:           "/passports/available-methods",
			SecurityModel: CheckPassportMethodsSecurityModel,
			Name:          "checkPassportMethods",
			Description:   "Publicly available information to create the authentication form, and show users how they can signin or signup to the system. Based on the PassportMethod entities, it will compute the available methods for the user, considering their region (IP for example)",
			Handlers: []gin.HandlerFunc{
				func(c *gin.Context) {
					// GET_ONE - get
					HttpGetEntity(c, CheckPassportMethodsActionFn)
				},
			},
			Format:         "GET_ONE",
			Action:         CheckPassportMethodsActionFn,
			ResponseEntity: &CheckPassportMethodsActionResDto{},
			Out: &Module3ActionBody{
				Entity: "CheckPassportMethodsActionResDto",
			},
		},
		{
			Method:        "GET",
			Url:           "/workspace/public/types",
			SecurityModel: QueryWorkspaceTypesPubliclySecurityModel,
			Name:          "queryWorkspaceTypesPublicly",
			Description:   "Returns the workspaces types available in the project publicly without authentication, and the value could be used upon signup to go different route.",
			Handlers: []gin.HandlerFunc{
				func(c *gin.Context) {
					// QUERY - get
					HttpQueryEntity2(c, QueryWorkspaceTypesPubliclyActionFn)
				},
			},
			Format:         "QUERY",
			Action:         QueryWorkspaceTypesPubliclyActionFn,
			ResponseEntity: &QueryWorkspaceTypesPubliclyActionResDto{},
			Out: &Module3ActionBody{
				Entity: "QueryWorkspaceTypesPubliclyActionResDto",
			},
		},
		{
			Method:        "REACTIVE",
			Url:           "reactive-search",
			SecurityModel: ReactiveSearchSecurityModel,
			Name:          "reactiveSearch",
			Description:   "Reactive search is a general purpose search mechanism for different modules, and could be used in mobile apps or front-end to quickly search for a entity.",
			Handlers: []gin.HandlerFunc{
				ReactiveSocketHandler(ReactiveSearchActionImp),
			},
			Format:         "REACTIVE",
			ResponseEntity: string(""),
			Out: &Module3ActionBody{
				Entity: "",
			},
		},
		{
			Method:        "POST",
			Url:           "/user/import",
			SecurityModel: ImportUserSecurityModel,
			Name:          "importUser",
			Description:   "Imports users, and creates their passports, and all details",
			Handlers: []gin.HandlerFunc{
				func(c *gin.Context) {
					// POST_ONE - post
					HttpPostEntity(c, ImportUserActionFn)
				},
			},
			Format:         "POST_ONE",
			Action:         ImportUserActionFn,
			ResponseEntity: &OkayResponseDto{},
			Out: &Module3ActionBody{
				Entity: "OkayResponseDto",
			},
			RequestEntity: &ImportUserActionReqDto{},
			In: &Module3ActionBody{
				Entity: "ImportUserActionReqDto",
			},
		},
		{
			Method:        "POST",
			Url:           "/email/send",
			SecurityModel: SendEmailSecurityModel,
			Name:          "sendEmail",
			Description:   "Send a email using default root notification configuration",
			Handlers: []gin.HandlerFunc{
				func(c *gin.Context) {
					// POST_ONE - post
					HttpPostEntity(c, SendEmailActionFn)
				},
			},
			Format:         "POST_ONE",
			Action:         SendEmailActionFn,
			ResponseEntity: &SendEmailActionResDto{},
			Out: &Module3ActionBody{
				Entity: "SendEmailActionResDto",
			},
			RequestEntity: &SendEmailActionReqDto{},
			In: &Module3ActionBody{
				Entity: "SendEmailActionReqDto",
			},
		},
		{
			Method:        "",
			Url:           "/list-capabilities",
			SecurityModel: ListCapabilitiesSecurityModel,
			Name:          "listCapabilities",
			Description:   "Lists all of the capabilities in database as a array of string as root access",
			Handlers: []gin.HandlerFunc{
				func(c *gin.Context) {
					// POST_ONE -
				},
			},
			Format:         "POST_ONE",
			Action:         ListCapabilitiesActionFn,
			ResponseEntity: &OkayResponseDto{},
			Out: &Module3ActionBody{
				Entity: "OkayResponseDto",
			},
		},
		{
			Method:        "POST",
			Url:           "/emailProvider/send",
			SecurityModel: SendEmailWithProviderSecurityModel,
			Name:          "sendEmailWithProvider",
			Description:   "Send a text message using an specific gsm provider",
			Handlers: []gin.HandlerFunc{
				func(c *gin.Context) {
					// POST_ONE - post
					HttpPostEntity(c, SendEmailWithProviderActionFn)
				},
			},
			Format:         "POST_ONE",
			Action:         SendEmailWithProviderActionFn,
			ResponseEntity: &SendEmailWithProviderActionResDto{},
			Out: &Module3ActionBody{
				Entity: "SendEmailWithProviderActionResDto",
			},
			RequestEntity: &SendEmailWithProviderActionReqDto{},
			In: &Module3ActionBody{
				Entity: "SendEmailWithProviderActionReqDto",
			},
		},
		{
			Method:        "POST",
			Url:           "/workspace/invite",
			SecurityModel: InviteToWorkspaceSecurityModel,
			Name:          "inviteToWorkspace",
			Description:   "Invite a new person (either a user, with passport or without passport)",
			Handlers: []gin.HandlerFunc{
				func(c *gin.Context) {
					// POST_ONE - post
					HttpPostEntity(c, InviteToWorkspaceActionFn)
				},
			},
			Format:         "POST_ONE",
			Action:         InviteToWorkspaceActionFn,
			ResponseEntity: &WorkspaceInviteEntity{},
			Out: &Module3ActionBody{
				Entity: "WorkspaceInviteEntity",
			},
			RequestEntity: &WorkspaceInviteEntity{},
			In: &Module3ActionBody{
				Entity: "WorkspaceInviteEntity",
			},
		},
		{
			Method:        "POST",
			Url:           "/gsm/send/sms",
			SecurityModel: GsmSendSmsSecurityModel,
			Name:          "gsmSendSms",
			Description:   "Send a text message using default root notification configuration",
			Handlers: []gin.HandlerFunc{
				func(c *gin.Context) {
					// POST_ONE - post
					HttpPostEntity(c, GsmSendSmsActionFn)
				},
			},
			Format:         "POST_ONE",
			Action:         GsmSendSmsActionFn,
			ResponseEntity: &GsmSendSmsActionResDto{},
			Out: &Module3ActionBody{
				Entity: "GsmSendSmsActionResDto",
			},
			RequestEntity: &GsmSendSmsActionReqDto{},
			In: &Module3ActionBody{
				Entity: "GsmSendSmsActionReqDto",
			},
		},
		{
			Method:        "POST",
			Url:           "/gsmProvider/send/sms",
			SecurityModel: GsmSendSmsWithProviderSecurityModel,
			Name:          "gsmSendSmsWithProvider",
			Description:   "Send a text message using an specific gsm provider",
			Handlers: []gin.HandlerFunc{
				func(c *gin.Context) {
					// POST_ONE - post
					HttpPostEntity(c, GsmSendSmsWithProviderActionFn)
				},
			},
			Format:         "POST_ONE",
			Action:         GsmSendSmsWithProviderActionFn,
			ResponseEntity: &GsmSendSmsWithProviderActionResDto{},
			Out: &Module3ActionBody{
				Entity: "GsmSendSmsWithProviderActionResDto",
			},
			RequestEntity: &GsmSendSmsWithProviderActionReqDto{},
			In: &Module3ActionBody{
				Entity: "GsmSendSmsWithProviderActionReqDto",
			},
		},
		{
			Method:        "POST",
			Url:           "/passports/signin/classic",
			SecurityModel: ClassicSigninSecurityModel,
			Name:          "classicSignin",
			Description:   "Signin publicly to and account using class passports (email, password)",
			Handlers: []gin.HandlerFunc{
				func(c *gin.Context) {
					// POST_ONE - post
					HttpPostEntity(c, ClassicSigninActionFn)
				},
			},
			Format:         "POST_ONE",
			Action:         ClassicSigninActionFn,
			ResponseEntity: &ClassicSigninActionResDto{},
			Out: &Module3ActionBody{
				Entity: "ClassicSigninActionResDto",
			},
			RequestEntity: &ClassicSigninActionReqDto{},
			In: &Module3ActionBody{
				Entity: "ClassicSigninActionReqDto",
			},
		},
		{
			Method:        "POST",
			Url:           "/passports/signup/classic",
			SecurityModel: ClassicSignupSecurityModel,
			Name:          "classicSignup",
			Description:   "Signup a user into system via public access (aka website visitors) using either email or phone number.",
			Handlers: []gin.HandlerFunc{
				func(c *gin.Context) {
					// POST_ONE - post
					HttpPostEntity(c, ClassicSignupActionFn)
				},
			},
			Format:         "POST_ONE",
			Action:         ClassicSignupActionFn,
			ResponseEntity: &ClassicSignupActionResDto{},
			Out: &Module3ActionBody{
				Entity: "ClassicSignupActionResDto",
			},
			RequestEntity: &ClassicSignupActionReqDto{},
			In: &Module3ActionBody{
				Entity: "ClassicSignupActionReqDto",
			},
		},
		{
			Method:        "POST",
			Url:           "/workspaces/create",
			SecurityModel: CreateWorkspaceSecurityModel,
			Name:          "createWorkspace",
			Description:   "",
			Handlers: []gin.HandlerFunc{
				func(c *gin.Context) {
					// POST_ONE - post
					HttpPostEntity(c, CreateWorkspaceActionFn)
				},
			},
			Format:         "POST_ONE",
			Action:         CreateWorkspaceActionFn,
			ResponseEntity: &WorkspaceEntity{},
			Out: &Module3ActionBody{
				Entity: "WorkspaceEntity",
			},
			RequestEntity: &CreateWorkspaceActionReqDto{},
			In: &Module3ActionBody{
				Entity: "CreateWorkspaceActionReqDto",
			},
		},
		{
			Method:        "POST",
			Url:           "/workspace/passport/check",
			SecurityModel: CheckClassicPassportSecurityModel,
			Name:          "checkClassicPassport",
			Description:   "Checks if a classic passport (email, phone) exists or not, used in multi step authentication",
			Handlers: []gin.HandlerFunc{
				func(c *gin.Context) {
					// POST_ONE - post
					HttpPostEntity(c, CheckClassicPassportActionFn)
				},
			},
			Format:         "POST_ONE",
			Action:         CheckClassicPassportActionFn,
			ResponseEntity: &CheckClassicPassportActionResDto{},
			Out: &Module3ActionBody{
				Entity: "CheckClassicPassportActionResDto",
			},
			RequestEntity: &CheckClassicPassportActionReqDto{},
			In: &Module3ActionBody{
				Entity: "CheckClassicPassportActionReqDto",
			},
		},
		{
			Method:        "POST",
			Url:           "/workspace/passport/otp",
			SecurityModel: ClassicPassportOtpSecurityModel,
			Name:          "classicPassportOtp",
			Description:   "Authenticate the user publicly for classic methods using communication service, such as sms, call, or email. You need to call classicPassportRequestOtp beforehand to send a otp code, and then validate it with this API. Also checkClassicPassport action might already sent the otp, so make sure you don't send it twice.",
			Handlers: []gin.HandlerFunc{
				func(c *gin.Context) {
					// POST_ONE - post
					HttpPostEntity(c, ClassicPassportOtpActionFn)
				},
			},
			Format:         "POST_ONE",
			Action:         ClassicPassportOtpActionFn,
			ResponseEntity: &ClassicPassportOtpActionResDto{},
			Out: &Module3ActionBody{
				Entity: "ClassicPassportOtpActionResDto",
			},
			RequestEntity: &ClassicPassportOtpActionReqDto{},
			In: &Module3ActionBody{
				Entity: "ClassicPassportOtpActionReqDto",
			},
		},
		{
			Method:        "POST",
			Url:           "/workspace/passport/request-otp",
			SecurityModel: ClassicPassportRequestOtpSecurityModel,
			Name:          "classicPassportRequestOtp",
			Description:   "Triggers an otp request, and will send an sms or email to the passport. This endpoint is not used for login, but rather makes a request at initial step. Later you can call classicPassportOtp to get in.",
			Handlers: []gin.HandlerFunc{
				func(c *gin.Context) {
					// POST_ONE - post
					HttpPostEntity(c, ClassicPassportRequestOtpActionFn)
				},
			},
			Format:         "POST_ONE",
			Action:         ClassicPassportRequestOtpActionFn,
			ResponseEntity: &ClassicPassportRequestOtpActionResDto{},
			Out: &Module3ActionBody{
				Entity: "ClassicPassportRequestOtpActionResDto",
			},
			RequestEntity: &ClassicPassportRequestOtpActionReqDto{},
			In: &Module3ActionBody{
				Entity: "ClassicPassportRequestOtpActionReqDto",
			},
		},
	}
	return routes
}

var WorkspacesCustomActionsCli = []cli.Command{
	UserPassportsActionCmd,
	ChangePasswordActionCmd,
	ConfirmClassicPassportTotpActionCmd,
	CheckPassportMethodsActionCmd,
	QueryWorkspaceTypesPubliclyActionCmd,
	ReactiveSearchActionCmd,
	ImportUserActionCmd,
	SendEmailActionCmd,
	ListCapabilitiesActionCmd,
	SendEmailWithProviderActionCmd,
	InviteToWorkspaceActionCmd,
	GsmSendSmsActionCmd,
	GsmSendSmsWithProviderActionCmd,
	ClassicSigninActionCmd,
	ClassicSignupActionCmd,
	CreateWorkspaceActionCmd,
	CheckClassicPassportActionCmd,
	ClassicPassportOtpActionCmd,
	ClassicPassportRequestOtpActionCmd,
}

// Use the actions bundle for ease and provide it to the ModuleProvider
// and it would gather all actions in the module level
var WorkspacesCliActionsBundle = &CliActionsBundle{
	Name:  "workspaces",
	Usage: `This is the fireback core module, which includes everything. In fact you could say workspaces is fireback itself. Maybe in the future that would be changed`,
	// Here we will include entities actions, as well as module level actions
	Subcommands: cli.Commands{
		UserPassportsActionCmd,
		ChangePasswordActionCmd,
		ConfirmClassicPassportTotpActionCmd,
		CheckPassportMethodsActionCmd,
		QueryWorkspaceTypesPubliclyActionCmd,
		ReactiveSearchActionCmd,
		ImportUserActionCmd,
		SendEmailActionCmd,
		ListCapabilitiesActionCmd,
		SendEmailWithProviderActionCmd,
		InviteToWorkspaceActionCmd,
		GsmSendSmsActionCmd,
		GsmSendSmsWithProviderActionCmd,
		ClassicSigninActionCmd,
		ClassicSignupActionCmd,
		CreateWorkspaceActionCmd,
		CheckClassicPassportActionCmd,
		ClassicPassportOtpActionCmd,
		ClassicPassportRequestOtpActionCmd,
		TimezoneGroupCliFn(),
		FileCliFn(),
		TableViewSizingCliFn(),
		AppMenuCliFn(),
		BackupTableMetaCliFn(),
		NotificationConfigCliFn(),
		PassportMethodCliFn(),
		WorkspaceInviteCliFn(),
		PendingWorkspaceInviteCliFn(),
		PreferenceCliFn(),
		TokenCliFn(),
		PersonCliFn(),
		UserWorkspaceCliFn(),
		WorkspaceRoleCliFn(),
		UserCliFn(),
		UserProfileCliFn(),
		WorkspaceCliFn(),
		RoleCliFn(),
		CapabilityCliFn(),
		WorkspaceConfigCliFn(),
		GsmProviderCliFn(),
		WorkspaceTypeCliFn(),
		EmailProviderCliFn(),
		EmailSenderCliFn(),
		PhoneConfirmationCliFn(),
		PublicJoinKeyCliFn(),
		EmailConfirmationCliFn(),
		PassportCliFn(),
		RegionalContentCliFn(),
		PublicAuthenticationCliFn(),
	},
}

func GetWorkspacesActionsBundle() *ModuleActionsBundle {
	return &ModuleActionsBundle{
		Actions:   WorkspacesCustomActions(),
		CliAction: WorkspacesCliActionsBundle,
	}
}
func GetWorkspacesActionsCli() []cli.Command {
	return WorkspacesCustomActionsCli
}
