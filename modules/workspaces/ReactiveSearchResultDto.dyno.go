package workspaces

/*
*	Generated by fireback 1.1.27
*	Written by Ali Torabi.
*	Checkout the repository for licenses and contribution: https://github.com/torabian/fireback
 */
import (
	"encoding/json"
	"fmt"
	"github.com/urfave/cli"
	"strings"
)

func CastReactiveSearchResultFromCli(c *cli.Context) *ReactiveSearchResultDto {
	template := &ReactiveSearchResultDto{}
	if c.IsSet("unique-id") {
		value := c.String("unique-id")
		template.UniqueId = &value
	}
	if c.IsSet("phrase") {
		value := c.String("phrase")
		template.Phrase = &value
	}
	if c.IsSet("icon") {
		value := c.String("icon")
		template.Icon = &value
	}
	if c.IsSet("description") {
		value := c.String("description")
		template.Description = &value
	}
	if c.IsSet("group") {
		value := c.String("group")
		template.Group = &value
	}
	if c.IsSet("ui-location") {
		value := c.String("ui-location")
		template.UiLocation = &value
	}
	if c.IsSet("action-fn") {
		value := c.String("action-fn")
		template.ActionFn = &value
	}
	return template
}

var ReactiveSearchResultDtoCommonCliFlagsOptional = []cli.Flag{
	&cli.StringFlag{
		Name:     "wid",
		Required: false,
		Usage:    "Provide workspace id, if you want to change the data workspace",
	},
	&cli.StringFlag{
		Name:     "uid",
		Required: false,
		Usage:    "Unique Id - external unique hash to query entity",
	},
	&cli.StringFlag{
		Name:     "pid",
		Required: false,
		Usage:    " Parent record id of the same type",
	},
	&cli.StringFlag{
		Name:     "unique-id",
		Required: false,
		Usage:    `uniqueId`,
	},
	&cli.StringFlag{
		Name:     "phrase",
		Required: false,
		Usage:    `phrase`,
	},
	&cli.StringFlag{
		Name:     "icon",
		Required: false,
		Usage:    `icon`,
	},
	&cli.StringFlag{
		Name:     "description",
		Required: false,
		Usage:    `description`,
	},
	&cli.StringFlag{
		Name:     "group",
		Required: false,
		Usage:    `group`,
	},
	&cli.StringFlag{
		Name:     "ui-location",
		Required: false,
		Usage:    `uiLocation`,
	},
	&cli.StringFlag{
		Name:     "action-fn",
		Required: false,
		Usage:    `actionFn`,
	},
}

type ReactiveSearchResultDto struct {
	UniqueId    *string `json:"uniqueId" yaml:"uniqueId"        `
	Phrase      *string `json:"phrase" yaml:"phrase"        `
	Icon        *string `json:"icon" yaml:"icon"        `
	Description *string `json:"description" yaml:"description"        `
	Group       *string `json:"group" yaml:"group"        `
	UiLocation  *string `json:"uiLocation" yaml:"uiLocation"        `
	ActionFn    *string `json:"actionFn" yaml:"actionFn"        `
}
type ReactiveSearchResultDtoList struct {
	Items []*ReactiveSearchResultDto
}

func NewReactiveSearchResultDtoList(items []*ReactiveSearchResultDto) *ReactiveSearchResultDtoList {
	return &ReactiveSearchResultDtoList{
		Items: items,
	}
}
func (x *ReactiveSearchResultDto) Json() string {
	if x != nil {
		str, _ := json.MarshalIndent(x, "", "  ")
		return (string(str))
	}
	// Intentional trim (so strings lib is always imported)
	return strings.TrimSpace("")
}
func (x *ReactiveSearchResultDto) JsonPrint() {
	fmt.Println(x.Json())
}

// This is an experimental way to create new dtos, with exluding the pointers as helper.
func NewReactiveSearchResultDto(
	UniqueId string,
	Phrase string,
	Icon string,
	Description string,
	Group string,
	UiLocation string,
	ActionFn string,
) ReactiveSearchResultDto {
	return ReactiveSearchResultDto{
		UniqueId:    &UniqueId,
		Phrase:      &Phrase,
		Icon:        &Icon,
		Description: &Description,
		Group:       &Group,
		UiLocation:  &UiLocation,
		ActionFn:    &ActionFn,
	}
}
