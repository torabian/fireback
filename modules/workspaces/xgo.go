package workspaces

import (
	"embed"
	"fmt"
	"log"
	"net/http"
	"os"
	"strings"

	"github.com/gin-contrib/gzip"
	"github.com/gin-gonic/gin"
	statics "github.com/torabian/fireback/modules/workspaces/static"
	"github.com/urfave/cli"
	"golang.org/x/exp/maps"
	"gorm.io/gorm"
)

/*
XWebServer is representing a fireback application, generally
a wrapper around modules, and some configuration for the project web server instance.
*/
type XWebServer struct {

	// application title, or name. it will be used only on cli or other descriptive places
	Title string

	// prefixes the entire api generated by fireback into a prefix, for example /api
	// it's useful to move all api in a prefix
	ApiPrefix string

	// task server is internal fireback queue system, which can manage cronjobs, tasks, consumers
	// if you are using external task system you might not need it.
	LiftTaskServer bool

	// the language and locales of the project, it's an indication of error translations
	SupportedLanguages []string

	// modules created by fireback are injected here
	Modules []*ModuleProvider

	// Custom cli actions or command that you might want to add to the project
	CliActions func() []cli.Command

	// runs TUS resumable upload server on a separate port
	RunTus             func()
	RunSocket          func(*gin.Engine)
	RunSearch          func(*gin.Engine, *XWebServer)
	SetupWebServerHook func(*gin.Engine, *XWebServer)
	SearchProviders    []SearchProviderFn
	SeedersSync        func()
	MockSync           func()
	PublicFolders      []PublicFolderInfo
}

/*
Public folders are used when you want to make a embed folder available though the web
server publicly. Quite useful on serving static content, also you can prefix them
*/
type PublicFolderInfo struct {
	Fs     *embed.FS
	Folder string
	Prefix string
}

type SearchProviderFn = func(query QueryDSL, chanStream chan *ReactiveSearchResultDto)

/*

This function would read a web server modules, and recursively convert them into a
cli application

*/

func GetCliCommands(x *XWebServer) []cli.Command {
	var commands []cli.Command

	// Helper function to recursively collect CLI commands
	var collectCommands func(modules []*ModuleProvider) []cli.Command
	collectCommands = func(modules []*ModuleProvider) []cli.Command {
		var collected []cli.Command
		for _, module := range modules {
			if len(module.Children) > 0 {
				if module.ActionsBundle != nil && module.ActionsBundle.CliAction != nil {
					// command := cli.Command{
					// 	Name:        "child2x",
					// 	Subcommands: collectCommands(module.Children),
					// }
					// fmt.Println(module.CliActionsBundle.Subcommands)
					module.ActionsBundle.CliAction.Subcommands = append(module.ActionsBundle.CliAction.Subcommands, collectCommands(module.Children)...)

				}
			}

			// Add CLI handlers from the module
			collected = append(collected, module.CliHandlers...)

			// Add commands from entity bundles
			for _, bundle := range module.EntityBundles {
				collected = append(collected, bundle.CliCommands...)
			}

			// Add actions from CliActionsBundle
			if module.ActionsBundle != nil && module.ActionsBundle.CliAction != nil {
				collected = append(collected, *module.ActionsBundle.CliAction)
			}

			// Recursively collect from children

		}
		return collected
	}

	// Collect commands from the root modules
	commands = collectCommands(x.Modules)

	// Add any CLI actions from x itself
	commands = append(commands, x.CliActions()...)

	return commands
}

// func GetCliCommands(x *XWebServer) []cli.Command {
// 	commands := []cli.Command{}

// 	for _, module := range x.Modules {
// 		commands = append(commands, module.CliHandlers...)
// 		for _, bundle := range module.EntityBundles {
// 			commands = append(commands, bundle.CliCommands...)
// 		}

// 		if module.CliActionsBundle != nil {
// 			commands = append(commands, *module.CliActionsBundle)
// 		}

// 	}

// 	commands = append(commands, x.CliActions()...)

// 	return commands
// }

func GetReportCommands(x *XWebServer) []cli.Command {
	commands := []cli.Command{}

	for _, item := range x.Modules {
		commands = append(commands, item.CliHandlers...)
	}

	commands = append(commands, x.CliActions()...)

	return commands
}

func ExecuteMockImport(x *XWebServer) {

	for _, item := range x.Modules {
		if item.MockHandler != nil {
			item.MockHandler()
		}
	}

	for _, item := range x.Modules {
		for _, entity := range item.EntityBundles {
			if entity.MockProvider != nil {
				entity.MockProvider()
			}
		}
	}

	if x.SeedersSync != nil {
		x.SeedersSync()
	}

	if x.MockSync != nil {
		x.MockSync()
	}

}
func ExecuteSeederImport(x *XWebServer) {

	for _, item := range x.Modules {
		if item.SeederHandler != nil {

			item.SeederHandler()
		}

	}

	if x.SeedersSync != nil {
		x.SeedersSync()
	}
}

func GetAppReportsString(items []Report) ([]string, error) {

	result := []string{}
	for _, entity := range items {
		result = append(result, entity.UniqueId+" >>> "+entity.Title+" ("+entity.Description+")")
	}
	return result, nil
}

func ExecuteMockWriter(x *XWebServer) {

	for _, item := range x.Modules {
		if item.MockWriterHandler != nil {
			item.MockWriterHandler(x.SupportedLanguages)
		}

	}

}

func SetupHttpServer(x *XWebServer) *gin.Engine {

	r := gin.New()

	r.Use(gzip.Gzip(gzip.DefaultCompression))

	r.Use(func(c *gin.Context) {
		if c.Request.Method == "GET" && (strings.HasSuffix(c.Request.URL.Path, ".svg")) {
			c.Header("Cache-Control", "public, max-age=31536000") // 1 year
		}
		c.Next()
	})

	translations := map[string]map[string]string{}
	for _, item := range x.Modules {
		maps.Copy(translations, item.Translations)
	}
	maps.Copy(translations, BasicTranslations)

	if x.RunTus != nil {
		go x.RunTus()
	}

	if x.LiftTaskServer {
		go taskServerLifter(x)
	}

	if x.RunSocket != nil {
		go x.RunSocket(r)
	}
	if x.RunSearch != nil {
		go x.RunSearch(r, x)
	}
	if x.SetupWebServerHook != nil {
		x.SetupWebServerHook(r, x)
	}

	r.GET("/stoplight.js", func(c *gin.Context) {
		file, err := statics.StaticFs.ReadFile("stoplight.js")
		if err != nil {
			c.String(http.StatusInternalServerError, "File not found")
			return
		}
		c.Data(http.StatusOK, "application/javascript", file)
	})

	r.GET("/stoplight.css", func(c *gin.Context) {
		file, err := statics.StaticFs.ReadFile("stoplight.css")
		if err != nil {
			c.String(http.StatusInternalServerError, "File not found")
			return
		}
		c.Data(http.StatusOK, "text/css", file)
	})

	{

		if config.DriveEnabled {
			prefix := "/xattach/"
			fileServer := http.StripPrefix(prefix, http.FileServer(http.Dir(config.Storage)))

			r.GET(prefix+"/*filepath", func(c *gin.Context) {
				c.Header("Cache-Control", "public, max-age=31536000") // 1 year
				fileServer.ServeHTTP(c.Writer, c.Request)
			})
		}
	}

	r.GET("/docs", func(c *gin.Context) {

		c.Header("content-type", "text/html")
		c.String(200, `<!doctype html>
		<html lang="en">
		  <head>
			<meta charset="utf-8">
			<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
			<title>Fireback OpenAPI3 Docs</title>
			<script src="stoplight.js"></script>
			<link rel="stylesheet" href="stoplight.css">
		  </head>
		  <style>
			#mosaic-provider-react-aria-0-1 > div > div > div > div.sl-flex > div.sl-flex.sl-overflow-y-auto.sl-flex-col.sl-sticky.sl-inset-y-0.sl-pt-8.sl-bg-canvas-100.sl-border-r {
				height: 100vh;
				overflow-y: scroll;	
			}
		  </style>
		  <body>
		
			<elements-api
			  apiDescriptionUrl="/openapi.yml"
			  router="hash"
			  layout="sidebar"
			/>
		
		  </body>
		</html>
		`)
	})

	r.GET("/openapi.yml", func(c *gin.Context) {
		data, _ := ConvertStructToOpenAPIYaml(x)
		c.Header("content-type", "application/json")
		c.String(200, data)
	})

	// r.Use(GinPostTranslateErrorMessages(translations))
	r.Use(GinMiddleware())

	r.GET("/ping", func(c *gin.Context) {
		c.JSON(200, gin.H{
			"data": gin.H{
				"pong": "yes",
			},
		})
	})

	for _, item := range x.PublicFolders {
		EmbedFolderForGin(item.Fs, item.Folder, r, item.Prefix)
	}

	// Enable the mvc app from here, if it's needed. Work on your static website on
	// website.go instead of here, and only uncomment line below
	// ServeMVCWebsite(r)

	group := r.Group(x.ApiPrefix)
	XWebServerToGin(x, group, "")

	return r
}

func XWebServerToGin(x *XWebServer, g *gin.RouterGroup, prefix string) {

	for _, item := range x.Modules {
		moduleNamespace := g.Group(item.Namespace)

		for _, actions := range item.Actions {
			CastRoutes2(actions, moduleNamespace)
		}

		if item.ActionsBundle != nil {
			CastRoutes2(item.ActionsBundle.Actions, moduleNamespace)
		}

		for _, bundle := range item.EntityBundles {
			CastRoutes2(bundle.Actions, moduleNamespace)
		}

		if len(item.Children) > 0 {
			// XWebServerToGin(x, g, prefix+"/"+item.Name)
		}
	}
}

func SyncDatabase(x *XWebServer, db *gorm.DB) {

	for _, item := range x.Modules {
		if item.EntityProvider != nil {
			item.EntityProvider(db)
		}

		for _, bundle := range item.EntityBundles {
			if err := dbref.AutoMigrate(bundle.AutoMigrationEntities...); err != nil {
				fmt.Println("There is an error on migrating:", bundle)
				log.Fatalln(err.Error())
			}
		}
	}

}

func RunApp(xapp *XWebServer) {

	app := &cli.App{
		EnableBashCompletion: true,
		Name:                 xapp.Title,
		Flags:                cliGlobalFlags,
		Commands:             GetCliCommands(xapp),
	}

	err := app.Run(os.Args)
	if err != nil {
		log.Fatal(err)
	}
}
