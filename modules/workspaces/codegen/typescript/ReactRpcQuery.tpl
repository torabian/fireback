/*
*	Generated by fireback {{ .fv }}
*	Written by Ali Torabi.
* The code is generated for react-query@v3.39.3
*	Checkout the repository for licenses and contribution: https://github.com/torabian/fireback
*/

import { useContext } from "react";
import { useQuery } from "react-query";
import { 
  RemoteQueryContext,
  UseRemoteQuery,
  queryBeforeSend,
} from "../../core/react-tools";
import { stringify } from "qs";
import { execApiFn, IResponseList } from "../../core/http-tools";


{{ template "tsimport" . }}

// Fireback gives the option to have typesafe query string
export type {{ .r.GetFuncNameUpper}}Qs = {

}

export type {{ .r.GetFuncNameUpper}}UrlParams = {
  
}

export type {{ .r.GetFuncNameUpper}}Headers = {

}

export function use{{ .r.GetFuncNameUpper}}({
  queryOptions,
  query,
  queryClient,
  execFnOverride,
  unauthorized,
  optionFn
}: UseRemoteQuery & {query?: {{ .r.GetFuncNameUpper}}Qs}) {
  const { options, execFn } = useContext(RemoteQueryContext);

  const computedOptions = optionFn ? optionFn(options) : options;
  // Calculare the function which will do the remote calls.
  // We consider to use global override, this specific override, or default which
  // comes with the sdk.
  const rpcFn = execFnOverride
    ? execFnOverride(computedOptions)
    : execFn
    ? execFn(computedOptions)
    : execApiFn(computedOptions);

  // Url of the remote affix.
  const url = "{{ .r.Url}}".substr(1);

  let computedUrl = `${url}?${stringify(query)}`;

  {{ template "routeUrl" .r }}

  // Attach the details of the request to the fn
  const fn = () => rpcFn("{{ .r.MethodUpper }}", computedUrl);
 

  const auth = computedOptions?.headers?.authorization
  const hasKey = auth != "undefined" && auth != undefined && auth !=null && auth != "null" && !!auth

  let enabled = true;
  if (!completeRouteUrls) {
    enabled = false;
  } else if (!hasKey && !unauthorized) {
    enabled = false;
  }
  const query$ = useQuery<any, any, IResponseList<{{ .r.ResponseEntityComputed}}>, any>(["{{ .r.EntityKey }}", computedOptions, query], fn, {
    cacheTime: 1000,
    retry: false,
    keepPreviousData: true,
    enabled,
    ...((queryOptions as any) || {})
  } as any);

  const items: Array<{{ .r.ResponseEntityComputed}}> = query$.data?.data?.items || [];
  
  return { 
    query: query$,
    items,
    keyExtractor: (item: {{ .r.ResponseEntityComputed}}) => item.uniqueId,
  };
}

use{{ .r.GetFuncNameUpper}}.UKEY = "{{ .r.EntityKey }}"