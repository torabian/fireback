package {{ .m.Name }}

{{ define "remoteresponsetype" }} {{ if .Out }}*{{ if .Out.Dto}}  {{ .Out.Dto }} {{ end }} {{ if .Out.Entity}}  {{ .Out.Entity }} {{ end }} {{ if .Out.Fields}} {{ upper .Name }}RemoteResponse {{ end }} {{else }}[]byte{{ end }} {{ end }}
{{ define "remoterequestbody" }} {{ if .In }} {{ if .In.Dto}} {{ .In.Dto }} {{ end }}{{ if .In.Entity}} {{ .In.Entity }} {{ end }}{{ if .In.Fields}} {{ upper .Name }}RemoteBody {{ end }}{{ end }}{{ end }}
{{ define "querycolumns" }} {{ if .Columns }} {{ if .Columns.Dto}} {{ .Columns.Dto }} {{ end }}{{ if .Columns.Entity}} {{ .Columns.Entity }} {{ end }}{{ if .Columns.Fields}} {{ upper .Name }}QueryColumns {{ end }}{{ end }}{{ end }}

{{- define "taskrequestbody" -}}
  {{- if .In -}}
    {{- if .In.Dto -}}
      {{ .In.Dto }} 
    {{- else if .In.Entity -}}
      {{ .In.Entity }} 
    {{- else -}}
      {{ upper .Name }}TaskParams 
    {{- end -}}
  {{- else -}}
    {{ upper .Name }}TaskParams 
  {{- end -}}

{{- end -}}

/*
*	Generated by fireback {{ .fv }}
*	Written by Ali Torabi.
*	Checkout the repository for licenses and contribution: https://github.com/torabian/fireback
*/

{{ if ne .wsprefix "" }}
import "github.com/torabian/fireback/modules/workspaces"
{{ end }}


{{ if or (.m.Queries) }}
import queries "{{ .gofModule }}/{{ .ctx.RelativePath }}/queries"
{{ end }}

import "encoding/json"
import "github.com/urfave/cli"
import "gopkg.in/yaml.v2"
import "fmt"

{{ if .m.Remotes }}
import (

	"github.com/hashicorp/go-retryablehttp"
  "net/http"
  
)
{{ end }}

{{ if .m.Queries }}
import (
	"reflect"
  
)
{{ end }}


func {{ upper .m.Name }}Json() string {
  e := cli.BoolFlag{}
	_ = e

  fmt.Println("Module test config")

  str2, _ := yaml.Marshal("")
	_ = str2

  str, _ := json.MarshalIndent("dont remove me", "", "  ")
	return (string(str))
}

// Module dynamic things comes here. Don't touch it :D

var PERM_ROOT_{{ .m.AllUpper }}_EVERYTHING = {{ .wsprefix }}PermissionInfo{
  CompleteKey: "root.{{ .ctx.RelativePathDot}}.*",
}
var ALL_PERM_{{ .m.AllUpper }}_MODULE = []{{ .wsprefix }}PermissionInfo{
  PERM_ROOT_{{ .m.AllUpper }}_EVERYTHING,
}



{{ range .remoteQueryChildren }}

  {{ range .}}

  type {{ .FullName }} struct {
    {{ template "definitionrow" (arr .Fields $.wsprefix) }}
  }

  {{ end }}
{{ end }}

{{ range .remoteResChildrenMap }}

  {{ range .}}

  type {{ .FullName }} struct {
    {{ template "definitionrow" (arr .Fields $.wsprefix) }}
  }

  {{ end }}
{{ end }}

{{ range .remoteReqChildrenMap }}

  {{ range .}}

  type {{ .FullName }} struct {
    {{ template "definitionrow" (arr .Fields $.wsprefix) }}
  }

  {{ end }}
{{ end }}


 
{{ if .m.Messages }}
{{ template "messageCode" (arr .m.Name .m.Messages $.wsprefix)}}
{{ end }}


{{ if .m.Remotes }}


type {{ .m.Name }}RemoteContext struct {
	client *retryablehttp.Client
}

var {{ upper .m.Name }}Remotes {{ .m.Name }}RemoteContext = {{ .m.Name }}RemoteContext{
	client: retryablehttp.NewClient(),
}

{{ end }}
{{ range .m.Remotes }}

/// {{ upper .Name }}

{{ if .Out }}
{{ if .Out.Fields }}

type {{ upper .Name }}RemoteResponse struct {
  {{ template "definitionrow" (arr .Out.Fields $.wsprefix) }}
}

{{ end }}
{{ end }}

{{ if .In }}
{{ if .In.Fields }}

type {{ upper .Name }}RemoteBody struct {
  {{ template "definitionrow" (arr .In.Fields $.wsprefix) }}
}


func (x *{{ upper .Name }}RemoteBody) JsonByte() []byte {
	if x != nil {
		str, _ := json.MarshalIndent(x, "", "  ")
		return str
	}
	return []byte{}
}
func (x *{{ upper .Name }}RemoteBody) Json() string {
	return string(x.JsonByte())
}


{{ end }}
{{ end }}


{{ if .Query }}
/// query item
type {{ upper .Name }}Query struct {
  {{ template "definitionrow" (arr .Query $.wsprefix true) }}
}

{{ end }}

func (x *{{ $.m.Name }}RemoteContext) {{ upper .Name }}(
  {{ if .Query }}
  query {{ upper .Name }}Query,
  {{ end }}
  {{ if .In }}
  body *{{ template "remoterequestbody" . }},
  {{ end }}
  headers http.Header,
  opt2 *{{ $.wsprefix }}RemoteRequestOptions,
) ({{ template "remoteresponsetype" . }}, *http.Response, *workspaces.IError) {

  if headers == nil {
		headers = http.Header{}
	}

	// It's super important to set the content type for request. By default, we assume
	// it's json, this can be extended in Fireback to be able to configurated via yaml
	if headers.Get("content-type") == "" {
		headers.Set("content-type", "application/json")
	}

  result, resp, err := {{ $.wsprefix }}MakeHTTPRequest(
		x.client,
		"{{ .Url }}",
    {{ if .Query}}
    query,
    {{ else }}
    nil,
    {{ end }}
		{{ $.wsprefix }}HTTPRequestOptions{
			Method: "{{ .Method }}",
      {{ if .In }}
      Body:   body.JsonByte(),
      {{ end }}
      Headers: headers,
		},
	)

  if err != nil {
    return nil, resp, err
  }

  {{ if .Out }}
    // Let's cast it to the object
    {{ if .Out.Entity }}
    var content *{{ .Out.Entity }}
    {{ else if .Out.Dto }}
    var content *{{ .Out.Dto }}
    {{ else if .Out.Fields }}
    var content *{{ upper .Name }}RemoteResponse

    {{ end }}
    json.Unmarshal(result, &content)
    return content, resp, nil
  {{ else }}
    return result, resp, nil
  {{ end }}

}

{{ end }}

{{ if .m.Queries }}
// There are queries to be created

  {{ template "generateQuery" (arr .m.Queries $.wsprefix)}}

{{ end }}

{{ if .m.Tasks }}


type {{ upper .m.Name }}TasksContext struct {
  {{ range .m.Tasks }}
  {{ upper .Name }} func ( body *{{ template "taskrequestbody" . }}, tx *{{ $.wsprefix }}TaskCtx) error
  {{ end }}
}

func (x *{{ upper .m.Name }}TasksContext) GetTasks() []*{{ $.wsprefix }}TaskAction {
	return []*{{ $.wsprefix }}TaskAction{
    {{ range .m.Tasks }}
		{
      Name: "{{ upper .Name }}",
      HandlerFunc: func(ctx *{{ $.wsprefix }}TaskCtx, content []byte) error {

        {{ if .In }}
				var body *{{ template "taskrequestbody" . }}

				if err := json.Unmarshal(content, &body); err != nil {
					return err
				}

				return x.{{ upper .Name }}(body, &{{ $.wsprefix }}TaskCtx{})

        {{ else }}
        return nil
        {{ end }}
			},
      Cli: func(c *cli.Context) error {
        {{ if .In }}
        dto := Cast{{ upper .Name }}TaskFromCli(c)
				task, err := New{{ upper .Name }}Task(dto)
				if err != nil {
					fmt.Println("Error on enqueue task {{ upper .Name }}: %w", err)
					return err
				}
				result, err2 := {{ $.wsprefix }}EnqueueTask(task)
				if err2 == nil {
					fmt.Println("task is in queue, id: %s", result.ID)
					return nil
				}
        {{ end }}

				return nil
			},
      {{ if .In}}
        Flags: {{ upper .Name }}CommonCliFlagsOptional,
      {{ end }}

      {{ if .Triggers }}
      Triggers: []*{{ $.wsprefix }}Module3Trigger{
        {{ range .Triggers }}
				{
					Cron: "{{.Cron}}",
				},
        {{ end }}
			},
      {{ end }}
		},
    {{ end }}
	}
}

{{ range .m.Tasks }}

{{ if .In }}
  var {{ upper .Name }}CommonCliFlagsOptional = []cli.Flag{
    {{ template "dtoCliFlag" (arr .In.Fields "") }}
  }

  func Cast{{ upper .Name }}TaskFromCli (c *cli.Context) *{{ template "taskrequestbody" . }} {
    template := &{{- template "taskrequestbody" . -}}{}
    {{ template "entityCliCastRecursive" (arr .In.Fields "" $.wsprefix)}}
    return template
  }

{{ end }}





func New{{ upper .Name }}Task(body *{{ upper .Name }}TaskParams) (*{{ $.wsprefix }}TaskMessage, error) {
  payload, err := json.Marshal(body)
  if err != nil {
    return nil, err
  }

  return &{{ $.wsprefix }}TaskMessage{
    Name: "{{ upper .Name }}",
    Payload: payload,
	}, nil
}

{{ end }}

{{ end }}


{{ range .taskChildren }}
  {{ range .}}

  type {{ .FullName }} struct {
    {{ template "definitionrow" (arr .Fields $.wsprefix) }}
  }

  {{ end }}
{{ end }}

{{ range .queriesChildren }}
  {{ range .}}

  type {{ .FullName }} struct {
    {{ template "definitionrow" (arr .Fields $.wsprefix) }}
  }

  {{ end }}
{{ end }}


{{ range .m.Tasks }}

type {{ upper .Name }}TaskParams struct {
  {{ if .In }}
    {{ if .In.Fields }}
      {{ template "definitionrow" (arr .In.Fields $.wsprefix) }}
    {{ end }}
  {{ end }}
}
    

func (x *{{ upper .Name }}TaskParams) Json() string {
  if x != nil {
    str, _ := json.MarshalIndent(x, "", "  ")
    return (string(str))

  }
  return ""
}


{{ end }}

{{ range .m.Queries }}

{{ if .Columns }}
  {{ if .Columns.Fields }}
  type {{ upper .Name }}QueryColumns struct {
    {{ if .Columns.Fields }}
      {{ template "definitionrow" (arr .Columns.Fields $.wsprefix) }}
    {{ end }}
  }
  func (x *{{ upper .Name }}QueryColumns) Json() string {
    if x != nil {
      str, _ := json.MarshalIndent(x, "", "  ")
      return (string(str))
    }
    return ""
  }
  {{ end }}
{{ end }}


func {{ upper .Name }}Query(query {{ $.wsprefix}}QueryDSL) ([]*{{ template "querycolumns" . }}, *{{ $.wsprefix}}QueryResultMeta, error) {
	refl := reflect.ValueOf(&{{ template "querycolumns" . }}{})
	items, meta, err := {{ $.wsprefix}}ContextAwareVSqlOperation[{{ template "querycolumns" . }}](
		refl, &queries.QueriesFs, "{{ upper .Name }}.vsql", query,
	)
	return items, meta, err
}

{{ end }}


{{ define "configFields" }}
  {{ $fields := index . 0 }}
  {{ $prefix := index . 1 }}
  {{ range $fields }}
    // {{ .Description }}
    {{ if or (eq .Type "string") (eq .Type "")}}
      {{ upper $prefix }}{{ upper .Name }} string `envconfig:"{{- if .Env -}}{{ .Env }}{{else}}{{ snakeUpper .Name }}{{end}}" description:"{{ escape .Description}}"`
    {{ end }}
    {{ if or (eq .Type "int64") }}
      {{ upper $prefix }}{{ upper .Name }} int64 `envconfig:"{{- if .Env -}}{{ .Env }}{{else}}{{ snakeUpper .Name }}{{end}}" description:"{{ escape .Description}}"`
    {{ end }}
    {{ if or (eq .Type "float64") }}
      {{ upper $prefix }}{{ upper .Name }} float64 `envconfig:"{{- if .Env -}}{{ .Env }}{{else}}{{ snakeUpper .Name }}{{end}}" description:"{{ escape .Description}}"`
    {{ end }}
    {{ if or (eq .Type "int") }}
      {{ upper $prefix }}{{ upper .Name }} int `envconfig:"{{- if .Env -}}{{ .Env }}{{else}}{{ snakeUpper .Name }}{{end}}" description:"{{ escape .Description}}"`
    {{ end }}
    {{ if or (eq .Type "bool") (eq .Type "boolean") }}
      {{ upper $prefix }}{{ upper .Name }} bool `envconfig:"{{- if .Env -}}{{ .Env }}{{else}}{{ snakeUpper .Name }}{{end}}" description:"{{ escape .Description}}"`
    {{ end }}
    {{ if or (eq .Type "int32") }}
      {{ upper $prefix }}{{ upper .Name }} int32 `envconfig:"{{- if .Env -}}{{ .Env }}{{else}}{{ snakeUpper .Name }}{{end}}" description:"{{ escape .Description}}"`
    {{ end }}
    {{ if or (eq .Type "object")}}
      {{ $newPrefix := print $prefix .Name  }}
      {{ template "configFields" (arr .Fields $newPrefix)}}
    {{ end }}
  {{ end }}
{{ end }}

{{ if .m.Config }}

type Config struct {
  {{ template "configFields" (arr .m.Config "") }}
}

func GetConfig() Config {
  return config
}


func GetConfigCliFlags() []cli.Flag {
	return []cli.Flag{
    {{ range .m.Config }} 
      {{ if or (eq .Type "string") (eq .Type "")}}
        cli.StringFlag{
          Name:  "{{ .DashedName }}",
          Usage: "{{ .Description }}",
        },
      {{ end }}
      {{ if or (eq .Type "int64") }}
        cli.Int64Flag{
          Name:  "{{ .DashedName }}",
          Usage: "{{ .Description }}",
        },
      {{ end }}
      {{ if or (eq .Type "float64") }}
        cli.Float64Flag{
          Name:  "{{ .DashedName }}",
          Usage: "{{ .Description }}",
        },
      {{ end }}
      {{ if or (eq .Type "int") }}
        cli.IntFlag{
          Name:  "{{ .DashedName }}",
          Usage: "{{ .Description }}",
        },
      {{ end }}
      {{ if or (eq .Type "bool") (eq .Type "boolean") }}
        cli.BoolFlag{
          Name:  "{{ .DashedName }}",
          Usage: "{{ .Description }}",
        },
      {{ end }}
      {{ if or (eq .Type "int32") }}
        cli.Int32Flag{
          Name:  "{{ .DashedName }}",
          Usage: "{{ .Description }}",
        },
      {{ end }}
    {{ end }}
	}
}

func CastConfigFromCli(config *Config, c *cli.Context) {
  {{ range .m.Config }} 
    if c.IsSet("{{ .DashedName }}") {
      {{ if or (eq .Type "string") (eq .Type "")}}
        config.{{ upper .Name }} = c.String("{{ .DashedName }}")
      {{ end }}
      {{ if or (eq .Type "int64") }}
        config.{{ upper .Name }} = c.Int64("{{ .DashedName }}")
      {{ end }}
      {{ if or (eq .Type "float64") }}
        config.{{ upper .Name }} = c.Float64("{{ .DashedName }}")
      {{ end }}
      {{ if or (eq .Type "int") }}
        config.{{ upper .Name }} = c.Int("{{ .DashedName }}")
      {{ end }}
      {{ if or (eq .Type "bool") (eq .Type "boolean") }}
        config.{{ upper .Name }} = c.Bool("{{ .DashedName }}")
      {{ end }}
      {{ if or (eq .Type "int32") }}
        config.{{ upper .Name }} = c.Int32("{{ .DashedName }}")
      {{ end }}
    }
  {{ end }}
}


func GetConfigCli() []cli.Command {
	return []cli.Command{
    {{ range .m.Config }}
		{
			Name:  "{{ .DashedName }}",
			Usage: "{{ .Description }} ({{ if or (eq .Type "string") (eq .Type "")}}string{{else}}{{.Type}}{{end}})",

      Subcommands: []cli.Command{
				{
					Name: "get",
					Action: func(c *cli.Context) error {
						fmt.Println(config.{{ upper .Name }})
						return nil
					},
				},
				{
					Name: "set",
					Action: func(c *cli.Context) error {
            {{ if or (eq .Type "bool") (eq .Type "boolean") }}
              return ConfigSetBoolean(c, config.{{ upper .Name }}, func(value bool) {
                config.{{ upper .Name }} = value
                config.Save(".env")
              })
            {{ end }}
            {{ if or (eq .Type "string") (eq .Type "")}}
              return ConfigSetString(c, config.{{ upper .Name }}, func(value string) {
                config.{{ upper .Name }} = value
                config.Save(".env")
              })
            {{ end }}
            {{ if or (eq .Type "int64")}}
              return ConfigSetInt64(c, config.{{ upper .Name }}, func(value int64) {
                config.{{ upper .Name }} = value
                config.Save(".env")
              })
            {{ end }}
            {{ if or (eq .Type "float64")}}
              return ConfigSetFloat64(c, config.{{ upper .Name }}, func(value float64) {
                config.{{ upper .Name }} = value
                config.Save(".env")
              })
            {{ end }}
            {{ if or (eq .Type "int")}}
              return ConfigSetInt(c, config.{{ upper .Name }}, func(value int) {
                config.{{ upper .Name }} = value
                config.Save(".env")
              })
            {{ end }}

            return nil
					},
				},
			},
		},
    {{ end }}
	}

}


// The config is usually populated by env vars on LoadConfiguration
var config Config = Config{
  {{ range .m.Config}}
    {{ if .Default }}
      {{ if or (eq .Type "string") (eq .Type "") }}
        {{ upper .Name }}: "{{ .Default }}",
      {{ else }}
        {{ upper .Name }}: {{ .Default }},
      {{ end }}
    {{ end }}
  {{ end }}
}

/**
You can call this function on first line of your main function.
This is different from fireback configuration (for now), you can
define config: in module3 file, similar to fields in entities,
and we generate the config struct and this function would read .env.local,
.env.prod, etc - depending on the ENV=xxx env variable.
**/
func LoadConfiguration() Config {
	{{ .wsprefix }} HandleEnvVars(&config)
	return config
}

func (x *Config) Yaml() string {
	if x != nil {
		str, _ := yaml.Marshal(x)
		return (string(str))
	}
	return ""
}

func (x *Config) Save(filepath string) error {
	return {{ .wsprefix }}SaveEnvFile(x, filepath)
}

{{ end }}

{{ template "eventInformation" (arr .m.Events $.wsprefix) }}
{{ template "notificationInformation" (arr .m.Notifications $.wsprefix) }}
