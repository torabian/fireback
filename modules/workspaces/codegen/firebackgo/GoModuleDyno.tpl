package {{ .m.Name }}

{{ define "remoteresponsetype" }} {{ if .Out }}*{{ if .Out.Dto}}  {{ .Out.Dto }} {{ end }} {{ if .Out.Entity}}  {{ .Out.Entity }} {{ end }} {{ if .Out.Fields}} {{ upper .Name }}RemoteResponse {{ end }} {{else }}[]byte{{ end }} {{ end }}
{{ define "remoterequestbody" }} {{ if .In }} {{ if .In.Dto}} {{ .In.Dto }} {{ end }}{{ if .In.Entity}} {{ .In.Entity }} {{ end }}{{ if .In.Fields}} {{ upper .Name }}RemoteBody {{ end }}{{ end }}{{ end }}

{{- define "taskrequestbody" -}}
  {{- if .In -}}
    {{- if .In.Dto -}}
      {{ .In.Dto }} 
    {{- else if .In.Entity -}}
      {{ .In.Entity }} 
    {{- else -}}
      {{ upper .Name }}TaskParams 
    {{- end -}}
  {{- else -}}
    {{ upper .Name }}TaskParams 
  {{- end -}}

{{- end -}}

/*
*	Generated by fireback {{ .fv }}
*	Written by Ali Torabi.
*	Checkout the repository for licenses and contribution: https://github.com/torabian/fireback
*/

{{ if ne .wsprefix "" }}
import "github.com/torabian/fireback/modules/workspaces"
{{ end }}

import "encoding/json"
import "github.com/urfave/cli"
import "gopkg.in/yaml.v2"
import "fmt"

{{ if .m.Remotes }}
import (

	"github.com/hashicorp/go-retryablehttp"
  "net/http"
  
)
{{ end }}


func {{ upper .m.Name }}Json() string {
  e := cli.BoolFlag{}
	_ = e

  fmt.Println("Module test config")

  str2, _ := yaml.Marshal("")
	_ = str2

  str, _ := json.MarshalIndent("dont remove me", "", "  ")
	return (string(str))
}

// Module dynamic things comes here. Don't touch it :D

var PERM_ROOT_{{ .m.AllUpper }}_EVERYTHING = {{ .wsprefix }}PermissionInfo{
  CompleteKey: "root/{{.m.AllLower}}/*",
}
var ALL_PERM_{{ .m.AllUpper }}_MODULE = []{{ .wsprefix }}PermissionInfo{
  PERM_ROOT_{{ .m.AllUpper }}_EVERYTHING,
}



{{ range .remoteQueryChildren }}

  {{ range .}}

  type {{ .FullName }} struct {
    {{ template "definitionrow" (arr .Fields $.wsprefix) }}
  }

  {{ end }}
{{ end }}

{{ range .remoteResChildrenMap }}

  {{ range .}}

  type {{ .FullName }} struct {
    {{ template "definitionrow" (arr .Fields $.wsprefix) }}
  }

  {{ end }}
{{ end }}

{{ range .remoteReqChildrenMap }}

  {{ range .}}

  type {{ .FullName }} struct {
    {{ template "definitionrow" (arr .Fields $.wsprefix) }}
  }

  {{ end }}
{{ end }}


 
{{ if .m.Messages }}
{{ template "messageCode" (arr .m.Name .m.Messages $.wsprefix)}}
{{ end }}


{{ if .m.Remotes }}


type {{ .m.Name }}RemoteContext struct {
	client *retryablehttp.Client
}

var {{ upper .m.Name }}Remotes {{ .m.Name }}RemoteContext = {{ .m.Name }}RemoteContext{
	client: retryablehttp.NewClient(),
}

{{ end }}
{{ range .m.Remotes }}

/// {{ upper .Name }}

{{ if .Out }}
{{ if .Out.Fields }}

type {{ upper .Name }}RemoteResponse struct {
  {{ template "definitionrow" (arr .Out.Fields $.wsprefix) }}
}

{{ end }}
{{ end }}

{{ if .In }}
{{ if .In.Fields }}

type {{ upper .Name }}RemoteBody struct {
  {{ template "definitionrow" (arr .In.Fields $.wsprefix) }}
}


func (x *{{ upper .Name }}RemoteBody) JsonByte() []byte {
	if x != nil {
		str, _ := json.MarshalIndent(x, "", "  ")
		return str
	}
	return []byte{}
}
func (x *{{ upper .Name }}RemoteBody) Json() string {
	return string(x.JsonByte())
}


{{ end }}
{{ end }}


{{ if .Query }}
/// query item
type {{ upper .Name }}Query struct {
  {{ template "definitionrow" (arr .Query $.wsprefix true) }}
}

{{ end }}

func (x *{{ $.m.Name }}RemoteContext) {{ upper .Name }}(
  {{ if .Query }}
  query {{ upper .Name }}Query,
  {{ end }}
  {{ if .In }}
  body *{{ template "remoterequestbody" . }},
  {{ end }}
  headers http.Header,
) ({{ template "remoteresponsetype" . }}, *http.Response, *workspaces.IError) {

  result, resp, err := {{ $.wsprefix }}MakeHTTPRequest(
		x.client,
		"{{ .Url }}",
    {{ if .Query}}
    query,
    {{ else }}
    nil,
    {{ end }}
		{{ $.wsprefix }}HTTPRequestOptions{
			Method: "{{ .Method }}",
      {{ if .In }}
      Body:   body.JsonByte(),
      {{ end }}
      Headers: headers,
		},
	)

  if err != nil {
    return nil, resp, err
  }

  {{ if .Out }}
    // Let's cast it to the object
    {{ if .Out.Entity }}
    var content *{{ .Out.Entity }}
    {{ else if .Out.Dto }}
    var content *{{ .Out.Dto }}
    {{ else if .Out.Fields }}
    var content *{{ upper .Name }}RemoteResponse

    {{ end }}
    json.Unmarshal(result, &content)
    return content, resp, nil
  {{ else }}
    return result, resp, nil
  {{ end }}

}

{{ end }}


{{ if .m.Tasks }}


type {{ upper .m.Name }}TasksContext struct {
  {{ range .m.Tasks }}
  {{ upper .Name }} func ( body *{{ template "taskrequestbody" . }}, tx *{{ $.wsprefix }}TaskCtx) error
  {{ end }}
}

func (x *{{ upper .m.Name }}TasksContext) GetTasks() []*{{ $.wsprefix }}TaskAction {
	return []*{{ $.wsprefix }}TaskAction{
    {{ range .m.Tasks }}
		{
      Name: "{{ upper .Name }}",
      HandlerFunc: func(ctx *{{ $.wsprefix }}TaskCtx, content []byte) error {

        {{ if .In }}
				var body *{{ template "taskrequestbody" . }}

				if err := json.Unmarshal(content, &body); err != nil {
					return err
				}

				return x.{{ upper .Name }}(body, &{{ $.wsprefix }}TaskCtx{})

        {{ else }}
        return nil
        {{ end }}
			},
      Cli: func(c *cli.Context) error {
        {{ if .In }}
        dto := Cast{{ upper .Name }}TaskFromCli(c)
				task, err := New{{ upper .Name }}Task(dto)
				if err != nil {
					fmt.Println("Error on enqueue task {{ upper .Name }}: %w", err)
					return err
				}
				result, err2 := {{ $.wsprefix }}EnqueueTask(task)
				if err2 == nil {
					fmt.Println("task is in queue, id: %s", result.ID)
					return nil
				}
        {{ end }}

				return nil
			},
      {{ if .In}}
        Flags: {{ upper .Name }}CommonCliFlagsOptional,
      {{ end }}

      {{ if .Triggers }}
      /// Think about the triggers here
      {{ end }}
		},
    {{ end }}
	}
}

{{ range .m.Tasks }}

{{ if .In }}
  var {{ upper .Name }}CommonCliFlagsOptional = []cli.Flag{
    {{ template "dtoCliFlag" (arr .In.Fields "") }}
  }

  func Cast{{ upper .Name }}TaskFromCli (c *cli.Context) *{{ template "taskrequestbody" . }} {
    template := &{{- template "taskrequestbody" . -}}{}
    {{ template "entityCliCastRecursive" (arr .In.Fields "")}}
    return template
  }

{{ end }}





func New{{ upper .Name }}Task(body *{{ upper .Name }}TaskParams) (*{{ $.wsprefix }}TaskMessage, error) {
  payload, err := json.Marshal(body)
  if err != nil {
    return nil, err
  }

  return &{{ $.wsprefix }}TaskMessage{
    Name: "{{ upper .Name }}",
    Payload: payload,
	}, nil
}

{{ end }}

{{ end }}


{{ range .taskChildren }}
  {{ range .}}

  type {{ .FullName }} struct {
    {{ template "definitionrow" (arr .Fields $.wsprefix) }}
  }

  {{ end }}
{{ end }}


{{ range .m.Tasks }}

type {{ upper .Name }}TaskParams struct {
  {{ if .In }}
    {{ if .In.Fields }}
      {{ template "definitionrow" (arr .In.Fields $.wsprefix) }}
    {{ end }}
  {{ end }}
}
    

func (x *{{ upper .Name }}TaskParams) Json() string {
  if x != nil {
    str, _ := json.MarshalIndent(x, "", "  ")
    return (string(str))

  }
  return ""
}


{{ end }}


{{ define "configFields" }}
  {{ $fields := index . 0 }}
  {{ $prefix := index . 1 }}
  {{ range $fields }}
    // {{ .Description }}
    {{ if or (eq .Type "string") (eq .Type "")}}
      {{ upper $prefix }}{{ upper .Name }} string `envconfig:"{{- if .Env -}}{{ .Env }}{{else}}{{ snakeUpper .Name }}{{end}}" description:"{{ escape .Description}}"`
    {{ end }}
    {{ if or (eq .Type "int64") }}
      {{ upper $prefix }}{{ upper .Name }} int64 `envconfig:"{{- if .Env -}}{{ .Env }}{{else}}{{ snakeUpper .Name }}{{end}}" description:"{{ escape .Description}}"`
    {{ end }}
    {{ if or (eq .Type "float64") }}
      {{ upper $prefix }}{{ upper .Name }} int64 `envconfig:"{{- if .Env -}}{{ .Env }}{{else}}{{ snakeUpper .Name }}{{end}}" description:"{{ escape .Description}}"`
    {{ end }}
    {{ if or (eq .Type "int") }}
      {{ upper $prefix }}{{ upper .Name }} int `envconfig:"{{- if .Env -}}{{ .Env }}{{else}}{{ snakeUpper .Name }}{{end}}" description:"{{ escape .Description}}"`
    {{ end }}
    {{ if or (eq .Type "bool") (eq .Type "boolean") }}
      {{ upper $prefix }}{{ upper .Name }} bool `envconfig:"{{- if .Env -}}{{ .Env }}{{else}}{{ snakeUpper .Name }}{{end}}" description:"{{ escape .Description}}"`
    {{ end }}
    {{ if or (eq .Type "int32") }}
      {{ upper $prefix }}{{ upper .Name }} int32 `envconfig:"{{- if .Env -}}{{ .Env }}{{else}}{{ snakeUpper .Name }}{{end}}" description:"{{ escape .Description}}"`
    {{ end }}
    {{ if or (eq .Type "object")}}
      {{ $newPrefix := print $prefix .Name  }}
      {{ template "configFields" (arr .Fields $newPrefix)}}
    {{ end }}
  {{ end }}
{{ end }}

{{ if .m.Config }}

type Config struct {
  {{ template "configFields" (arr .m.Config "") }}
}

// The config is usually populated by env vars on LoadConfiguration
var config Config = Config{
  {{ range .m.Config}}
    {{ if .Default }}
      {{ if or (eq .Type "string") (eq .Type "") }}
        {{ upper .Name }}: "{{ .Default }}",
      {{ else }}
        {{ upper .Name }}: {{ .Default }},
      {{ end }}
    {{ end }}
  {{ end }}
}

/**
You can call this function on first line of your main function.
This is different from fireback configuration (for now), you can
define config: in module3 file, similar to fields in entities,
and we generate the config struct and this function would read .env.local,
.env.prod, etc - depending on the ENV=xxx env variable.
**/
func LoadConfiguration() Config {
	{{ .wsprefix }} HandleEnvVars(&config)
	return config
}

func (x *Config) Yaml() string {
	if x != nil {
		str, _ := yaml.Marshal(x)
		return (string(str))
	}
	return ""
}

func (x *Config) Save(filepath string) error {
	return {{ .wsprefix }}SaveEnvFile(x, filepath)
}


{{ end }}