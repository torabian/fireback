package abac

/*
*	Generated by fireback 1.2.1
*	Written by Ali Torabi.
*	Checkout the repository for licenses and contribution: https://github.com/torabian/fireback
 */
import (
	"github.com/gin-gonic/gin"
	"github.com/torabian/fireback/modules/workspaces"
	"github.com/urfave/cli"
)

// using shared actions here
type QueryUserRoleWorkspacesResDtoRoles struct {
	Name     string `json:"name" yaml:"name"        `
	UniqueId string `json:"uniqueId" yaml:"uniqueId"        `
	// Capabilities related to this role which are available
	Capabilities []string `json:"capabilities" yaml:"capabilities"        `
}
type CheckClassicPassportResDtoOtpInfo struct {
	SuspendUntil int64 `json:"suspendUntil" yaml:"suspendUntil"        `
	ValidUntil   int64 `json:"validUntil" yaml:"validUntil"        `
	BlockedUntil int64 `json:"blockedUntil" yaml:"blockedUntil"        `
	// The amount of time left to unblock for next request
	SecondsToUnblock int64 `json:"secondsToUnblock" yaml:"secondsToUnblock"        `
}

var AcceptInviteSecurityModel = &workspaces.SecurityModel{
	ActionRequires:  []workspaces.PermissionInfo{},
	ResolveStrategy: "user",
}

type AcceptInviteActionReqDto struct {
	// The invitation id which will be used to process
	InvitationUniqueId string `json:"invitationUniqueId" yaml:"invitationUniqueId"  validate:"required"        `
}

func (x *AcceptInviteActionReqDto) RootObjectName() string {
	return "Abac"
}

var AcceptInviteCommonCliFlagsOptional = []cli.Flag{
	&cli.StringFlag{
		Name:     "invitation-unique-id",
		Required: true,
		Usage:    `The invitation id which will be used to process (string)`,
	},
}

func AcceptInviteActionReqValidator(dto *AcceptInviteActionReqDto) *workspaces.IError {
	err := workspaces.CommonStructValidatorPointer(dto, false)
	return err
}
func CastAcceptInviteFromCli(c *cli.Context) *AcceptInviteActionReqDto {
	template := &AcceptInviteActionReqDto{}
	if c.IsSet("invitation-unique-id") {
		template.InvitationUniqueId = c.String("invitation-unique-id")
	}
	return template
}

type acceptInviteActionImpSig func(
	req *AcceptInviteActionReqDto,
	q workspaces.QueryDSL) (string,
	*workspaces.IError,
)

var AcceptInviteActionImp acceptInviteActionImpSig

func AcceptInviteActionFn(
	req *AcceptInviteActionReqDto,
	q workspaces.QueryDSL,
) (
	string,
	*workspaces.IError,
) {
	if AcceptInviteActionImp == nil {
		return "", nil
	}
	return AcceptInviteActionImp(req, q)
}

var AcceptInviteActionCmd cli.Command = cli.Command{
	Name:  "accept-invite",
	Usage: `Use it when user accepts an invitation, and it will complete the joining process`,
	Flags: AcceptInviteCommonCliFlagsOptional,
	Action: func(c *cli.Context) {
		query := workspaces.CommonCliQueryDSLBuilderAuthorize(c, AcceptInviteSecurityModel)
		dto := CastAcceptInviteFromCli(c)
		result, err := AcceptInviteActionFn(dto, query)
		workspaces.HandleActionInCli(c, result, err, map[string]map[string]string{})
	},
}
var OauthAuthenticateSecurityModel *workspaces.SecurityModel = nil

type OauthAuthenticateActionReqDto struct {
	// The token that Auth2 provider returned to the front-end, which will be used to validate the backend
	Token string `json:"token" yaml:"token"        `
	// The service name, such as "google" which later backend will use to authorize the token and create the user.
	Service string `json:"service" yaml:"service"        `
}

func (x *OauthAuthenticateActionReqDto) RootObjectName() string {
	return "Abac"
}

var OauthAuthenticateCommonCliFlagsOptional = []cli.Flag{
	&cli.StringFlag{
		Name:     "token",
		Required: false,
		Usage:    `The token that Auth2 provider returned to the front-end, which will be used to validate the backend (string)`,
	},
	&cli.StringFlag{
		Name:     "service",
		Required: false,
		Usage:    `The service name, such as "google" which later backend will use to authorize the token and create the user. (string)`,
	},
}

func OauthAuthenticateActionReqValidator(dto *OauthAuthenticateActionReqDto) *workspaces.IError {
	err := workspaces.CommonStructValidatorPointer(dto, false)
	return err
}
func CastOauthAuthenticateFromCli(c *cli.Context) *OauthAuthenticateActionReqDto {
	template := &OauthAuthenticateActionReqDto{}
	if c.IsSet("token") {
		template.Token = c.String("token")
	}
	if c.IsSet("service") {
		template.Service = c.String("service")
	}
	return template
}

type OauthAuthenticateActionResDto struct {
	Session   *UserSessionDto   `json:"session" yaml:"session"    gorm:"foreignKey:SessionId;references:UniqueId"      `
	SessionId workspaces.String `json:"sessionId" yaml:"sessionId"`
	// The next possible action which is suggested.
	Next []string `json:"next" yaml:"next"        `
}

func (x *OauthAuthenticateActionResDto) RootObjectName() string {
	return "Abac"
}

type oauthAuthenticateActionImpSig func(
	req *OauthAuthenticateActionReqDto,
	q workspaces.QueryDSL) (*OauthAuthenticateActionResDto,
	*workspaces.IError,
)

var OauthAuthenticateActionImp oauthAuthenticateActionImpSig

func OauthAuthenticateActionFn(
	req *OauthAuthenticateActionReqDto,
	q workspaces.QueryDSL,
) (
	*OauthAuthenticateActionResDto,
	*workspaces.IError,
) {
	if OauthAuthenticateActionImp == nil {
		return nil, nil
	}
	return OauthAuthenticateActionImp(req, q)
}

var OauthAuthenticateActionCmd cli.Command = cli.Command{
	Name:  "oauth-authenticate",
	Usage: `When a token is got from a oauth service such as google, we send the token here to authenticate the user. To me seems this doesn't need to have 2FA or anything, so we return the session directly, or maybe there needs to be next step.`,
	Flags: OauthAuthenticateCommonCliFlagsOptional,
	Action: func(c *cli.Context) {
		query := workspaces.CommonCliQueryDSLBuilderAuthorize(c, OauthAuthenticateSecurityModel)
		dto := CastOauthAuthenticateFromCli(c)
		result, err := OauthAuthenticateActionFn(dto, query)
		workspaces.HandleActionInCli(c, result, err, map[string]map[string]string{})
	},
}
var UserPassportsSecurityModel = &workspaces.SecurityModel{
	ActionRequires:  []workspaces.PermissionInfo{},
	ResolveStrategy: "user",
}

type UserPassportsActionResDto struct {
	// The passport value, such as email address or phone number
	Value string `json:"value" yaml:"value"        `
	// Unique identifier of the passport to operate some action on top of it
	UniqueId string `json:"uniqueId" yaml:"uniqueId"        `
	// The type of the passport, such as email, phone number
	Type string `json:"type" yaml:"type"        `
	// Regardless of the secret, user needs to confirm his secret. There is an extra action to confirm user totp, could be used after signup or prior to login.
	TotpConfirmed bool `json:"totpConfirmed" yaml:"totpConfirmed"        `
}

func (x *UserPassportsActionResDto) RootObjectName() string {
	return "Abac"
}

type userPassportsActionImpSig func(
	q workspaces.QueryDSL) ([]*UserPassportsActionResDto,
	*workspaces.QueryResultMeta,
	*workspaces.IError,
)

var UserPassportsActionImp userPassportsActionImpSig

func UserPassportsActionFn(
	q workspaces.QueryDSL,
) (
	[]*UserPassportsActionResDto,
	*workspaces.QueryResultMeta,
	*workspaces.IError,
) {
	if UserPassportsActionImp == nil {
		return nil, nil, nil
	}
	return UserPassportsActionImp(q)
}

var UserPassportsActionCmd cli.Command = cli.Command{
	Name:  "user-passports",
	Usage: `Returns list of passports belongs to an specific user.`,
	Flags: workspaces.CommonQueryFlags,
	Action: func(c *cli.Context) {
		query := workspaces.CommonCliQueryDSLBuilderAuthorize(c, UserPassportsSecurityModel)
		result, _, err := UserPassportsActionFn(query)
		workspaces.HandleActionInCli(c, result, err, map[string]map[string]string{})
	},
}
var ChangePasswordSecurityModel = &workspaces.SecurityModel{
	ActionRequires:  []workspaces.PermissionInfo{},
	ResolveStrategy: "user",
}

type ChangePasswordActionReqDto struct {
	// New password meeting the security requirements.
	Password string `json:"password" yaml:"password"  validate:"required"        `
	// The passport uniqueId (not the email or phone number) which password would be applied to. Don't confuse with value.
	UniqueId string `json:"uniqueId" yaml:"uniqueId"  validate:"required"        `
}

func (x *ChangePasswordActionReqDto) RootObjectName() string {
	return "Abac"
}

var ChangePasswordCommonCliFlagsOptional = []cli.Flag{
	&cli.StringFlag{
		Name:     "password",
		Required: true,
		Usage:    `New password meeting the security requirements. (string)`,
	},
	&cli.StringFlag{
		Name:     "unique-id",
		Required: true,
		Usage:    `The passport uniqueId (not the email or phone number) which password would be applied to. Don't confuse with value. (string)`,
	},
}

func ChangePasswordActionReqValidator(dto *ChangePasswordActionReqDto) *workspaces.IError {
	err := workspaces.CommonStructValidatorPointer(dto, false)
	return err
}
func CastChangePasswordFromCli(c *cli.Context) *ChangePasswordActionReqDto {
	template := &ChangePasswordActionReqDto{}
	if c.IsSet("password") {
		template.Password = c.String("password")
	}
	if c.IsSet("unique-id") {
		template.UniqueId = c.String("unique-id")
	}
	return template
}

type changePasswordActionImpSig func(
	req *ChangePasswordActionReqDto,
	q workspaces.QueryDSL) (string,
	*workspaces.IError,
)

var ChangePasswordActionImp changePasswordActionImpSig

func ChangePasswordActionFn(
	req *ChangePasswordActionReqDto,
	q workspaces.QueryDSL,
) (
	string,
	*workspaces.IError,
) {
	if ChangePasswordActionImp == nil {
		return "", nil
	}
	return ChangePasswordActionImp(req, q)
}

var ChangePasswordActionCmd cli.Command = cli.Command{
	Name:  "change-password",
	Usage: `Change the password for a given passport of the user. User needs to be authenticated in order to be able to change the password for a given account.`,
	Flags: ChangePasswordCommonCliFlagsOptional,
	Action: func(c *cli.Context) {
		query := workspaces.CommonCliQueryDSLBuilderAuthorize(c, ChangePasswordSecurityModel)
		dto := CastChangePasswordFromCli(c)
		result, err := ChangePasswordActionFn(dto, query)
		workspaces.HandleActionInCli(c, result, err, map[string]map[string]string{})
	},
}
var UserInvitationsSecurityModel = &workspaces.SecurityModel{
	ActionRequires:  []workspaces.PermissionInfo{},
	ResolveStrategy: "user",
}

type userInvitationsActionImpSig func(
	q workspaces.QueryDSL) ([]*UserInvitationsQueryColumns,
	*workspaces.QueryResultMeta,
	*workspaces.IError,
)

var UserInvitationsActionImp userInvitationsActionImpSig

func UserInvitationsActionFn(
	q workspaces.QueryDSL,
) (
	[]*UserInvitationsQueryColumns,
	*workspaces.QueryResultMeta,
	*workspaces.IError,
) {
	if UserInvitationsActionImp == nil {
		return nil, nil, nil
	}
	return UserInvitationsActionImp(q)
}

var UserInvitationsActionCmd cli.Command = cli.Command{
	Name:  "user-invitations",
	Usage: `Shows the invitations for an specific user, if the invited member already has a account. It's based on the passports, so if the passport is authenticated we will show them.`,
	Flags: workspaces.CommonQueryFlags,
	Action: func(c *cli.Context) {
		query := workspaces.CommonCliQueryDSLBuilderAuthorize(c, UserInvitationsSecurityModel)
		result, _, err := UserInvitationsActionFn(query)
		workspaces.HandleActionInCli(c, result, err, map[string]map[string]string{})
	},
}
var ConfirmClassicPassportTotpSecurityModel *workspaces.SecurityModel = nil

type ConfirmClassicPassportTotpActionReqDto struct {
	// Passport value, email or phone number which is already successfully registered.
	Value string `json:"value" yaml:"value"  validate:"required"        `
	// Password related to the passport. Totp is only available for passports with a password. Basically totp is protecting passport, not otp over email or sms.
	Password string `json:"password" yaml:"password"  validate:"required"        `
	// The totp code generated by authenticator such as google or microsft apps.
	TotpCode string `json:"totpCode" yaml:"totpCode"  validate:"required"        `
}

func (x *ConfirmClassicPassportTotpActionReqDto) RootObjectName() string {
	return "Abac"
}

var ConfirmClassicPassportTotpCommonCliFlagsOptional = []cli.Flag{
	&cli.StringFlag{
		Name:     "value",
		Required: true,
		Usage:    `Passport value, email or phone number which is already successfully registered. (string)`,
	},
	&cli.StringFlag{
		Name:     "password",
		Required: true,
		Usage:    `Password related to the passport. Totp is only available for passports with a password. Basically totp is protecting passport, not otp over email or sms. (string)`,
	},
	&cli.StringFlag{
		Name:     "totp-code",
		Required: true,
		Usage:    `The totp code generated by authenticator such as google or microsft apps. (string)`,
	},
}

func ConfirmClassicPassportTotpActionReqValidator(dto *ConfirmClassicPassportTotpActionReqDto) *workspaces.IError {
	err := workspaces.CommonStructValidatorPointer(dto, false)
	return err
}
func CastConfirmClassicPassportTotpFromCli(c *cli.Context) *ConfirmClassicPassportTotpActionReqDto {
	template := &ConfirmClassicPassportTotpActionReqDto{}
	if c.IsSet("value") {
		template.Value = c.String("value")
	}
	if c.IsSet("password") {
		template.Password = c.String("password")
	}
	if c.IsSet("totp-code") {
		template.TotpCode = c.String("totp-code")
	}
	return template
}

type ConfirmClassicPassportTotpActionResDto struct {
	Session   *UserSessionDto   `json:"session" yaml:"session"    gorm:"foreignKey:SessionId;references:UniqueId"      `
	SessionId workspaces.String `json:"sessionId" yaml:"sessionId"`
}

func (x *ConfirmClassicPassportTotpActionResDto) RootObjectName() string {
	return "Abac"
}

type confirmClassicPassportTotpActionImpSig func(
	req *ConfirmClassicPassportTotpActionReqDto,
	q workspaces.QueryDSL) (*ConfirmClassicPassportTotpActionResDto,
	*workspaces.IError,
)

var ConfirmClassicPassportTotpActionImp confirmClassicPassportTotpActionImpSig

func ConfirmClassicPassportTotpActionFn(
	req *ConfirmClassicPassportTotpActionReqDto,
	q workspaces.QueryDSL,
) (
	*ConfirmClassicPassportTotpActionResDto,
	*workspaces.IError,
) {
	if ConfirmClassicPassportTotpActionImp == nil {
		return nil, nil
	}
	return ConfirmClassicPassportTotpActionImp(req, q)
}

var ConfirmClassicPassportTotpActionCmd cli.Command = cli.Command{
	Name:  "confirm-classic-passport-totp",
	Usage: `When user requires to setup the totp for an specifc passport, they can use this endpoint to confirm it.`,
	Flags: ConfirmClassicPassportTotpCommonCliFlagsOptional,
	Action: func(c *cli.Context) {
		query := workspaces.CommonCliQueryDSLBuilderAuthorize(c, ConfirmClassicPassportTotpSecurityModel)
		dto := CastConfirmClassicPassportTotpFromCli(c)
		result, err := ConfirmClassicPassportTotpActionFn(dto, query)
		workspaces.HandleActionInCli(c, result, err, map[string]map[string]string{})
	},
}
var CheckPassportMethodsSecurityModel *workspaces.SecurityModel = nil

type CheckPassportMethodsActionResDto struct {
	Email                bool   `json:"email" yaml:"email"        `
	Phone                bool   `json:"phone" yaml:"phone"        `
	Google               bool   `json:"google" yaml:"google"        `
	GoogleOAuthClientKey string `json:"googleOAuthClientKey" yaml:"googleOAuthClientKey"        `
	EnabledRecaptcha2    bool   `json:"enabledRecaptcha2" yaml:"enabledRecaptcha2"        `
	Recaptcha2ClientKey  string `json:"recaptcha2ClientKey" yaml:"recaptcha2ClientKey"        `
}

func (x *CheckPassportMethodsActionResDto) RootObjectName() string {
	return "Abac"
}

type checkPassportMethodsActionImpSig func(
	q workspaces.QueryDSL) (*CheckPassportMethodsActionResDto,
	*workspaces.IError,
)

var CheckPassportMethodsActionImp checkPassportMethodsActionImpSig

func CheckPassportMethodsActionFn(
	q workspaces.QueryDSL,
) (
	*CheckPassportMethodsActionResDto,
	*workspaces.IError,
) {
	if CheckPassportMethodsActionImp == nil {
		return nil, nil
	}
	return CheckPassportMethodsActionImp(q)
}

var CheckPassportMethodsActionCmd cli.Command = cli.Command{
	Name:  "check-passport-methods",
	Usage: `Publicly available information to create the authentication form, and show users how they can signin or signup to the system. Based on the PassportMethod entities, it will compute the available methods for the user, considering their region (IP for example)`,
	Action: func(c *cli.Context) {
		query := workspaces.CommonCliQueryDSLBuilderAuthorize(c, CheckPassportMethodsSecurityModel)
		result, err := CheckPassportMethodsActionFn(query)
		workspaces.HandleActionInCli(c, result, err, map[string]map[string]string{})
	},
}
var QueryWorkspaceTypesPubliclySecurityModel *workspaces.SecurityModel = nil

type QueryWorkspaceTypesPubliclyActionResDto struct {
	Title       string `json:"title" yaml:"title"        `
	Description string `json:"description" yaml:"description"        `
	UniqueId    string `json:"uniqueId" yaml:"uniqueId"        `
	Slug        string `json:"slug" yaml:"slug"        `
}

func (x *QueryWorkspaceTypesPubliclyActionResDto) RootObjectName() string {
	return "Abac"
}

type queryWorkspaceTypesPubliclyActionImpSig func(
	q workspaces.QueryDSL) ([]*QueryWorkspaceTypesPubliclyActionResDto,
	*workspaces.QueryResultMeta,
	*workspaces.IError,
)

var QueryWorkspaceTypesPubliclyActionImp queryWorkspaceTypesPubliclyActionImpSig

func QueryWorkspaceTypesPubliclyActionFn(
	q workspaces.QueryDSL,
) (
	[]*QueryWorkspaceTypesPubliclyActionResDto,
	*workspaces.QueryResultMeta,
	*workspaces.IError,
) {
	if QueryWorkspaceTypesPubliclyActionImp == nil {
		return nil, nil, nil
	}
	return QueryWorkspaceTypesPubliclyActionImp(q)
}

var QueryWorkspaceTypesPubliclyActionCmd cli.Command = cli.Command{
	Name:  "public-types",
	Usage: `Returns the workspaces types available in the project publicly without authentication, and the value could be used upon signup to go different route.`,
	Flags: workspaces.CommonQueryFlags,
	Action: func(c *cli.Context) {
		query := workspaces.CommonCliQueryDSLBuilderAuthorize(c, QueryWorkspaceTypesPubliclySecurityModel)
		result, _, err := QueryWorkspaceTypesPubliclyActionFn(query)
		workspaces.HandleActionInCli(c, result, err, map[string]map[string]string{})
	},
}
var QueryUserRoleWorkspacesSecurityModel = &workspaces.SecurityModel{
	ActionRequires:  []workspaces.PermissionInfo{},
	ResolveStrategy: "user",
}

type QueryUserRoleWorkspacesActionResDto struct {
	Name string `json:"name" yaml:"name"        `
	// Workspace level capabilities which are available
	Capabilities []string                              `json:"capabilities" yaml:"capabilities"        `
	UniqueId     string                                `json:"uniqueId" yaml:"uniqueId"        `
	Roles        []*QueryUserRoleWorkspacesResDtoRoles `json:"roles" yaml:"roles"    gorm:"foreignKey:LinkerId;references:UniqueId;constraint:OnDelete:CASCADE"      `
}

func (x *QueryUserRoleWorkspacesActionResDto) RootObjectName() string {
	return "Abac"
}

type queryUserRoleWorkspacesActionImpSig func(
	q workspaces.QueryDSL) ([]*QueryUserRoleWorkspacesActionResDto,
	*workspaces.QueryResultMeta,
	*workspaces.IError,
)

var QueryUserRoleWorkspacesActionImp queryUserRoleWorkspacesActionImpSig

func QueryUserRoleWorkspacesActionFn(
	q workspaces.QueryDSL,
) (
	[]*QueryUserRoleWorkspacesActionResDto,
	*workspaces.QueryResultMeta,
	*workspaces.IError,
) {
	if QueryUserRoleWorkspacesActionImp == nil {
		return nil, nil, nil
	}
	return QueryUserRoleWorkspacesActionImp(q)
}

var QueryUserRoleWorkspacesActionCmd cli.Command = cli.Command{
	Name:  "urw",
	Usage: `Returns the workspaces that user belongs to, as well as his role in there, and the permissions for each role`,
	Flags: workspaces.CommonQueryFlags,
	Action: func(c *cli.Context) {
		query := workspaces.CommonCliQueryDSLBuilderAuthorize(c, QueryUserRoleWorkspacesSecurityModel)
		result, _, err := QueryUserRoleWorkspacesActionFn(query)
		workspaces.HandleActionInCli(c, result, err, map[string]map[string]string{})
	},
}
var ReactiveSearchSecurityModel *workspaces.SecurityModel = nil
var ReactiveSearchActionImp = workspaces.DefaultEmptyReactiveAction

// Reactive action does not have that
var ReactiveSearchActionCmd cli.Command = cli.Command{
	Name:  "reactive-search",
	Usage: `Reactive search is a general purpose search mechanism for different modules, and could be used in mobile apps or front-end to quickly search for a entity.`,
	Action: func(c *cli.Context) {
		query := workspaces.CommonCliQueryDSLBuilderAuthorize(c, ReactiveSearchSecurityModel)
		workspaces.CliReactivePipeHandler(query, ReactiveSearchActionImp)
	},
}
var ImportUserSecurityModel *workspaces.SecurityModel = nil

type ImportUserActionReqDto struct {
	Path string `json:"path" yaml:"path"        `
}

func (x *ImportUserActionReqDto) RootObjectName() string {
	return "Abac"
}

var ImportUserCommonCliFlagsOptional = []cli.Flag{
	&cli.StringFlag{
		Name:     "path",
		Required: false,
		Usage:    `path (string)`,
	},
}

func ImportUserActionReqValidator(dto *ImportUserActionReqDto) *workspaces.IError {
	err := workspaces.CommonStructValidatorPointer(dto, false)
	return err
}
func CastImportUserFromCli(c *cli.Context) *ImportUserActionReqDto {
	template := &ImportUserActionReqDto{}
	if c.IsSet("path") {
		template.Path = c.String("path")
	}
	return template
}

type importUserActionImpSig func(
	req *ImportUserActionReqDto,
	q workspaces.QueryDSL) (*OkayResponseDto,
	*workspaces.IError,
)

var ImportUserActionImp importUserActionImpSig

func ImportUserActionFn(
	req *ImportUserActionReqDto,
	q workspaces.QueryDSL,
) (
	*OkayResponseDto,
	*workspaces.IError,
) {
	if ImportUserActionImp == nil {
		return nil, nil
	}
	return ImportUserActionImp(req, q)
}

var ImportUserActionCmd cli.Command = cli.Command{
	Name:  "import-user",
	Usage: `Imports users, and creates their passports, and all details`,
	Flags: ImportUserCommonCliFlagsOptional,
	Action: func(c *cli.Context) {
		query := workspaces.CommonCliQueryDSLBuilderAuthorize(c, ImportUserSecurityModel)
		dto := CastImportUserFromCli(c)
		result, err := ImportUserActionFn(dto, query)
		workspaces.HandleActionInCli(c, result, err, map[string]map[string]string{})
	},
}
var SendEmailSecurityModel *workspaces.SecurityModel = nil

type SendEmailActionReqDto struct {
	ToAddress string `json:"toAddress" yaml:"toAddress"  validate:"required"        `
	Body      string `json:"body" yaml:"body"  validate:"required"        `
}

func (x *SendEmailActionReqDto) RootObjectName() string {
	return "Abac"
}

var SendEmailCommonCliFlagsOptional = []cli.Flag{
	&cli.StringFlag{
		Name:     "to-address",
		Required: true,
		Usage:    `toAddress (string)`,
	},
	&cli.StringFlag{
		Name:     "body",
		Required: true,
		Usage:    `body (string)`,
	},
}

func SendEmailActionReqValidator(dto *SendEmailActionReqDto) *workspaces.IError {
	err := workspaces.CommonStructValidatorPointer(dto, false)
	return err
}
func CastSendEmailFromCli(c *cli.Context) *SendEmailActionReqDto {
	template := &SendEmailActionReqDto{}
	if c.IsSet("to-address") {
		template.ToAddress = c.String("to-address")
	}
	if c.IsSet("body") {
		template.Body = c.String("body")
	}
	return template
}

type SendEmailActionResDto struct {
	QueueId string `json:"queueId" yaml:"queueId"        `
}

func (x *SendEmailActionResDto) RootObjectName() string {
	return "Abac"
}

type sendEmailActionImpSig func(
	req *SendEmailActionReqDto,
	q workspaces.QueryDSL) (*SendEmailActionResDto,
	*workspaces.IError,
)

var SendEmailActionImp sendEmailActionImpSig

func SendEmailActionFn(
	req *SendEmailActionReqDto,
	q workspaces.QueryDSL,
) (
	*SendEmailActionResDto,
	*workspaces.IError,
) {
	if SendEmailActionImp == nil {
		return nil, nil
	}
	return SendEmailActionImp(req, q)
}

var SendEmailActionCmd cli.Command = cli.Command{
	Name:  "email",
	Usage: `Send a email using default root notification configuration`,
	Flags: SendEmailCommonCliFlagsOptional,
	Action: func(c *cli.Context) {
		query := workspaces.CommonCliQueryDSLBuilderAuthorize(c, SendEmailSecurityModel)
		dto := CastSendEmailFromCli(c)
		result, err := SendEmailActionFn(dto, query)
		workspaces.HandleActionInCli(c, result, err, map[string]map[string]string{})
	},
}
var SendEmailWithProviderSecurityModel *workspaces.SecurityModel = nil

type SendEmailWithProviderActionReqDto struct {
	EmailProvider   *EmailProviderEntity `json:"emailProvider" yaml:"emailProvider"    gorm:"foreignKey:EmailProviderId;references:UniqueId"      `
	EmailProviderId workspaces.String    `json:"emailProviderId" yaml:"emailProviderId"`
	ToAddress       string               `json:"toAddress" yaml:"toAddress"  validate:"required"        `
	Body            string               `json:"body" yaml:"body"  validate:"required"        `
}

func (x *SendEmailWithProviderActionReqDto) RootObjectName() string {
	return "Abac"
}

var SendEmailWithProviderCommonCliFlagsOptional = []cli.Flag{
	&cli.StringFlag{
		Name:     "email-provider-id",
		Required: false,
		Usage:    `emailProvider (one)`,
	},
	&cli.StringFlag{
		Name:     "to-address",
		Required: true,
		Usage:    `toAddress (string)`,
	},
	&cli.StringFlag{
		Name:     "body",
		Required: true,
		Usage:    `body (string)`,
	},
}

func SendEmailWithProviderActionReqValidator(dto *SendEmailWithProviderActionReqDto) *workspaces.IError {
	err := workspaces.CommonStructValidatorPointer(dto, false)
	return err
}
func CastSendEmailWithProviderFromCli(c *cli.Context) *SendEmailWithProviderActionReqDto {
	template := &SendEmailWithProviderActionReqDto{}
	if c.IsSet("email-provider-id") {
		template.EmailProviderId = workspaces.NewStringAutoNull(c.String("email-provider-id"))
	}
	if c.IsSet("to-address") {
		template.ToAddress = c.String("to-address")
	}
	if c.IsSet("body") {
		template.Body = c.String("body")
	}
	return template
}

type SendEmailWithProviderActionResDto struct {
	QueueId string `json:"queueId" yaml:"queueId"        `
}

func (x *SendEmailWithProviderActionResDto) RootObjectName() string {
	return "Abac"
}

type sendEmailWithProviderActionImpSig func(
	req *SendEmailWithProviderActionReqDto,
	q workspaces.QueryDSL) (*SendEmailWithProviderActionResDto,
	*workspaces.IError,
)

var SendEmailWithProviderActionImp sendEmailWithProviderActionImpSig

func SendEmailWithProviderActionFn(
	req *SendEmailWithProviderActionReqDto,
	q workspaces.QueryDSL,
) (
	*SendEmailWithProviderActionResDto,
	*workspaces.IError,
) {
	if SendEmailWithProviderActionImp == nil {
		return nil, nil
	}
	return SendEmailWithProviderActionImp(req, q)
}

var SendEmailWithProviderActionCmd cli.Command = cli.Command{
	Name:  "emailp",
	Usage: `Send a text message using an specific gsm provider`,
	Flags: SendEmailWithProviderCommonCliFlagsOptional,
	Action: func(c *cli.Context) {
		query := workspaces.CommonCliQueryDSLBuilderAuthorize(c, SendEmailWithProviderSecurityModel)
		dto := CastSendEmailWithProviderFromCli(c)
		result, err := SendEmailWithProviderActionFn(dto, query)
		workspaces.HandleActionInCli(c, result, err, map[string]map[string]string{})
	},
}
var InviteToWorkspaceSecurityModel *workspaces.SecurityModel = nil

type inviteToWorkspaceActionImpSig func(
	req *WorkspaceInviteEntity,
	q workspaces.QueryDSL) (*WorkspaceInviteEntity,
	*workspaces.IError,
)

var InviteToWorkspaceActionImp inviteToWorkspaceActionImpSig

func InviteToWorkspaceActionFn(
	req *WorkspaceInviteEntity,
	q workspaces.QueryDSL,
) (
	*WorkspaceInviteEntity,
	*workspaces.IError,
) {
	if InviteToWorkspaceActionImp == nil {
		return nil, nil
	}
	return InviteToWorkspaceActionImp(req, q)
}

var InviteToWorkspaceActionCmd cli.Command = cli.Command{
	Name:  "invite",
	Usage: `Invite a new person (either a user, with passport or without passport)`,
	Flags: WorkspaceInviteCommonCliFlagsOptional,
	Action: func(c *cli.Context) {
		query := workspaces.CommonCliQueryDSLBuilderAuthorize(c, InviteToWorkspaceSecurityModel)
		dto := CastWorkspaceInviteFromCli(c)
		result, err := InviteToWorkspaceActionFn(dto, query)
		workspaces.HandleActionInCli(c, result, err, map[string]map[string]string{})
	},
}
var GsmSendSmsSecurityModel *workspaces.SecurityModel = nil

type GsmSendSmsActionReqDto struct {
	ToNumber string `json:"toNumber" yaml:"toNumber"  validate:"required"        `
	Body     string `json:"body" yaml:"body"  validate:"required"        `
}

func (x *GsmSendSmsActionReqDto) RootObjectName() string {
	return "Abac"
}

var GsmSendSmsCommonCliFlagsOptional = []cli.Flag{
	&cli.StringFlag{
		Name:     "to-number",
		Required: true,
		Usage:    `toNumber (string)`,
	},
	&cli.StringFlag{
		Name:     "body",
		Required: true,
		Usage:    `body (string)`,
	},
}

func GsmSendSmsActionReqValidator(dto *GsmSendSmsActionReqDto) *workspaces.IError {
	err := workspaces.CommonStructValidatorPointer(dto, false)
	return err
}
func CastGsmSendSmsFromCli(c *cli.Context) *GsmSendSmsActionReqDto {
	template := &GsmSendSmsActionReqDto{}
	if c.IsSet("to-number") {
		template.ToNumber = c.String("to-number")
	}
	if c.IsSet("body") {
		template.Body = c.String("body")
	}
	return template
}

type GsmSendSmsActionResDto struct {
	QueueId string `json:"queueId" yaml:"queueId"        `
}

func (x *GsmSendSmsActionResDto) RootObjectName() string {
	return "Abac"
}

type gsmSendSmsActionImpSig func(
	req *GsmSendSmsActionReqDto,
	q workspaces.QueryDSL) (*GsmSendSmsActionResDto,
	*workspaces.IError,
)

var GsmSendSmsActionImp gsmSendSmsActionImpSig

func GsmSendSmsActionFn(
	req *GsmSendSmsActionReqDto,
	q workspaces.QueryDSL,
) (
	*GsmSendSmsActionResDto,
	*workspaces.IError,
) {
	if GsmSendSmsActionImp == nil {
		return nil, nil
	}
	return GsmSendSmsActionImp(req, q)
}

var GsmSendSmsActionCmd cli.Command = cli.Command{
	Name:  "sms",
	Usage: `Send a text message using default root notification configuration`,
	Flags: GsmSendSmsCommonCliFlagsOptional,
	Action: func(c *cli.Context) {
		query := workspaces.CommonCliQueryDSLBuilderAuthorize(c, GsmSendSmsSecurityModel)
		dto := CastGsmSendSmsFromCli(c)
		result, err := GsmSendSmsActionFn(dto, query)
		workspaces.HandleActionInCli(c, result, err, map[string]map[string]string{})
	},
}
var GsmSendSmsWithProviderSecurityModel *workspaces.SecurityModel = nil

type GsmSendSmsWithProviderActionReqDto struct {
	GsmProvider   *GsmProviderEntity `json:"gsmProvider" yaml:"gsmProvider"    gorm:"foreignKey:GsmProviderId;references:UniqueId"      `
	GsmProviderId workspaces.String  `json:"gsmProviderId" yaml:"gsmProviderId"`
	ToNumber      string             `json:"toNumber" yaml:"toNumber"  validate:"required"        `
	Body          string             `json:"body" yaml:"body"  validate:"required"        `
}

func (x *GsmSendSmsWithProviderActionReqDto) RootObjectName() string {
	return "Abac"
}

var GsmSendSmsWithProviderCommonCliFlagsOptional = []cli.Flag{
	&cli.StringFlag{
		Name:     "gsm-provider-id",
		Required: false,
		Usage:    `gsmProvider (one)`,
	},
	&cli.StringFlag{
		Name:     "to-number",
		Required: true,
		Usage:    `toNumber (string)`,
	},
	&cli.StringFlag{
		Name:     "body",
		Required: true,
		Usage:    `body (string)`,
	},
}

func GsmSendSmsWithProviderActionReqValidator(dto *GsmSendSmsWithProviderActionReqDto) *workspaces.IError {
	err := workspaces.CommonStructValidatorPointer(dto, false)
	return err
}
func CastGsmSendSmsWithProviderFromCli(c *cli.Context) *GsmSendSmsWithProviderActionReqDto {
	template := &GsmSendSmsWithProviderActionReqDto{}
	if c.IsSet("gsm-provider-id") {
		template.GsmProviderId = workspaces.NewStringAutoNull(c.String("gsm-provider-id"))
	}
	if c.IsSet("to-number") {
		template.ToNumber = c.String("to-number")
	}
	if c.IsSet("body") {
		template.Body = c.String("body")
	}
	return template
}

type GsmSendSmsWithProviderActionResDto struct {
	QueueId string `json:"queueId" yaml:"queueId"        `
}

func (x *GsmSendSmsWithProviderActionResDto) RootObjectName() string {
	return "Abac"
}

type gsmSendSmsWithProviderActionImpSig func(
	req *GsmSendSmsWithProviderActionReqDto,
	q workspaces.QueryDSL) (*GsmSendSmsWithProviderActionResDto,
	*workspaces.IError,
)

var GsmSendSmsWithProviderActionImp gsmSendSmsWithProviderActionImpSig

func GsmSendSmsWithProviderActionFn(
	req *GsmSendSmsWithProviderActionReqDto,
	q workspaces.QueryDSL,
) (
	*GsmSendSmsWithProviderActionResDto,
	*workspaces.IError,
) {
	if GsmSendSmsWithProviderActionImp == nil {
		return nil, nil
	}
	return GsmSendSmsWithProviderActionImp(req, q)
}

var GsmSendSmsWithProviderActionCmd cli.Command = cli.Command{
	Name:  "smsp",
	Usage: `Send a text message using an specific gsm provider`,
	Flags: GsmSendSmsWithProviderCommonCliFlagsOptional,
	Action: func(c *cli.Context) {
		query := workspaces.CommonCliQueryDSLBuilderAuthorize(c, GsmSendSmsWithProviderSecurityModel)
		dto := CastGsmSendSmsWithProviderFromCli(c)
		result, err := GsmSendSmsWithProviderActionFn(dto, query)
		workspaces.HandleActionInCli(c, result, err, map[string]map[string]string{})
	},
}
var ClassicSigninSecurityModel *workspaces.SecurityModel = nil

type ClassicSigninActionReqDto struct {
	Value    string `json:"value" yaml:"value"  validate:"required"        `
	Password string `json:"password" yaml:"password"  validate:"required"        `
	// Accepts login with totp code. If enabled, first login would return a success response with next[enter-totp] value and ui can understand that user needs to be navigated into the screen other screen.
	TotpCode string `json:"totpCode" yaml:"totpCode"        `
	// Session secret when logging in to the application requires more steps to complete.
	SessionSecret string `json:"sessionSecret" yaml:"sessionSecret"        `
}

func (x *ClassicSigninActionReqDto) RootObjectName() string {
	return "Abac"
}

var ClassicSigninCommonCliFlagsOptional = []cli.Flag{
	&cli.StringFlag{
		Name:     "value",
		Required: true,
		Usage:    `value (string)`,
	},
	&cli.StringFlag{
		Name:     "password",
		Required: true,
		Usage:    `password (string)`,
	},
	&cli.StringFlag{
		Name:     "totp-code",
		Required: false,
		Usage:    `Accepts login with totp code. If enabled, first login would return a success response with next[enter-totp] value and ui can understand that user needs to be navigated into the screen other screen. (string)`,
	},
	&cli.StringFlag{
		Name:     "session-secret",
		Required: false,
		Usage:    `Session secret when logging in to the application requires more steps to complete. (string)`,
	},
}

func ClassicSigninActionReqValidator(dto *ClassicSigninActionReqDto) *workspaces.IError {
	err := workspaces.CommonStructValidatorPointer(dto, false)
	return err
}
func CastClassicSigninFromCli(c *cli.Context) *ClassicSigninActionReqDto {
	template := &ClassicSigninActionReqDto{}
	if c.IsSet("value") {
		template.Value = c.String("value")
	}
	if c.IsSet("password") {
		template.Password = c.String("password")
	}
	if c.IsSet("totp-code") {
		template.TotpCode = c.String("totp-code")
	}
	if c.IsSet("session-secret") {
		template.SessionSecret = c.String("session-secret")
	}
	return template
}

type ClassicSigninActionResDto struct {
	Session   *UserSessionDto   `json:"session" yaml:"session"    gorm:"foreignKey:SessionId;references:UniqueId"      `
	SessionId workspaces.String `json:"sessionId" yaml:"sessionId"`
	// The next possible action which is suggested.
	Next []string `json:"next" yaml:"next"        `
	// In case the account doesn't have totp, but enforced by installation, this value will contain the link
	TotpUrl string `json:"totpUrl" yaml:"totpUrl"        `
	// Returns a secret session if the authentication requires more steps.
	SessionSecret string `json:"sessionSecret" yaml:"sessionSecret"        `
}

func (x *ClassicSigninActionResDto) RootObjectName() string {
	return "Abac"
}

type classicSigninActionImpSig func(
	req *ClassicSigninActionReqDto,
	q workspaces.QueryDSL) (*ClassicSigninActionResDto,
	*workspaces.IError,
)

var ClassicSigninActionImp classicSigninActionImpSig

func ClassicSigninActionFn(
	req *ClassicSigninActionReqDto,
	q workspaces.QueryDSL,
) (
	*ClassicSigninActionResDto,
	*workspaces.IError,
) {
	if ClassicSigninActionImp == nil {
		return nil, nil
	}
	return ClassicSigninActionImp(req, q)
}

var ClassicSigninActionCmd cli.Command = cli.Command{
	Name:  "in",
	Usage: `Signin publicly to and account using class passports (email, password)`,
	Flags: ClassicSigninCommonCliFlagsOptional,
	Action: func(c *cli.Context) {
		query := workspaces.CommonCliQueryDSLBuilderAuthorize(c, ClassicSigninSecurityModel)
		dto := CastClassicSigninFromCli(c)
		result, err := ClassicSigninActionFn(dto, query)
		workspaces.HandleActionInCli(c, result, err, map[string]map[string]string{})
	},
}
var ClassicSignupSecurityModel *workspaces.SecurityModel = nil

type ClassicSignupActionReqDto struct {
	Value string `json:"value" yaml:"value"  validate:"required"        `
	// Required when the account creation requires recaptcha, or otp approval first. If such requirements are there, you first need to follow the otp apis, get the session secret and pass it here to complete the setup.
	SessionSecret   string            `json:"sessionSecret" yaml:"sessionSecret"        `
	Type            string            `json:"type" yaml:"type"  validate:"required"        `
	Password        string            `json:"password" yaml:"password"  validate:"required"        `
	FirstName       string            `json:"firstName" yaml:"firstName"  validate:"required"        `
	LastName        string            `json:"lastName" yaml:"lastName"  validate:"required"        `
	InviteId        workspaces.String `json:"inviteId" yaml:"inviteId"        `
	PublicJoinKeyId workspaces.String `json:"publicJoinKeyId" yaml:"publicJoinKeyId"        `
	WorkspaceTypeId workspaces.String `json:"workspaceTypeId" yaml:"workspaceTypeId"  validate:"required"        `
}

func (x *ClassicSignupActionReqDto) RootObjectName() string {
	return "Abac"
}

var ClassicSignupCommonCliFlagsOptional = []cli.Flag{
	&cli.StringFlag{
		Name:     "value",
		Required: true,
		Usage:    `value (string)`,
	},
	&cli.StringFlag{
		Name:     "session-secret",
		Required: false,
		Usage:    `Required when the account creation requires recaptcha, or otp approval first. If such requirements are there, you first need to follow the otp apis, get the session secret and pass it here to complete the setup. (string)`,
	},
	&cli.StringFlag{
		Name:     "type",
		Required: true,
		Usage:    `One of: 'phonenumber', 'email' (enum)`,
	},
	&cli.StringFlag{
		Name:     "password",
		Required: true,
		Usage:    `password (string)`,
	},
	&cli.StringFlag{
		Name:     "first-name",
		Required: true,
		Usage:    `firstName (string)`,
	},
	&cli.StringFlag{
		Name:     "last-name",
		Required: true,
		Usage:    `lastName (string)`,
	},
	&cli.StringFlag{
		Name:     "invite-id",
		Required: false,
		Usage:    `inviteId (string?)`,
	},
	&cli.StringFlag{
		Name:     "public-join-key-id",
		Required: false,
		Usage:    `publicJoinKeyId (string?)`,
	},
	&cli.StringFlag{
		Name:     "workspace-type-id",
		Required: true,
		Usage:    `workspaceTypeId (string?)`,
	},
}

func ClassicSignupActionReqValidator(dto *ClassicSignupActionReqDto) *workspaces.IError {
	err := workspaces.CommonStructValidatorPointer(dto, false)
	return err
}
func CastClassicSignupFromCli(c *cli.Context) *ClassicSignupActionReqDto {
	template := &ClassicSignupActionReqDto{}
	if c.IsSet("value") {
		template.Value = c.String("value")
	}
	if c.IsSet("session-secret") {
		template.SessionSecret = c.String("session-secret")
	}
	if c.IsSet("type") {
		template.Type = c.String("type")
	}
	if c.IsSet("password") {
		template.Password = c.String("password")
	}
	if c.IsSet("first-name") {
		template.FirstName = c.String("first-name")
	}
	if c.IsSet("last-name") {
		template.LastName = c.String("last-name")
	}
	if c.IsSet("invite-id") {
		template.InviteId = workspaces.NewStringAutoNull(c.String("invite-id"))
	}
	if c.IsSet("public-join-key-id") {
		template.PublicJoinKeyId = workspaces.NewStringAutoNull(c.String("public-join-key-id"))
	}
	if c.IsSet("workspace-type-id") {
		template.WorkspaceTypeId = workspaces.NewStringAutoNull(c.String("workspace-type-id"))
	}
	return template
}

type ClassicSignupActionResDto struct {
	// Returns the user session in case that signup is completely successful.
	Session   *UserSessionDto   `json:"session" yaml:"session"    gorm:"foreignKey:SessionId;references:UniqueId"      `
	SessionId workspaces.String `json:"sessionId" yaml:"sessionId"`
	// If time based otp is available, we add it response to make it easier for ui.
	TotpUrl string `json:"totpUrl" yaml:"totpUrl"        `
	// Returns true and session will be empty if, the totp is required by the installation. In such scenario, you need to forward user to setup totp screen.
	ContinueToTotp bool `json:"continueToTotp" yaml:"continueToTotp"        `
	// Determines if user must complete totp in order to continue based on workspace or installation
	ForcedTotp bool `json:"forcedTotp" yaml:"forcedTotp"        `
}

func (x *ClassicSignupActionResDto) RootObjectName() string {
	return "Abac"
}

type classicSignupActionImpSig func(
	req *ClassicSignupActionReqDto,
	q workspaces.QueryDSL) (*ClassicSignupActionResDto,
	*workspaces.IError,
)

var ClassicSignupActionImp classicSignupActionImpSig

func ClassicSignupActionFn(
	req *ClassicSignupActionReqDto,
	q workspaces.QueryDSL,
) (
	*ClassicSignupActionResDto,
	*workspaces.IError,
) {
	if ClassicSignupActionImp == nil {
		return nil, nil
	}
	return ClassicSignupActionImp(req, q)
}

var ClassicSignupActionCmd cli.Command = cli.Command{
	Name:  "up",
	Usage: `Signup a user into system via public access (aka website visitors) using either email or phone number.`,
	Flags: ClassicSignupCommonCliFlagsOptional,
	Action: func(c *cli.Context) {
		query := workspaces.CommonCliQueryDSLBuilderAuthorize(c, ClassicSignupSecurityModel)
		dto := CastClassicSignupFromCli(c)
		result, err := ClassicSignupActionFn(dto, query)
		workspaces.HandleActionInCli(c, result, err, map[string]map[string]string{})
	},
}
var CreateWorkspaceSecurityModel *workspaces.SecurityModel = nil

type CreateWorkspaceActionReqDto struct {
	Name        string            `json:"name" yaml:"name"        `
	Workspace   *WorkspaceEntity  `json:"workspace" yaml:"workspace"    gorm:"foreignKey:WorkspaceId;references:UniqueId"      `
	WorkspaceId workspaces.String `json:"workspaceId" yaml:"workspaceId"        `
}

func (x *CreateWorkspaceActionReqDto) RootObjectName() string {
	return "Abac"
}

var CreateWorkspaceCommonCliFlagsOptional = []cli.Flag{
	&cli.StringFlag{
		Name:     "name",
		Required: false,
		Usage:    `name (string)`,
	},
	&cli.StringFlag{
		Name:     "workspace-id",
		Required: false,
		Usage:    `workspace (one)`,
	},
	&cli.StringFlag{
		Name:     "workspace-id",
		Required: false,
		Usage:    `workspaceId (string?)`,
	},
}

func CreateWorkspaceActionReqValidator(dto *CreateWorkspaceActionReqDto) *workspaces.IError {
	err := workspaces.CommonStructValidatorPointer(dto, false)
	return err
}
func CastCreateWorkspaceFromCli(c *cli.Context) *CreateWorkspaceActionReqDto {
	template := &CreateWorkspaceActionReqDto{}
	if c.IsSet("name") {
		template.Name = c.String("name")
	}
	if c.IsSet("workspace-id") {
		template.WorkspaceId = workspaces.NewStringAutoNull(c.String("workspace-id"))
	}
	if c.IsSet("workspace-id") {
		template.WorkspaceId = workspaces.NewStringAutoNull(c.String("workspace-id"))
	}
	return template
}

type createWorkspaceActionImpSig func(
	req *CreateWorkspaceActionReqDto,
	q workspaces.QueryDSL) (*WorkspaceEntity,
	*workspaces.IError,
)

var CreateWorkspaceActionImp createWorkspaceActionImpSig

func CreateWorkspaceActionFn(
	req *CreateWorkspaceActionReqDto,
	q workspaces.QueryDSL,
) (
	*WorkspaceEntity,
	*workspaces.IError,
) {
	if CreateWorkspaceActionImp == nil {
		return nil, nil
	}
	return CreateWorkspaceActionImp(req, q)
}

var CreateWorkspaceActionCmd cli.Command = cli.Command{
	Name:  "create-workspace",
	Usage: ``,
	Flags: CreateWorkspaceCommonCliFlagsOptional,
	Action: func(c *cli.Context) {
		query := workspaces.CommonCliQueryDSLBuilderAuthorize(c, CreateWorkspaceSecurityModel)
		dto := CastCreateWorkspaceFromCli(c)
		result, err := CreateWorkspaceActionFn(dto, query)
		workspaces.HandleActionInCli(c, result, err, map[string]map[string]string{})
	},
}
var CheckClassicPassportSecurityModel *workspaces.SecurityModel = nil

type CheckClassicPassportActionReqDto struct {
	Value string `json:"value" yaml:"value"  validate:"required"        `
	// This can be the value of recaptcha2, recaptch3, or generate security image or voice for verification. Will be used based on the configuration.
	SecurityToken string `json:"securityToken" yaml:"securityToken"        `
}

func (x *CheckClassicPassportActionReqDto) RootObjectName() string {
	return "Abac"
}

var CheckClassicPassportCommonCliFlagsOptional = []cli.Flag{
	&cli.StringFlag{
		Name:     "value",
		Required: true,
		Usage:    `value (string)`,
	},
	&cli.StringFlag{
		Name:     "security-token",
		Required: false,
		Usage:    `This can be the value of recaptcha2, recaptch3, or generate security image or voice for verification. Will be used based on the configuration. (string)`,
	},
}

func CheckClassicPassportActionReqValidator(dto *CheckClassicPassportActionReqDto) *workspaces.IError {
	err := workspaces.CommonStructValidatorPointer(dto, false)
	return err
}
func CastCheckClassicPassportFromCli(c *cli.Context) *CheckClassicPassportActionReqDto {
	template := &CheckClassicPassportActionReqDto{}
	if c.IsSet("value") {
		template.Value = c.String("value")
	}
	if c.IsSet("security-token") {
		template.SecurityToken = c.String("security-token")
	}
	return template
}

type CheckClassicPassportActionResDto struct {
	// The next possible action which is suggested.
	Next []string `json:"next" yaml:"next"        `
	// Extra information that can be useful actually when doing onboarding. Make sure sensetive information doesn't go out.
	Flags []string `json:"flags" yaml:"flags"        `
	// If the endpoint automatically triggers a send otp, then it would be holding that information, Also the otp information can become available.
	OtpInfo *CheckClassicPassportResDtoOtpInfo `json:"otpInfo" yaml:"otpInfo"    gorm:"foreignKey:LinkerId;references:UniqueId;constraint:OnDelete:CASCADE"      `
}

func (x *CheckClassicPassportActionResDto) RootObjectName() string {
	return "Abac"
}

type checkClassicPassportActionImpSig func(
	req *CheckClassicPassportActionReqDto,
	q workspaces.QueryDSL) (*CheckClassicPassportActionResDto,
	*workspaces.IError,
)

var CheckClassicPassportActionImp checkClassicPassportActionImpSig

func CheckClassicPassportActionFn(
	req *CheckClassicPassportActionReqDto,
	q workspaces.QueryDSL,
) (
	*CheckClassicPassportActionResDto,
	*workspaces.IError,
) {
	if CheckClassicPassportActionImp == nil {
		return nil, nil
	}
	return CheckClassicPassportActionImp(req, q)
}

var CheckClassicPassportActionCmd cli.Command = cli.Command{
	Name:  "ccp",
	Usage: `Checks if a classic passport (email, phone) exists or not, used in multi step authentication`,
	Flags: CheckClassicPassportCommonCliFlagsOptional,
	Action: func(c *cli.Context) {
		query := workspaces.CommonCliQueryDSLBuilderAuthorize(c, CheckClassicPassportSecurityModel)
		dto := CastCheckClassicPassportFromCli(c)
		result, err := CheckClassicPassportActionFn(dto, query)
		workspaces.HandleActionInCli(c, result, err, map[string]map[string]string{})
	},
}
var ClassicPassportOtpSecurityModel *workspaces.SecurityModel = nil

type ClassicPassportOtpActionReqDto struct {
	Value string `json:"value" yaml:"value"  validate:"required"        `
	Otp   string `json:"otp" yaml:"otp"  validate:"required"        `
}

func (x *ClassicPassportOtpActionReqDto) RootObjectName() string {
	return "Abac"
}

var ClassicPassportOtpCommonCliFlagsOptional = []cli.Flag{
	&cli.StringFlag{
		Name:     "value",
		Required: true,
		Usage:    `value (string)`,
	},
	&cli.StringFlag{
		Name:     "otp",
		Required: true,
		Usage:    `otp (string)`,
	},
}

func ClassicPassportOtpActionReqValidator(dto *ClassicPassportOtpActionReqDto) *workspaces.IError {
	err := workspaces.CommonStructValidatorPointer(dto, false)
	return err
}
func CastClassicPassportOtpFromCli(c *cli.Context) *ClassicPassportOtpActionReqDto {
	template := &ClassicPassportOtpActionReqDto{}
	if c.IsSet("value") {
		template.Value = c.String("value")
	}
	if c.IsSet("otp") {
		template.Otp = c.String("otp")
	}
	return template
}

type ClassicPassportOtpActionResDto struct {
	Session   *UserSessionDto   `json:"session" yaml:"session"    gorm:"foreignKey:SessionId;references:UniqueId"      `
	SessionId workspaces.String `json:"sessionId" yaml:"sessionId"`
	// If time based otp is available, we add it response to make it easier for ui.
	TotpUrl string `json:"totpUrl" yaml:"totpUrl"        `
	// The session secret will be used to call complete user registeration api.
	SessionSecret string `json:"sessionSecret" yaml:"sessionSecret"        `
	// If return true, means the OTP is correct and user needs to be created before continue the authentication processs.
	ContinueWithCreation bool `json:"continueWithCreation" yaml:"continueWithCreation"        `
}

func (x *ClassicPassportOtpActionResDto) RootObjectName() string {
	return "Abac"
}

type classicPassportOtpActionImpSig func(
	req *ClassicPassportOtpActionReqDto,
	q workspaces.QueryDSL) (*ClassicPassportOtpActionResDto,
	*workspaces.IError,
)

var ClassicPassportOtpActionImp classicPassportOtpActionImpSig

func ClassicPassportOtpActionFn(
	req *ClassicPassportOtpActionReqDto,
	q workspaces.QueryDSL,
) (
	*ClassicPassportOtpActionResDto,
	*workspaces.IError,
) {
	if ClassicPassportOtpActionImp == nil {
		return nil, nil
	}
	return ClassicPassportOtpActionImp(req, q)
}

var ClassicPassportOtpActionCmd cli.Command = cli.Command{
	Name:  "otp",
	Usage: `Authenticate the user publicly for classic methods using communication service, such as sms, call, or email. You need to call classicPassportRequestOtp beforehand to send a otp code, and then validate it with this API. Also checkClassicPassport action might already sent the otp, so make sure you don't send it twice.`,
	Flags: ClassicPassportOtpCommonCliFlagsOptional,
	Action: func(c *cli.Context) {
		query := workspaces.CommonCliQueryDSLBuilderAuthorize(c, ClassicPassportOtpSecurityModel)
		dto := CastClassicPassportOtpFromCli(c)
		result, err := ClassicPassportOtpActionFn(dto, query)
		workspaces.HandleActionInCli(c, result, err, map[string]map[string]string{})
	},
}
var ClassicPassportRequestOtpSecurityModel *workspaces.SecurityModel = nil

type ClassicPassportRequestOtpActionReqDto struct {
	// Passport value (email, phone number) which would be recieving the otp code.
	Value string `json:"value" yaml:"value"  validate:"required"        `
}

func (x *ClassicPassportRequestOtpActionReqDto) RootObjectName() string {
	return "Abac"
}

var ClassicPassportRequestOtpCommonCliFlagsOptional = []cli.Flag{
	&cli.StringFlag{
		Name:     "value",
		Required: true,
		Usage:    `Passport value (email, phone number) which would be recieving the otp code. (string)`,
	},
}

func ClassicPassportRequestOtpActionReqValidator(dto *ClassicPassportRequestOtpActionReqDto) *workspaces.IError {
	err := workspaces.CommonStructValidatorPointer(dto, false)
	return err
}
func CastClassicPassportRequestOtpFromCli(c *cli.Context) *ClassicPassportRequestOtpActionReqDto {
	template := &ClassicPassportRequestOtpActionReqDto{}
	if c.IsSet("value") {
		template.Value = c.String("value")
	}
	return template
}

type ClassicPassportRequestOtpActionResDto struct {
	SuspendUntil int64 `json:"suspendUntil" yaml:"suspendUntil"        `
	ValidUntil   int64 `json:"validUntil" yaml:"validUntil"        `
	BlockedUntil int64 `json:"blockedUntil" yaml:"blockedUntil"        `
	// The amount of time left to unblock for next request
	SecondsToUnblock int64 `json:"secondsToUnblock" yaml:"secondsToUnblock"        `
}

func (x *ClassicPassportRequestOtpActionResDto) RootObjectName() string {
	return "Abac"
}

type classicPassportRequestOtpActionImpSig func(
	req *ClassicPassportRequestOtpActionReqDto,
	q workspaces.QueryDSL) (*ClassicPassportRequestOtpActionResDto,
	*workspaces.IError,
)

var ClassicPassportRequestOtpActionImp classicPassportRequestOtpActionImpSig

func ClassicPassportRequestOtpActionFn(
	req *ClassicPassportRequestOtpActionReqDto,
	q workspaces.QueryDSL,
) (
	*ClassicPassportRequestOtpActionResDto,
	*workspaces.IError,
) {
	if ClassicPassportRequestOtpActionImp == nil {
		return nil, nil
	}
	return ClassicPassportRequestOtpActionImp(req, q)
}

var ClassicPassportRequestOtpActionCmd cli.Command = cli.Command{
	Name:  "otp-request",
	Usage: `Triggers an otp request, and will send an sms or email to the passport. This endpoint is not used for login, but rather makes a request at initial step. Later you can call classicPassportOtp to get in.`,
	Flags: ClassicPassportRequestOtpCommonCliFlagsOptional,
	Action: func(c *cli.Context) {
		query := workspaces.CommonCliQueryDSLBuilderAuthorize(c, ClassicPassportRequestOtpSecurityModel)
		dto := CastClassicPassportRequestOtpFromCli(c)
		result, err := ClassicPassportRequestOtpActionFn(dto, query)
		workspaces.HandleActionInCli(c, result, err, map[string]map[string]string{})
	},
}

func AbacCustomActions() []workspaces.Module3Action {
	routes := []workspaces.Module3Action{
		{
			Method:        "POST",
			Url:           "/user/invitation/accept",
			SecurityModel: AcceptInviteSecurityModel,
			Name:          "acceptInvite",
			Description:   "Use it when user accepts an invitation, and it will complete the joining process",
			Handlers: []gin.HandlerFunc{
				func(c *gin.Context) {
					// POST_ONE - post
					workspaces.HttpPostEntity(c, AcceptInviteActionFn)
				},
			},
			Format:         "POST_ONE",
			Action:         AcceptInviteActionFn,
			ResponseEntity: string(""),
			Out: &workspaces.Module3ActionBody{
				Entity: "",
			},
			RequestEntity: &AcceptInviteActionReqDto{},
			In: &workspaces.Module3ActionBody{
				Entity: "AcceptInviteActionReqDto",
			},
		},
		{
			Method:        "POST",
			Url:           "/passport/via-oauth",
			SecurityModel: OauthAuthenticateSecurityModel,
			Name:          "oauthAuthenticate",
			Description:   "When a token is got from a oauth service such as google, we send the token here to authenticate the user. To me seems this doesn't need to have 2FA or anything, so we return the session directly, or maybe there needs to be next step.",
			Handlers: []gin.HandlerFunc{
				func(c *gin.Context) {
					// POST_ONE - post
					workspaces.HttpPostEntity(c, OauthAuthenticateActionFn)
				},
			},
			Format:         "POST_ONE",
			Action:         OauthAuthenticateActionFn,
			ResponseEntity: &OauthAuthenticateActionResDto{},
			Out: &workspaces.Module3ActionBody{
				Entity: "OauthAuthenticateActionResDto",
			},
			RequestEntity: &OauthAuthenticateActionReqDto{},
			In: &workspaces.Module3ActionBody{
				Entity: "OauthAuthenticateActionReqDto",
			},
		},
		{
			Method:        "GET",
			Url:           "/user/passports",
			SecurityModel: UserPassportsSecurityModel,
			Name:          "userPassports",
			Description:   "Returns list of passports belongs to an specific user.",
			Handlers: []gin.HandlerFunc{
				func(c *gin.Context) {
					// QUERY - get
					workspaces.HttpQueryEntity2(c, UserPassportsActionFn)
				},
			},
			Format:         "QUERY",
			Action:         UserPassportsActionFn,
			ResponseEntity: &UserPassportsActionResDto{},
			Out: &workspaces.Module3ActionBody{
				Entity: "UserPassportsActionResDto",
			},
		},
		{
			Method:        "POST",
			Url:           "/passport/change-password",
			SecurityModel: ChangePasswordSecurityModel,
			Name:          "changePassword",
			Description:   "Change the password for a given passport of the user. User needs to be authenticated in order to be able to change the password for a given account.",
			Handlers: []gin.HandlerFunc{
				func(c *gin.Context) {
					// POST_ONE - post
					workspaces.HttpPostEntity(c, ChangePasswordActionFn)
				},
			},
			Format:         "POST_ONE",
			Action:         ChangePasswordActionFn,
			ResponseEntity: string(""),
			Out: &workspaces.Module3ActionBody{
				Entity: "",
			},
			RequestEntity: &ChangePasswordActionReqDto{},
			In: &workspaces.Module3ActionBody{
				Entity: "ChangePasswordActionReqDto",
			},
		},
		{
			Method:        "GET",
			Url:           "/users/invitations",
			SecurityModel: UserInvitationsSecurityModel,
			Name:          "userInvitations",
			Description:   "Shows the invitations for an specific user, if the invited member already has a account. It's based on the passports, so if the passport is authenticated we will show them.",
			Handlers: []gin.HandlerFunc{
				func(c *gin.Context) {
					// QUERY - get
					workspaces.HttpQueryEntity2(c, UserInvitationsActionFn)
				},
			},
			Format:         "QUERY",
			Action:         UserInvitationsActionFn,
			ResponseEntity: &UserInvitationsQueryColumns{},
			Out: &workspaces.Module3ActionBody{
				Entity: "UserInvitationsQueryColumns",
			},
		},
		{
			Method:        "POST",
			Url:           "/passport/totp/confirm",
			SecurityModel: ConfirmClassicPassportTotpSecurityModel,
			Name:          "confirmClassicPassportTotp",
			Description:   "When user requires to setup the totp for an specifc passport, they can use this endpoint to confirm it.",
			Handlers: []gin.HandlerFunc{
				func(c *gin.Context) {
					// POST_ONE - post
					workspaces.HttpPostEntity(c, ConfirmClassicPassportTotpActionFn)
				},
			},
			Format:         "POST_ONE",
			Action:         ConfirmClassicPassportTotpActionFn,
			ResponseEntity: &ConfirmClassicPassportTotpActionResDto{},
			Out: &workspaces.Module3ActionBody{
				Entity: "ConfirmClassicPassportTotpActionResDto",
			},
			RequestEntity: &ConfirmClassicPassportTotpActionReqDto{},
			In: &workspaces.Module3ActionBody{
				Entity: "ConfirmClassicPassportTotpActionReqDto",
			},
		},
		{
			Method:        "GET",
			Url:           "/passports/available-methods",
			SecurityModel: CheckPassportMethodsSecurityModel,
			Name:          "checkPassportMethods",
			Description:   "Publicly available information to create the authentication form, and show users how they can signin or signup to the system. Based on the PassportMethod entities, it will compute the available methods for the user, considering their region (IP for example)",
			Handlers: []gin.HandlerFunc{
				func(c *gin.Context) {
					// GET_ONE - get
					workspaces.HttpGetEntity(c, CheckPassportMethodsActionFn)
				},
			},
			Format:         "GET_ONE",
			Action:         CheckPassportMethodsActionFn,
			ResponseEntity: &CheckPassportMethodsActionResDto{},
			Out: &workspaces.Module3ActionBody{
				Entity: "CheckPassportMethodsActionResDto",
			},
		},
		{
			Method:        "GET",
			Url:           "/workspace/public/types",
			SecurityModel: QueryWorkspaceTypesPubliclySecurityModel,
			Name:          "queryWorkspaceTypesPublicly",
			Description:   "Returns the workspaces types available in the project publicly without authentication, and the value could be used upon signup to go different route.",
			Handlers: []gin.HandlerFunc{
				func(c *gin.Context) {
					// QUERY - get
					workspaces.HttpQueryEntity2(c, QueryWorkspaceTypesPubliclyActionFn)
				},
			},
			Format:         "QUERY",
			Action:         QueryWorkspaceTypesPubliclyActionFn,
			ResponseEntity: &QueryWorkspaceTypesPubliclyActionResDto{},
			Out: &workspaces.Module3ActionBody{
				Entity: "QueryWorkspaceTypesPubliclyActionResDto",
			},
		},
		{
			Method:        "GET",
			Url:           "/urw/query",
			SecurityModel: QueryUserRoleWorkspacesSecurityModel,
			Name:          "queryUserRoleWorkspaces",
			Description:   "Returns the workspaces that user belongs to, as well as his role in there, and the permissions for each role",
			Handlers: []gin.HandlerFunc{
				func(c *gin.Context) {
					// QUERY - get
					workspaces.HttpQueryEntity2(c, QueryUserRoleWorkspacesActionFn)
				},
			},
			Format:         "QUERY",
			Action:         QueryUserRoleWorkspacesActionFn,
			ResponseEntity: &QueryUserRoleWorkspacesActionResDto{},
			Out: &workspaces.Module3ActionBody{
				Entity: "QueryUserRoleWorkspacesActionResDto",
			},
		},
		{
			Method:        "REACTIVE",
			Url:           "reactive-search",
			SecurityModel: ReactiveSearchSecurityModel,
			Name:          "reactiveSearch",
			Description:   "Reactive search is a general purpose search mechanism for different modules, and could be used in mobile apps or front-end to quickly search for a entity.",
			Handlers: []gin.HandlerFunc{
				workspaces.ReactiveSocketHandler(ReactiveSearchActionImp),
			},
			Format:         "REACTIVE",
			ResponseEntity: string(""),
			Out: &workspaces.Module3ActionBody{
				Entity: "",
			},
		},
		{
			Method:        "POST",
			Url:           "/user/import",
			SecurityModel: ImportUserSecurityModel,
			Name:          "importUser",
			Description:   "Imports users, and creates their passports, and all details",
			Handlers: []gin.HandlerFunc{
				func(c *gin.Context) {
					// POST_ONE - post
					workspaces.HttpPostEntity(c, ImportUserActionFn)
				},
			},
			Format:         "POST_ONE",
			Action:         ImportUserActionFn,
			ResponseEntity: &OkayResponseDto{},
			Out: &workspaces.Module3ActionBody{
				Entity: "OkayResponseDto",
			},
			RequestEntity: &ImportUserActionReqDto{},
			In: &workspaces.Module3ActionBody{
				Entity: "ImportUserActionReqDto",
			},
		},
		{
			Method:        "POST",
			Url:           "/email/send",
			SecurityModel: SendEmailSecurityModel,
			Name:          "sendEmail",
			Description:   "Send a email using default root notification configuration",
			Handlers: []gin.HandlerFunc{
				func(c *gin.Context) {
					// POST_ONE - post
					workspaces.HttpPostEntity(c, SendEmailActionFn)
				},
			},
			Format:         "POST_ONE",
			Action:         SendEmailActionFn,
			ResponseEntity: &SendEmailActionResDto{},
			Out: &workspaces.Module3ActionBody{
				Entity: "SendEmailActionResDto",
			},
			RequestEntity: &SendEmailActionReqDto{},
			In: &workspaces.Module3ActionBody{
				Entity: "SendEmailActionReqDto",
			},
		},
		{
			Method:        "POST",
			Url:           "/emailProvider/send",
			SecurityModel: SendEmailWithProviderSecurityModel,
			Name:          "sendEmailWithProvider",
			Description:   "Send a text message using an specific gsm provider",
			Handlers: []gin.HandlerFunc{
				func(c *gin.Context) {
					// POST_ONE - post
					workspaces.HttpPostEntity(c, SendEmailWithProviderActionFn)
				},
			},
			Format:         "POST_ONE",
			Action:         SendEmailWithProviderActionFn,
			ResponseEntity: &SendEmailWithProviderActionResDto{},
			Out: &workspaces.Module3ActionBody{
				Entity: "SendEmailWithProviderActionResDto",
			},
			RequestEntity: &SendEmailWithProviderActionReqDto{},
			In: &workspaces.Module3ActionBody{
				Entity: "SendEmailWithProviderActionReqDto",
			},
		},
		{
			Method:        "POST",
			Url:           "/workspace/invite",
			SecurityModel: InviteToWorkspaceSecurityModel,
			Name:          "inviteToWorkspace",
			Description:   "Invite a new person (either a user, with passport or without passport)",
			Handlers: []gin.HandlerFunc{
				func(c *gin.Context) {
					// POST_ONE - post
					workspaces.HttpPostEntity(c, InviteToWorkspaceActionFn)
				},
			},
			Format:         "POST_ONE",
			Action:         InviteToWorkspaceActionFn,
			ResponseEntity: &WorkspaceInviteEntity{},
			Out: &workspaces.Module3ActionBody{
				Entity: "WorkspaceInviteEntity",
			},
			RequestEntity: &WorkspaceInviteEntity{},
			In: &workspaces.Module3ActionBody{
				Entity: "WorkspaceInviteEntity",
			},
		},
		{
			Method:        "POST",
			Url:           "/gsm/send/sms",
			SecurityModel: GsmSendSmsSecurityModel,
			Name:          "gsmSendSms",
			Description:   "Send a text message using default root notification configuration",
			Handlers: []gin.HandlerFunc{
				func(c *gin.Context) {
					// POST_ONE - post
					workspaces.HttpPostEntity(c, GsmSendSmsActionFn)
				},
			},
			Format:         "POST_ONE",
			Action:         GsmSendSmsActionFn,
			ResponseEntity: &GsmSendSmsActionResDto{},
			Out: &workspaces.Module3ActionBody{
				Entity: "GsmSendSmsActionResDto",
			},
			RequestEntity: &GsmSendSmsActionReqDto{},
			In: &workspaces.Module3ActionBody{
				Entity: "GsmSendSmsActionReqDto",
			},
		},
		{
			Method:        "POST",
			Url:           "/gsmProvider/send/sms",
			SecurityModel: GsmSendSmsWithProviderSecurityModel,
			Name:          "gsmSendSmsWithProvider",
			Description:   "Send a text message using an specific gsm provider",
			Handlers: []gin.HandlerFunc{
				func(c *gin.Context) {
					// POST_ONE - post
					workspaces.HttpPostEntity(c, GsmSendSmsWithProviderActionFn)
				},
			},
			Format:         "POST_ONE",
			Action:         GsmSendSmsWithProviderActionFn,
			ResponseEntity: &GsmSendSmsWithProviderActionResDto{},
			Out: &workspaces.Module3ActionBody{
				Entity: "GsmSendSmsWithProviderActionResDto",
			},
			RequestEntity: &GsmSendSmsWithProviderActionReqDto{},
			In: &workspaces.Module3ActionBody{
				Entity: "GsmSendSmsWithProviderActionReqDto",
			},
		},
		{
			Method:        "POST",
			Url:           "/passports/signin/classic",
			SecurityModel: ClassicSigninSecurityModel,
			Name:          "classicSignin",
			Description:   "Signin publicly to and account using class passports (email, password)",
			Handlers: []gin.HandlerFunc{
				func(c *gin.Context) {
					// POST_ONE - post
					workspaces.HttpPostEntity(c, ClassicSigninActionFn)
				},
			},
			Format:         "POST_ONE",
			Action:         ClassicSigninActionFn,
			ResponseEntity: &ClassicSigninActionResDto{},
			Out: &workspaces.Module3ActionBody{
				Entity: "ClassicSigninActionResDto",
			},
			RequestEntity: &ClassicSigninActionReqDto{},
			In: &workspaces.Module3ActionBody{
				Entity: "ClassicSigninActionReqDto",
			},
		},
		{
			Method:        "POST",
			Url:           "/passports/signup/classic",
			SecurityModel: ClassicSignupSecurityModel,
			Name:          "classicSignup",
			Description:   "Signup a user into system via public access (aka website visitors) using either email or phone number.",
			Handlers: []gin.HandlerFunc{
				func(c *gin.Context) {
					// POST_ONE - post
					workspaces.HttpPostEntity(c, ClassicSignupActionFn)
				},
			},
			Format:         "POST_ONE",
			Action:         ClassicSignupActionFn,
			ResponseEntity: &ClassicSignupActionResDto{},
			Out: &workspaces.Module3ActionBody{
				Entity: "ClassicSignupActionResDto",
			},
			RequestEntity: &ClassicSignupActionReqDto{},
			In: &workspaces.Module3ActionBody{
				Entity: "ClassicSignupActionReqDto",
			},
		},
		{
			Method:        "POST",
			Url:           "/workspaces/create",
			SecurityModel: CreateWorkspaceSecurityModel,
			Name:          "createWorkspace",
			Description:   "",
			Handlers: []gin.HandlerFunc{
				func(c *gin.Context) {
					// POST_ONE - post
					workspaces.HttpPostEntity(c, CreateWorkspaceActionFn)
				},
			},
			Format:         "POST_ONE",
			Action:         CreateWorkspaceActionFn,
			ResponseEntity: &WorkspaceEntity{},
			Out: &workspaces.Module3ActionBody{
				Entity: "WorkspaceEntity",
			},
			RequestEntity: &CreateWorkspaceActionReqDto{},
			In: &workspaces.Module3ActionBody{
				Entity: "CreateWorkspaceActionReqDto",
			},
		},
		{
			Method:        "POST",
			Url:           "/workspace/passport/check",
			SecurityModel: CheckClassicPassportSecurityModel,
			Name:          "checkClassicPassport",
			Description:   "Checks if a classic passport (email, phone) exists or not, used in multi step authentication",
			Handlers: []gin.HandlerFunc{
				func(c *gin.Context) {
					// POST_ONE - post
					workspaces.HttpPostEntity(c, CheckClassicPassportActionFn)
				},
			},
			Format:         "POST_ONE",
			Action:         CheckClassicPassportActionFn,
			ResponseEntity: &CheckClassicPassportActionResDto{},
			Out: &workspaces.Module3ActionBody{
				Entity: "CheckClassicPassportActionResDto",
			},
			RequestEntity: &CheckClassicPassportActionReqDto{},
			In: &workspaces.Module3ActionBody{
				Entity: "CheckClassicPassportActionReqDto",
			},
		},
		{
			Method:        "POST",
			Url:           "/workspace/passport/otp",
			SecurityModel: ClassicPassportOtpSecurityModel,
			Name:          "classicPassportOtp",
			Description:   "Authenticate the user publicly for classic methods using communication service, such as sms, call, or email. You need to call classicPassportRequestOtp beforehand to send a otp code, and then validate it with this API. Also checkClassicPassport action might already sent the otp, so make sure you don't send it twice.",
			Handlers: []gin.HandlerFunc{
				func(c *gin.Context) {
					// POST_ONE - post
					workspaces.HttpPostEntity(c, ClassicPassportOtpActionFn)
				},
			},
			Format:         "POST_ONE",
			Action:         ClassicPassportOtpActionFn,
			ResponseEntity: &ClassicPassportOtpActionResDto{},
			Out: &workspaces.Module3ActionBody{
				Entity: "ClassicPassportOtpActionResDto",
			},
			RequestEntity: &ClassicPassportOtpActionReqDto{},
			In: &workspaces.Module3ActionBody{
				Entity: "ClassicPassportOtpActionReqDto",
			},
		},
		{
			Method:        "POST",
			Url:           "/workspace/passport/request-otp",
			SecurityModel: ClassicPassportRequestOtpSecurityModel,
			Name:          "classicPassportRequestOtp",
			Description:   "Triggers an otp request, and will send an sms or email to the passport. This endpoint is not used for login, but rather makes a request at initial step. Later you can call classicPassportOtp to get in.",
			Handlers: []gin.HandlerFunc{
				func(c *gin.Context) {
					// POST_ONE - post
					workspaces.HttpPostEntity(c, ClassicPassportRequestOtpActionFn)
				},
			},
			Format:         "POST_ONE",
			Action:         ClassicPassportRequestOtpActionFn,
			ResponseEntity: &ClassicPassportRequestOtpActionResDto{},
			Out: &workspaces.Module3ActionBody{
				Entity: "ClassicPassportRequestOtpActionResDto",
			},
			RequestEntity: &ClassicPassportRequestOtpActionReqDto{},
			In: &workspaces.Module3ActionBody{
				Entity: "ClassicPassportRequestOtpActionReqDto",
			},
		},
	}
	return routes
}

var AbacCustomActionsCli = []cli.Command{
	AcceptInviteActionCmd,
	OauthAuthenticateActionCmd,
	UserPassportsActionCmd,
	ChangePasswordActionCmd,
	UserInvitationsActionCmd,
	ConfirmClassicPassportTotpActionCmd,
	CheckPassportMethodsActionCmd,
	QueryWorkspaceTypesPubliclyActionCmd,
	QueryUserRoleWorkspacesActionCmd,
	ReactiveSearchActionCmd,
	ImportUserActionCmd,
	SendEmailActionCmd,
	SendEmailWithProviderActionCmd,
	InviteToWorkspaceActionCmd,
	GsmSendSmsActionCmd,
	GsmSendSmsWithProviderActionCmd,
	ClassicSigninActionCmd,
	ClassicSignupActionCmd,
	CreateWorkspaceActionCmd,
	CheckClassicPassportActionCmd,
	ClassicPassportOtpActionCmd,
	ClassicPassportRequestOtpActionCmd,
}

// Use the actions bundle for ease and provide it to the ModuleProvider
// and it would gather all actions in the module level
var AbacCliActionsBundle = &workspaces.CliActionsBundle{
	Name:  "abac",
	Usage: `This is the fireback core module, which includes everything. In fact you could say workspaces is fireback itself. Maybe in the future that would be changed`,
	// Here we will include entities actions, as well as module level actions
	Subcommands: cli.Commands{
		AcceptInviteActionCmd,
		OauthAuthenticateActionCmd,
		UserPassportsActionCmd,
		ChangePasswordActionCmd,
		UserInvitationsActionCmd,
		ConfirmClassicPassportTotpActionCmd,
		CheckPassportMethodsActionCmd,
		QueryWorkspaceTypesPubliclyActionCmd,
		QueryUserRoleWorkspacesActionCmd,
		ReactiveSearchActionCmd,
		ImportUserActionCmd,
		SendEmailActionCmd,
		SendEmailWithProviderActionCmd,
		InviteToWorkspaceActionCmd,
		GsmSendSmsActionCmd,
		GsmSendSmsWithProviderActionCmd,
		ClassicSigninActionCmd,
		ClassicSignupActionCmd,
		CreateWorkspaceActionCmd,
		CheckClassicPassportActionCmd,
		ClassicPassportOtpActionCmd,
		ClassicPassportRequestOtpActionCmd,
		TimezoneGroupCliFn(),
		FileCliFn(),
		TableViewSizingCliFn(),
		AppMenuCliFn(),
		BackupTableMetaCliFn(),
		NotificationConfigCliFn(),
		PassportMethodCliFn(),
		WorkspaceInviteCliFn(),
		PendingWorkspaceInviteCliFn(),
		PreferenceCliFn(),
		TokenCliFn(),
		UserWorkspaceCliFn(),
		WorkspaceRoleCliFn(),
		UserCliFn(),
		UserProfileCliFn(),
		WorkspaceCliFn(),
		RoleCliFn(),
		WorkspaceConfigCliFn(),
		GsmProviderCliFn(),
		WorkspaceTypeCliFn(),
		EmailProviderCliFn(),
		EmailSenderCliFn(),
		PhoneConfirmationCliFn(),
		PublicJoinKeyCliFn(),
		EmailConfirmationCliFn(),
		PassportCliFn(),
		RegionalContentCliFn(),
		PublicAuthenticationCliFn(),
	},
}

func GetAbacActionsBundle() *workspaces.ModuleActionsBundle {
	return &workspaces.ModuleActionsBundle{
		Actions:   AbacCustomActions(),
		CliAction: AbacCliActionsBundle,
	}
}
func GetAbacActionsCli() []cli.Command {
	return AbacCustomActionsCli
}
