package abac

/*
*	Generated by fireback 1.2.3
*	Written by Ali Torabi.
*	Checkout the repository for licenses and contribution: https://github.com/torabian/fireback
 */
import (
	"encoding/json"
	"fmt"
	"github.com/torabian/fireback/modules/fireback"
	"github.com/urfave/cli"
	"strings"
)

func CastReactiveSearchResultFromCli(c *cli.Context) *ReactiveSearchResultDto {
	template := &ReactiveSearchResultDto{}
	fireback.HandleXsrc(c, template)
	if c.IsSet("unique-id") {
		template.UniqueId = c.String("unique-id")
	}
	if c.IsSet("phrase") {
		template.Phrase = c.String("phrase")
	}
	if c.IsSet("icon") {
		template.Icon = c.String("icon")
	}
	if c.IsSet("description") {
		template.Description = c.String("description")
	}
	if c.IsSet("group") {
		template.Group = c.String("group")
	}
	if c.IsSet("ui-location") {
		template.UiLocation = c.String("ui-location")
	}
	if c.IsSet("action-fn") {
		template.ActionFn = c.String("action-fn")
	}
	return template
}

var ReactiveSearchResultDtoCommonCliFlagsOptional = []cli.Flag{
	&cli.StringFlag{
		Name:     "x-src",
		Required: false,
		Usage:    `Import the body of the request from a file (e.g. json/yaml) on the disk`,
	},
	&cli.StringFlag{
		Name:     "wid",
		Required: false,
		Usage:    "Provide workspace id, if you want to change the data workspace",
	},
	&cli.StringFlag{
		Name:     "uid",
		Required: false,
		Usage:    "Unique Id - external unique hash to query entity",
	},
	&cli.StringFlag{
		Name:     "pid",
		Required: false,
		Usage:    " Parent record id of the same type",
	},
	&cli.StringFlag{
		Name:     "unique-id",
		Required: false,
		Usage:    `uniqueId (string)`,
	},
	&cli.StringFlag{
		Name:     "phrase",
		Required: false,
		Usage:    `phrase (string)`,
	},
	&cli.StringFlag{
		Name:     "icon",
		Required: false,
		Usage:    `icon (string)`,
	},
	&cli.StringFlag{
		Name:     "description",
		Required: false,
		Usage:    `description (string)`,
	},
	&cli.StringFlag{
		Name:     "group",
		Required: false,
		Usage:    `group (string)`,
	},
	&cli.StringFlag{
		Name:     "ui-location",
		Required: false,
		Usage:    `uiLocation (string)`,
	},
	&cli.StringFlag{
		Name:     "action-fn",
		Required: false,
		Usage:    `actionFn (string)`,
	},
}

type ReactiveSearchResultDto struct {
	UniqueId    string `json:"uniqueId" xml:"uniqueId" yaml:"uniqueId"        `
	Phrase      string `json:"phrase" xml:"phrase" yaml:"phrase"        `
	Icon        string `json:"icon" xml:"icon" yaml:"icon"        `
	Description string `json:"description" xml:"description" yaml:"description"        `
	Group       string `json:"group" xml:"group" yaml:"group"        `
	UiLocation  string `json:"uiLocation" xml:"uiLocation" yaml:"uiLocation"        `
	ActionFn    string `json:"actionFn" xml:"actionFn" yaml:"actionFn"        `
}
type ReactiveSearchResultDtoList struct {
	Items []*ReactiveSearchResultDto
}

func NewReactiveSearchResultDtoList(items []*ReactiveSearchResultDto) *ReactiveSearchResultDtoList {
	return &ReactiveSearchResultDtoList{
		Items: items,
	}
}
func (x *ReactiveSearchResultDtoList) Json() string {
	if x != nil {
		str, _ := json.MarshalIndent(x, "", "  ")
		return (string(str))
	}
	return ""
}
func (x *ReactiveSearchResultDto) Json() string {
	if x != nil {
		str, _ := json.MarshalIndent(x, "", "  ")
		return (string(str))
	}
	// Intentional trim (so strings lib is always imported)
	return strings.TrimSpace("")
}
func (x *ReactiveSearchResultDto) JsonPrint() {
	fmt.Println(x.Json())
	// Somehow to make the import always needed, makes no sense.
	_ = fireback.Body
}

// This is an experimental way to create new dtos, with exluding the pointers as helper.
func NewReactiveSearchResultDto(
	UniqueId string,
	Phrase string,
	Icon string,
	Description string,
	Group string,
	UiLocation string,
	ActionFn string,
) ReactiveSearchResultDto {
	return ReactiveSearchResultDto{
		UniqueId:    UniqueId,
		Phrase:      Phrase,
		Icon:        Icon,
		Description: Description,
		Group:       Group,
		UiLocation:  UiLocation,
		ActionFn:    ActionFn,
	}
}
