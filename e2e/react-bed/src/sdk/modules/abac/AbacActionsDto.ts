/*
*	Generated by fireback 1.2.2
*	Written by Ali Torabi.
*	Checkout the repository for licenses and contribution: https://github.com/torabian/fireback
*/
import {
    BaseDto,
    BaseEntity,
} from "../../core/definitions"
import {
    EmailProviderEntity,
} from "./EmailProviderEntity"
import {
    GsmProviderEntity,
} from "./GsmProviderEntity"
import {
    UserSessionDto,
} from "./UserSessionDto"
import {
    WorkspaceEntity,
} from "./WorkspaceEntity"
  export class QueryUserRoleWorkspacesResDtoRoles {
  public name?: string | null;
  public uniqueId?: string | null;
  /**
  Capabilities related to this role which are available
  */
  public capabilities?: string[] | null;
  }
  export class CheckClassicPassportResDtoOtpInfo {
  public suspendUntil?: number | null;
  public validUntil?: number | null;
  public blockedUntil?: number | null;
  /**
  The amount of time left to unblock for next request
  */
  public secondsToUnblock?: number | null;
  }
export class AcceptInviteActionReqDto {
  /**
  The invitation id which will be used to process
  */
  public invitationUniqueId?: string | null;
public static Fields = {
      invitationUniqueId: 'invitationUniqueId',
}
}
export class OauthAuthenticateActionReqDto {
  /**
  The token that Auth2 provider returned to the front-end, which will be used to validate the backend
  */
  public token?: string | null;
  /**
  The service name, such as "google" which later backend will use to authorize the token and create the user.
  */
  public service?: string | null;
public static Fields = {
      token: 'token',
      service: 'service',
}
}
export class OauthAuthenticateActionResDto {
  public session?: UserSessionDto | null;
      sessionId?: string | null;
  /**
  The next possible action which is suggested.
  */
  public next?: string[] | null;
public static Fields = {
          sessionId: 'sessionId',
      session$: 'session',
      session: UserSessionDto.Fields,
      next: 'next',
}
}
export class UserPassportsActionResDto {
  /**
  The passport value, such as email address or phone number
  */
  public value?: string | null;
  /**
  Unique identifier of the passport to operate some action on top of it
  */
  public uniqueId?: string | null;
  /**
  The type of the passport, such as email, phone number
  */
  public type?: string | null;
  /**
  Regardless of the secret, user needs to confirm his secret. There is an extra action to confirm user totp, could be used after signup or prior to login.
  */
  public totpConfirmed?: boolean | null;
public static Fields = {
      value: 'value',
      uniqueId: 'uniqueId',
      type: 'type',
      totpConfirmed: 'totpConfirmed',
}
}
export class ChangePasswordActionReqDto {
  /**
  New password meeting the security requirements.
  */
  public password?: string | null;
  /**
  The passport uniqueId (not the email or phone number) which password would be applied to. Don't confuse with value.
  */
  public uniqueId?: string | null;
public static Fields = {
      password: 'password',
      uniqueId: 'uniqueId',
}
}
export class ConfirmClassicPassportTotpActionReqDto {
  /**
  Passport value, email or phone number which is already successfully registered.
  */
  public value?: string | null;
  /**
  Password related to the passport. Totp is only available for passports with a password. Basically totp is protecting passport, not otp over email or sms.
  */
  public password?: string | null;
  /**
  The totp code generated by authenticator such as google or microsft apps.
  */
  public totpCode?: string | null;
public static Fields = {
      value: 'value',
      password: 'password',
      totpCode: 'totpCode',
}
}
export class ConfirmClassicPassportTotpActionResDto {
  public session?: UserSessionDto | null;
      sessionId?: string | null;
public static Fields = {
          sessionId: 'sessionId',
      session$: 'session',
      session: UserSessionDto.Fields,
}
}
export class CheckPassportMethodsActionResDto {
  public email?: boolean | null;
  public phone?: boolean | null;
  public google?: boolean | null;
  public googleOAuthClientKey?: string | null;
  public enabledRecaptcha2?: boolean | null;
  public recaptcha2ClientKey?: string | null;
public static Fields = {
      email: 'email',
      phone: 'phone',
      google: 'google',
      googleOAuthClientKey: 'googleOAuthClientKey',
      enabledRecaptcha2: 'enabledRecaptcha2',
      recaptcha2ClientKey: 'recaptcha2ClientKey',
}
}
export class QueryWorkspaceTypesPubliclyActionResDto {
  public title?: string | null;
  public description?: string | null;
  public uniqueId?: string | null;
  public slug?: string | null;
public static Fields = {
      title: 'title',
      description: 'description',
      uniqueId: 'uniqueId',
      slug: 'slug',
}
}
export class QueryUserRoleWorkspacesActionResDto {
  public name?: string | null;
  /**
  Workspace level capabilities which are available
  */
  public capabilities?: string[] | null;
  public uniqueId?: string | null;
  public roles?: QueryUserRoleWorkspacesResDtoRoles[] | null;
public static Fields = {
      name: 'name',
      capabilities: 'capabilities',
      uniqueId: 'uniqueId',
      roles$: 'roles',
      roles: {
      name: 'name',
      uniqueId: 'uniqueId',
      capabilities: 'capabilities',
      },
}
}
export class ImportUserActionReqDto {
  public path?: string | null;
public static Fields = {
      path: 'path',
}
}
export class SendEmailActionReqDto {
  public toAddress?: string | null;
  public body?: string | null;
public static Fields = {
      toAddress: 'toAddress',
      body: 'body',
}
}
export class SendEmailActionResDto {
  public queueId?: string | null;
public static Fields = {
      queueId: 'queueId',
}
}
export class SendEmailWithProviderActionReqDto {
  public emailProvider?: EmailProviderEntity | null;
      emailProviderId?: string | null;
  public toAddress?: string | null;
  public body?: string | null;
public static Fields = {
          emailProviderId: 'emailProviderId',
      emailProvider$: 'emailProvider',
      emailProvider: EmailProviderEntity.Fields,
      toAddress: 'toAddress',
      body: 'body',
}
}
export class SendEmailWithProviderActionResDto {
  public queueId?: string | null;
public static Fields = {
      queueId: 'queueId',
}
}
export class GsmSendSmsActionReqDto {
  public toNumber?: string | null;
  public body?: string | null;
public static Fields = {
      toNumber: 'toNumber',
      body: 'body',
}
}
export class GsmSendSmsActionResDto {
  public queueId?: string | null;
public static Fields = {
      queueId: 'queueId',
}
}
export class GsmSendSmsWithProviderActionReqDto {
  public gsmProvider?: GsmProviderEntity | null;
      gsmProviderId?: string | null;
  public toNumber?: string | null;
  public body?: string | null;
public static Fields = {
          gsmProviderId: 'gsmProviderId',
      gsmProvider$: 'gsmProvider',
      gsmProvider: GsmProviderEntity.Fields,
      toNumber: 'toNumber',
      body: 'body',
}
}
export class GsmSendSmsWithProviderActionResDto {
  public queueId?: string | null;
public static Fields = {
      queueId: 'queueId',
}
}
export class ClassicSigninActionReqDto {
  public value?: string | null;
  public password?: string | null;
  /**
  Accepts login with totp code. If enabled, first login would return a success response with next[enter-totp] value and ui can understand that user needs to be navigated into the screen other screen.
  */
  public totpCode?: string | null;
  /**
  Session secret when logging in to the application requires more steps to complete.
  */
  public sessionSecret?: string | null;
public static Fields = {
      value: 'value',
      password: 'password',
      totpCode: 'totpCode',
      sessionSecret: 'sessionSecret',
}
}
export class ClassicSigninActionResDto {
  public session?: UserSessionDto | null;
      sessionId?: string | null;
  /**
  The next possible action which is suggested.
  */
  public next?: string[] | null;
  /**
  In case the account doesn't have totp, but enforced by installation, this value will contain the link
  */
  public totpUrl?: string | null;
  /**
  Returns a secret session if the authentication requires more steps.
  */
  public sessionSecret?: string | null;
public static Fields = {
          sessionId: 'sessionId',
      session$: 'session',
      session: UserSessionDto.Fields,
      next: 'next',
      totpUrl: 'totpUrl',
      sessionSecret: 'sessionSecret',
}
}
export class ClassicSignupActionReqDto {
  public value?: string | null;
  /**
  Required when the account creation requires recaptcha, or otp approval first. If such requirements are there, you first need to follow the otp apis, get the session secret and pass it here to complete the setup.
  */
  public sessionSecret?: string | null;
  public type?: "phonenumber" | "email" | null;
  public password?: string | null;
  public firstName?: string | null;
  public lastName?: string | null;
  public inviteId?: string | null;
  public publicJoinKeyId?: string | null;
  public workspaceTypeId?: string | null;
public static Fields = {
      value: 'value',
      sessionSecret: 'sessionSecret',
      type: 'type',
      password: 'password',
      firstName: 'firstName',
      lastName: 'lastName',
      inviteId: 'inviteId',
      publicJoinKeyId: 'publicJoinKeyId',
      workspaceTypeId: 'workspaceTypeId',
}
}
export class ClassicSignupActionResDto {
  /**
  Returns the user session in case that signup is completely successful.
  */
  public session?: UserSessionDto | null;
      sessionId?: string | null;
  /**
  If time based otp is available, we add it response to make it easier for ui.
  */
  public totpUrl?: string | null;
  /**
  Returns true and session will be empty if, the totp is required by the installation. In such scenario, you need to forward user to setup totp screen.
  */
  public continueToTotp?: boolean | null;
  /**
  Determines if user must complete totp in order to continue based on workspace or installation
  */
  public forcedTotp?: boolean | null;
public static Fields = {
          sessionId: 'sessionId',
      session$: 'session',
      session: UserSessionDto.Fields,
      totpUrl: 'totpUrl',
      continueToTotp: 'continueToTotp',
      forcedTotp: 'forcedTotp',
}
}
export class CreateWorkspaceActionReqDto {
  public name?: string | null;
  public workspace?: WorkspaceEntity | null;
  public workspaceId?: string | null;
public static Fields = {
      name: 'name',
      workspace$: 'workspace',
      workspace: WorkspaceEntity.Fields,
      workspaceId: 'workspaceId',
}
}
export class CheckClassicPassportActionReqDto {
  public value?: string | null;
  /**
  This can be the value of recaptcha2, recaptch3, or generate security image or voice for verification. Will be used based on the configuration.
  */
  public securityToken?: string | null;
public static Fields = {
      value: 'value',
      securityToken: 'securityToken',
}
}
export class CheckClassicPassportActionResDto {
  /**
  The next possible action which is suggested.
  */
  public next?: string[] | null;
  /**
  Extra information that can be useful actually when doing onboarding. Make sure sensetive information doesn't go out.
  */
  public flags?: string[] | null;
  /**
  If the endpoint automatically triggers a send otp, then it would be holding that information, Also the otp information can become available.
  */
  public otpInfo?: CheckClassicPassportResDtoOtpInfo | null;
public static Fields = {
      next: 'next',
      flags: 'flags',
      otpInfo$: 'otpInfo',
      otpInfo: {
      suspendUntil: 'suspendUntil',
      validUntil: 'validUntil',
      blockedUntil: 'blockedUntil',
      secondsToUnblock: 'secondsToUnblock',
      },
}
}
export class ClassicPassportOtpActionReqDto {
  public value?: string | null;
  public otp?: string | null;
public static Fields = {
      value: 'value',
      otp: 'otp',
}
}
export class ClassicPassportOtpActionResDto {
  public session?: UserSessionDto | null;
      sessionId?: string | null;
  /**
  If time based otp is available, we add it response to make it easier for ui.
  */
  public totpUrl?: string | null;
  /**
  The session secret will be used to call complete user registeration api.
  */
  public sessionSecret?: string | null;
  /**
  If return true, means the OTP is correct and user needs to be created before continue the authentication processs.
  */
  public continueWithCreation?: boolean | null;
public static Fields = {
          sessionId: 'sessionId',
      session$: 'session',
      session: UserSessionDto.Fields,
      totpUrl: 'totpUrl',
      sessionSecret: 'sessionSecret',
      continueWithCreation: 'continueWithCreation',
}
}
export class ClassicPassportRequestOtpActionReqDto {
  /**
  Passport value (email, phone number) which would be recieving the otp code.
  */
  public value?: string | null;
public static Fields = {
      value: 'value',
}
}
export class ClassicPassportRequestOtpActionResDto {
  public suspendUntil?: number | null;
  public validUntil?: number | null;
  public blockedUntil?: number | null;
  /**
  The amount of time left to unblock for next request
  */
  public secondsToUnblock?: number | null;
public static Fields = {
      suspendUntil: 'suspendUntil',
      validUntil: 'validUntil',
      blockedUntil: 'blockedUntil',
      secondsToUnblock: 'secondsToUnblock',
}
}