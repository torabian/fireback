/*
*	Generated by fireback 1.2.3
*	Written by Ali Torabi.
*	Checkout the repository for licenses and contribution: https://github.com/torabian/fireback
*/
    import {
        BaseDto,
        BaseEntity,
    } from "../../core/definitions"
// In this section we have sub entities related to this object
// Class body
export type InvoiceEntityKeys =
  keyof typeof InvoiceEntity.Fields;
export class InvoiceEntity extends BaseEntity {
  public children?: InvoiceEntity[] | null;
  /**
  Explanation about the invoice, the reason someone needs to pay
  */
  public title?: string | null;
    public titleExcerpt?: string[] | null;
  /**
  Amount of the invoice which has to be payed
  */
  public amount?: {amount: number, currency: string, formatted?: string} | null;
  /**
  The unique key, when an event related to the invoice happened it would be triggered. For example if another module wants to initiate the payment, and after payment success, wants to run some code, it would be listening to invoice events and notificationKey will come.
  */
  public notificationKey?: string | null;
  /**
  Final status of the invoice from a accounting perspective
  */
  public finalStatus?: "payed" | "pending" | null;
  public static Navigation = {
      edit(uniqueId: string, locale?: string) {
          return `${locale ? '/' + locale : '..'}/invoice/edit/${uniqueId}`;
      },
      create(locale?: string) {
          return `${locale ? '/' + locale : '..'}/invoice/new`;
      },
      single(uniqueId: string, locale?: string) {
          return `${locale ? '/' + locale : '..'}/invoice/${uniqueId}`;
      },
      query(params: any = {}, locale?: string) {
          return `${locale ? '/' + locale : '..'}/invoices`;
      },
      /**
      * Use R series while building router in CRA or nextjs, or react navigation for react Native
      * Might be useful in Angular as well.
      **/
      Redit: "invoice/edit/:uniqueId",
      Rcreate: "invoice/new",
      Rsingle: "invoice/:uniqueId",
      Rquery: "invoices",
  };
  public static definition = {
  "rpc": {
    "query": {}
  },
  "permRewrite": {
    "replace": "root.modules",
    "with": "root.manage"
  },
  "name": "invoice",
  "features": {},
  "security": {
    "writeOnRoot": true,
    "readOnRoot": true
  },
  "gormMap": {},
  "fields": [
    {
      "name": "title",
      "description": "Explanation about the invoice, the reason someone needs to pay",
      "type": "text",
      "validate": "required",
      "computedType": "string",
      "gormMap": {}
    },
    {
      "name": "amount",
      "description": "Amount of the invoice which has to be payed",
      "type": "money?",
      "validate": "required",
      "computedType": "{amount: number, currency: string, formatted?: string}",
      "gormMap": {}
    },
    {
      "name": "notificationKey",
      "description": "The unique key, when an event related to the invoice happened it would be triggered. For example if another module wants to initiate the payment, and after payment success, wants to run some code, it would be listening to invoice events and notificationKey will come.",
      "type": "string",
      "computedType": "string",
      "gormMap": {}
    },
    {
      "name": "finalStatus",
      "description": "Final status of the invoice from a accounting perspective",
      "type": "enum",
      "validate": "required",
      "of": [
        {
          "k": "payed",
          "description": "Payed"
        },
        {
          "k": "pending",
          "description": "Pending"
        }
      ],
      "computedType": "\"payed\" | \"pending\"",
      "gormMap": {}
    }
  ],
  "description": "Invoice is a billable value, which a party recieves, and needs to pay it by different means. Invoice keeps information such as reason, total amount, tax amount and other details. An invoice can be payed via different payment methods."
}
public static Fields = {
  ...BaseEntity.Fields,
      title: `title`,
      amount: `amount`,
      notificationKey: `notificationKey`,
      finalStatus: `finalStatus`,
}
}
